%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: Haskell
file_extensions:
  - hs
scope: source.haskell

variables:
  # Comments
  no_comment_ahead: '(?!{{comment_begin}})'
  comment_ahead: '(?={{comment_begin}})'
  comment_begin: '--+(?:{{comment_first_char}}|$)'
  comment_first_char: '[ \t\w"''(),;\[\]`{}]'

  # In case this regex seems overly general,
  # note that Haskell permits the definition of new operators
  # which can be nearly any string of punctuation characters,
  # such as $%^&*.
  operator_char: '[*|!%&$@#?~+:\-.=</>\\]'
  operator_infix: '{{operator_char}}+'
  operator_parens: '(?:{{no_comment_ahead}}{{operator_infix}}|,+)'

  # Identifiers
  con_id: (?:[[:upper:]][\w']*)
  var_id: (?:(?!{{reserved_id}})[[:lower:]][\w']*)
  reserved_id: |-
    (?x:
      case | class | data | default | deriving | do | else
    | foreign | if | import | in | infix | infixl
    | infixr | instance | let | module | newtype | of
    | then | type | where | _
    ){{break}}

  break: (?![\w'])

  # Escaped Characters
  escape_chars: |-
    (?x:NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI
      |DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL
      |[abfnrtv\\\"'\&])
  escape_sequence: |-
    (?x:
      (\\{{escape_chars}})   # Escapes
      | (\\[0-9]+)           # Decimal Escapes
      | (\\o[0-7]+)          # Octal Escapes
      | (\\x[0-9A-Fa-f]+)    # Hexadecimal Escapes
      | (\^[A-Z@\[\]\\\^_])  # Control Chars
    )

contexts:
  prototype:
    - include: comment
    - include: preprocessor
  
  main:
    - include: statement
    - include: expression

  statement:
    - include: declaration
    - include: import

  expression:
    - include: keyword
    - include: operator
    - include: constant
    - include: string
    - include: splice
    - include: group
    - include: list
    - include: ident
    - match: ','
      scope: punctuation.separator.comma.haskell

  group:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      push:
        - meta_scope: meta.group.haskell
        - match: \)
          scope: punctuation.section.group.end.haskell
          pop: true
        - include: expression

  list:
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push:
        - meta_scope: meta.sequence.haskell
        - match: \]
          scope: punctuation.section.sequence.end.haskell
          pop: true
        - match: ','
          scope: punctuation.separator.sequence.haskell
        - include: expression

  constant:
    - match: \[\]
      scope: constant.language.empty-list.haskell
    - include: constant_unit
    - include: number
    - match: '{{con_id}}'
      scope: constant.other.haskell

  constant_unit:
    - match: \(\)
      scope: constant.language.unit.haskell

  number:
    - match: (0[oO])([0-7]+){{break}}
      scope: meta.number.integer.octal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: (0[xX])(\h+){{break}}
      scope: meta.number.integer.hexadecimal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
    - match: \d+{{break}}
      scope: meta.number.integer.decimal.haskell constant.numeric.value.haskell

  declaration:
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
      push:
        - meta_scope: meta.declaration.module.haskell
        - match: where{{break}}
          scope: keyword.control.context.haskell
          pop: true
        - match: ({{con_id}})(\.)
          captures:
            1: variable.namespace.haskell
            2: punctuation.accessor.dot.haskell
        - match: '{{con_id}}'
          scope: entity.name.namespace.haskell
        - include: module_exports
    - match: class{{break}}
      scope: keyword.declaration.class.haskell
      push:
        - meta_scope: meta.declaration.class.haskell
        - match: where{{break}}
          scope: keyword.control.context.haskell
          pop: true
        - match: |-
            (?x:Monad|Monadoid|Functor|Applicative|Foldableble|Traversable
              |Eq|Ord|Read|Show|Num|Fractional|Rational|Enum|Bounded
              |Real|RealFrac|RealFloat|Integral|Floating){{break}}
          scope: support.class.prelude.haskell
        - include: ident_inherited_class
        - include: ident_generic_type
        - include: operator_big_arrow
    - match: instance{{break}}
      scope: keyword.declaration.haskell
      push:
        - meta_scope: meta.declaration.instance.haskell
        - match: where{{break}}|$
          scope: keyword.control.context.haskell
          pop: true
        - include: type_signature
    - match: '^(\s*)({{var_id}}|\(({{operator_parens}})\))\s*(::|∷)'
      captures:
        2: entity.name.function.haskell
        3: keyword.operator.infix.haskell
        4: keyword.other.double-colon.haskell
      push:
        - meta_scope: meta.function.type-declaration.haskell
        - match: ^(?!\s*(?:--|{-|$)|\1\s)
          pop: true
        - include: type_signature
    - match: (deriving|via)\s*\(
      captures:
        1: keyword.other.haskell
      push:
        - meta_scope: meta.deriving.haskell
        - match: \)
          pop: true
        - include: ident_inherited_class

  import:
    - match: import{{break}}
      scope: keyword.control.import.haskell
      push:
        - meta_scope: meta.import.haskell
        - match: ($|;)
          pop: true
        - match: (?:qualified|as|hiding){{break}}
          scope: keyword.control.import.haskell
        - include: module_name
        - include: module_exports

  keyword:
    - match: (?:do|in){{break}}
      scope: keyword.control.context.haskell
    - match: (?:newtype|type){{break}}
      scope: keyword.declaration.type.haskell
    - match: (?:data){{break}}
      scope: keyword.declaration.data.haskell
    - match: (?:deriving){{break}}
      scope: keyword.declaration.data.haskell
    - match: (?:case|of){{break}}
      scope: keyword.control.conditional.select.haskell  # the construct is commonly called "select"
    - match: (?:let|where){{break}}
      scope: keyword.declaration.variable.haskell
    - match: (?:return){{break}}
      scope: keyword.control.flow.return.haskell
    - match: (?:default|otherwise){{break}}
      scope: keyword.other.haskell
    - match: (?:if){{break}}
      scope: keyword.control.conditional.if.haskell
    - match: (?:then){{break}}
      scope: keyword.control.conditional.then.haskell
    - match: (?:else){{break}}
      scope: keyword.control.conditional.else.haskell

  operator:
    - match: (`)[ \w'.]+(`)
      # Haskell allows any ordinary function application (elem 4 [1..10])
      # to be rewritten as an infix expression (4 `elem` [1..10])."
      scope: keyword.operator.function.infix.haskell
      captures:
        1: punctuation.definition.function.begin.haskell
        2: punctuation.definition.function.end.haskell
    - match: (`)[^`]*?(?:(`)|{{comment_ahead}})
      scope: invalid.illegal.operator.haskell
    - match: 'infix[lr]?{{break}}'
      scope: keyword.operator.haskell
    - match: (\d+)(?:(\.)(\d+)([eE][-+]?\d+)?|([eE][-+]?\d+)){{break}}
      scope: meta.number.float.decimal.haskell
      captures:
        1: constant.numeric.value.haskell
        2: punctuation.separator.decimal.haskell
        3: constant.numeric.value.haskell
        4: constant.numeric.value.exponent.haskell
        5: constant.numeric.value.exponent.haskell
    - match: '{{operator_infix}}'
      scope: keyword.operator.haskell
    - include: operator_paren

  operator_arrow:
    - match: '(?:->|→)'
      scope: keyword.other.arrow.haskell

  operator_big_arrow:
    - match: '(?:=>|⇒)'
      scope: keyword.other.big-arrow.haskell

  operator_paren:
    - match: \(({{operator_parens}})\)
      scope: variable.function.infix.haskell
      captures:
        1: keyword.operator.haskell

  preprocessor:
    # In addition to Haskell's "native" syntax,
    # GHC permits the C preprocessor to be run on a source file.
    - match: ^\s*((#)\s*\w+)
      scope: meta.preprocessor.c
      captures:
        1: keyword.directive.other.c
        2: punctuation.definition.preprocessor.c
    - include: pragma

  string:
    - match: \"
      scope: punctuation.definition.string.begin.haskell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.string.haskell string.quoted.double.haskell
        - match: \"|$
          scope: punctuation.definition.string.end.haskell
          pop: true
        - match: '{{escape_sequence}}'
          captures:
            1: constant.character.escape.haskell
            2: constant.character.escape.decimal.haskell
            3: constant.character.escape.octal.haskell
            4: constant.character.escape.hexadecimal.haskell
            5: constant.character.escape.control.haskell
    - match: |-
        (?x)
        (')
        (?:
          ([\ -\[\]-~])          # Basic Char
          | {{escape_sequence}}  # Escapes
        )
        ([^']*?)
        (?:(')|{{comment_ahead}})
      scope: meta.string.haskell string.quoted.single.haskell
      captures:
        1: punctuation.definition.string.begin.haskell
        2: constant.character.literal.haskell
        3: constant.character.escape.haskell
        4: constant.character.escape.decimal.haskell
        5: constant.character.escape.octal.haskell
        6: constant.character.escape.hexadecimal.haskell
        7: constant.character.escape.control.haskell
        8: invalid.illegal.expected-closing-quotation.haskell
        9: punctuation.definition.string.end.haskell

  splice:
    - match: '\[(?:|e|d|t|p)\|'
      comment: Points out splices in ast quotes
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: true
        - match: \$\(
          scope: keyword.other.splice.haskell
        - match: \$
          scope: string.quasiquoted.haskell
        - match: '[^$]*'
          scope: string.quasiquoted.haskell
    - match: \$\(
      comment: Highlight the beginning of a splice.
      scope: keyword.other.splice.haskell
    - match: '\[[\w'']*\|'
      scope: keyword.other.quasibracket.haskell
      push:
        - meta_scope: meta.other.quasiquote.haskell
        - match: '(.*)(\|\])'
          captures:
            1: string.quasiquoted.haskell
            2: keyword.other.quasibracket.haskell
          pop: true
        - match: .*
          scope: string.quasiquoted.haskell

  ident:
    - match: |-
        (?x)
        (abs|acos|acosh|all|and|any|appendFile|asTypeOf|asin|asinh|atan|atan2|atanh
        |break
        |ceiling|compare|concat|concatMap|const|cos|cosh|curry|cycle
        |decodeFloat|div|divMod|drop|dropWhile
        |either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error
        |errorWithoutStackTrace|even|exp|exponent
        |fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldMap|foldl|foldl1|foldr
        |foldr1|fromEnum|fromInteger|fromIntegral|fromRational|fst
        |gcd|getChar|getContents|getLine
        |head
        |id|init|interact|ioError|isDenormalized|isIEEE|isInfinite|isNaN|isNegativeZero|iterate
        |last|lcm|length|lex|lines|log|logBase|lookup
        |map|mapM|mapM_|mappend|max|maxBound|maximum|maybe|mconcat|mempty|min|minBound|minimum|mod
        |negate|not|notElem|null
        |odd|or|otherwise
        |pi|pred|print|product|properFraction|pure|putChar|putStr|putStrLn
        |quot|quotRem|read
        |readFile|readIO|readList|readLn|readParen|reads|readsPrec|realToFrac|recip|rem|repeat
        |replicate|return|reverse|round|scaleFloat
        |scanl|scanl1|scanr|scanr1|seq|sequence|sequenceA|sequence_|show|showChar|showList
        |showParen|showString|shows|showsPrec|significand|signum|sin|sinh|snd|span|splitAt|sqrt
        |subtract|succ|sum|tail
        |take|takeWhile|tan|tanh|toEnum|toInteger|toRational|traverse|truncate|uncurry
        |undefined|unlines|until|unwords|unzip|unzip3|userError|words
        |writeFile
        |zip|zip3|zipWith|zipWith3
        ){{break}}
      scope: support.function.prelude.haskell
    - match: '[[:lower:]][^\s{{operator_char}}),\]{}]+'
      scope: meta.name.haskell

  ident_function:
    - match: '{{var_id}}'
      scope: variable.function.haskell

  ident_inherited_class:
    - match: '{{con_id}}'
      scope: entity.other.inherited-class.haskell

  ident_generic_type:
    - match: '{{var_id}}'
      scope: variable.other.generic-type.haskell

  ident_type:
    - match: '{{con_id}}'
      scope: storage.type.haskell

  comment:
    - match: '(--+)(?:{{comment_first_char}}.*)?$\n?'
      scope: comment.line.double-dash.haskell
      captures:
        1: punctuation.definition.comment.haskell
    - include: block_comment

  block_comment:
    - match: '\{-(?!#)'
      scope: punctuation.definition.comment.begin.haskell
      push:
        - meta_scope: comment.block.haskell
        - match: '\{-#'
          push:
            - match: '-\}'
              pop: true
            - include: block_comment
        - include: block_comment
        - match: '-\}'
          scope: punctuation.definition.comment.end.haskell
          pop: true

  module_exports:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      push:
        - meta_scope: meta.declaration.exports.haskell
        - match: \)
          scope: punctuation.section.group.end.haskell
          pop: true
        - include: ident_function
        - include: ident_type
        - match: ','
          scope: punctuation.separator.comma.haskell
        - include: operator_paren
        - match: \({{no_comment_ahead}}.*?\)
          comment: So named because I don't know what to call this.
          scope: meta.other.unknown.haskell
  
  module_name:
    - match: ({{con_id}})(\.)?
      captures:
        1: variable.namespace.haskell
        2: punctuation.accessor.dot.haskell
  
  type_signature:
    - include: pragma
    - include: operator_arrow
    - include: operator_big_arrow
    - include: ident_generic_type
    - include: ident_type
    - include: constant_unit

  pragma:
    - match: '\{-#'
      push:
        - meta_scope: meta.preprocessor.haskell
        - match: '#-\}'
          pop: true
        - match: |-
            (?x:
              LANGUAGE|OPTIONS_GHC|OPTIONS_HADDOCK|INCLUDE|WARNING|DEPRECATED|MINIMAL
              |UNPACK|NOUNPACK|SOURCE|OVERLAPPING|OVERLAPPABLE|OVERLAPS
              |INCOHERENT|INLINE|NOINLINE|INLINABLE|CONLIKE|LINE|RULES
              |SPECIALIZE|SPECIALISE
            ){{break}}
          # https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pragmas
          scope: keyword.directive.other.haskell
