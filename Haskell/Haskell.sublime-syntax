%YAML 1.2
---
# https://ghc.gitlab.haskell.org/ghc/doc/users_guide
# https://www.haskell.org/onlinereport/haskell2010
# https://www.sublimetext.com/docs/syntax.html
name: Haskell
scope: source.haskell
version: 2

file_extensions:
  - hs
  - hs-boot
  - hsig

first_line_match: |-
  (?xi:
    ^ \#! .* \b(cabal|runhaskell|stack)\b       # shebang
  | ^ \s* -- .*? -\*- .*? \bhaskell\b .*? -\*-  # editorconfig
  )

###############################################################################

variables:
  # 2.2 Lexical Program Structure
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-160002.2
  special: '[(),;\[\]`{}]'
  symbol: '[\p{S}\p{P}&&[^_"''{{special}}]]'
  ascii_symbol: '[!#$%&⋆+./<=>?@\\\^|\-~:]'
  unicode_symbol: '[[:punct:]&&[^:ascii:]]'

  # 2.3 Comments
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
  no_comment_ahead: '(?!{{comment_begin}})'
  comment_ahead: '(?={{comment_begin}})'
  comment_begin: '--+(?:{{comment_first_char}}|$)'
  comment_first_char: '[\s\w"''{{special}}]'

  # 2.4 Identifiers and Operators
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
  id: (?:(?!{{reserved_id}})[\w']*(#)*)
  con_id: (?:[[:upper:]][\w']*(#)*)
  var_id: (?:(?!{{reserved_id}})[[:lower:]_][\w']*(#)*)
  reserved_id: |-
    (?x:
      _ | case | class | data | default | deriving | do | else | family | forall
    | foreign | if | import | in | infix | infixl | infixr | instance | let | mdo
    | module | newtype | of | proc | rec | signature | then | type | via | where
    ){{break}}
  break: (?![\w'#])

  # GHC 6.9.5 Numeric underscores
  # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/numeric_underscores.html
  bin_digit: '[01_]'
  dec_digit: '[\d_]'
  hex_digit: '[\h_]'
  oct_digit: '[0-7_]'
  dec_exponent: (?:[eE][-+]?\d+)
  hex_exponent: (?:[pP][-+]?\d+)

  # In case this regex seems overly general, note that Haskell permits
  # the definition of new operators which can be nearly any string
  # of punctuation characters, such as $%^&*.
  operator_symbol: (?:{{symbol}}+)
  operator_parens: (?:{{no_comment_ahead}}{{operator_symbol}})

  operator_double_colon: (?:::|∷)
  operator_big_arrow: (?:=>|⇒)
  operator_left_arrow: (?:<-|←)
  operator_right_arrow: (?:->|→)

  consym: (?:[:]{{varsym}})
  varsym: (?:[{{symbol}}&&[^:]]{{symbol}}*)

  # 2.6 Character and String Literals
  # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
  escape_chars: |-
    (?x:
      NUL | SOH | STX | ETX | EOT | ENQ | ACK | BEL | BS | HT | LF | VT | FF
    | CR | SO | SI | DLE | DC1 | DC2 | DC3 | DC4 | NAK | SYN | ETB | CAN | EM
    | SUB | ESC | FS | GS | RS | US | SP | DEL
    | [abfnrtv\\\"'\&]
    )
  escape_sequence: |-
    (?x:
        (\\{{escape_chars}}) # Escapes
      | (\\[0-9]+)           # Decimal Escapes
      | (\\o[0-7]+)          # Octal Escapes
      | (\\x[0-9A-Fa-f]+)    # Hexadecimal Escapes
      | (\^[A-Z@\[\]\\\^_])  # Control Chars
    )

  # GHC 6.20 Pragmas
  pragma_directives: |-
    (?x:
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html
      LANGUAGE | OPTIONS | OPTIONS_GHC | OPTIONS_HADDOCK | INCLUDE | WARNING
    | DEPRECATED | MINIMAL | INLINE | NOINLINE | INLINABLE | CONLIKE | LINE
    | COLUMN | RULES | SPECIALIZE | UNPACK | NOUNPACK | SOURCE | COMPLETE
    | OVERLAPPING | OVERLAPPABLE | OVERLAPS | INCOHERENT | CTYPE
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/profiling.html
    | CORE | GENERATED | SCC
    ){{break}}

  # https://wiki.haskell.org/Language_extensions
  # https://github.com/JustusAdam/language-haskell
  pragma_deprecated_constants: |-
    (?:No)?(?x:
      AutoDeriveTypeable | DatatypeContexts | DoRec | IncoherentInstances
    | MonadFailDesugaring | MonoPatBinds | NullaryTypeClasses
    | OverlappingInstances | PatternSignatures | RecordPuns | RelaxedPolyRec
    ){{break}}

  # https://wiki.haskell.org/Language_extensions
  # https://github.com/JustusAdam/language-haskell
  pragma_extension_constants: |-
    (?:No)?(?x:
      AllowAmbiguousTypes | AlternativeLayoutRule
    | AlternativeLayoutRuleTransitional | Arrows | BangPatterns | BinaryLiterals
    | CApiFFI | CPP | CUSKs | ConstrainedClassMethods | ConstraintKinds
    | DataKinds | DefaultSignatures | DeriveAnyClass | DeriveDataTypeable
    | DeriveFoldable | DeriveFunctor | DeriveGeneric | DeriveLift
    | DeriveTraversable | DerivingStrategies | DerivingVia
    | DisambiguateRecordFields | DoAndIfThenElse | BlockArguments
    | DuplicateRecordFields | EmptyCase | EmptyDataDecls | EmptyDataDeriving
    | ExistentialQuantification | ExplicitForAll | ExplicitNamespaces
    | ExtendedDefaultRules | FlexibleContexts | FlexibleInstances
    | ForeignFunctionInterface | FunctionalDependencies | GADTSyntax | GADTs
    | GHCForeignImportPrim | Generali(?:s | z)edNewtypeDeriving | ImplicitParams
    | ImplicitPrelude | ImportQualifiedPost | ImpredicativeTypes
    | TypeFamilyDependencies | InstanceSigs | ApplicativeDo | InterruptibleFFI
    | JavaScriptFFI | KindSignatures | LambdaCase | LexicalNegation
    | LiberalTypeSynonyms | LinearTypes | MagicHash | MonadComprehensions
    | MonoLocalBinds | MonomorphismRestriction | MultiParamTypeClasses
    | MultiWayIf | NumericUnderscores | NPlusKPatterns | NamedFieldPuns
    | NamedWildCards | NegativeLiterals | HexFloatLiterals
    | NondecreasingIndentation | NumDecimals | OverloadedLabels | OverloadedLists
    | OverloadedStrings | PackageImports | ParallelArrays | ParallelListComp
    | PartialTypeSignatures | PatternGuards | PatternSynonyms | PolyKinds
    | PolymorphicComponents | QuantifiedConstraints | PostfixOperators
    | QualifiedDo | QuasiQuotes | Rank2Types | RankNTypes | RebindableSyntax
    | RecordWildCards | RecursiveDo | RelaxedLayout | RoleAnnotations | Safe
    | ScopedTypeVariables | StandaloneDeriving | StarIsType | StaticPointers
    | Strict | StrictData | TemplateHaskell | TemplateHaskellQuotes
    | StandaloneKindSignatures | TraditionalRecordSyntax | TransformListComp
    | Trustworthy | TupleSections | TypeApplications | TypeInType | TypeFamilies
    | TypeOperators | TypeSynonymInstances | UnboxedTuples | UnboxedSums
    | UndecidableInstances | UndecidableSuperClasses | UnicodeSyntax
    | UnliftedFFITypes | UnliftedNewtypes | Unsafe | ViewPatterns
    | Haskell98 | Haskell2010
    ){{break}}

  prelude_classes: |-
    (?x:
    # 9 Standard Prelude
      Applicative | Bifoldable | Bifunctor | Bitraversable | Bits | Bounded
    | Coercible | Enum | Eq | Floating | Foldable | Fractional | Functor | Integral
    | IsString | Ix | Monad | Monoid | Num | Ord | Read | Real | RealFloat
    | RealFrac | Semigroup | Show | Traversable | Typeable
    ){{break}}

  prelude_constants: |-
    (?x: Just | Left | Nothing | Right | True | False | LT | EQ | GT ){{break}}

  prelude_types: |-
    (?x:
    # 9 Standard Prelude
    # https://hackage.haskell.org/package/base-4.16.0.0
      Bool | Char | Complex | Constraint | Double | Dynamic  | Either | FilePath
    | Float | Integer | IO | IOError | IOException | IORef | Maybe | Ordering | Proxy
    | Ratio | Rational | ReadS | ShowS | STRef | String | Type | Unique | Version | Void
    # 24 Foreign
    # https://www.haskell.org/onlinereport/haskell2010/haskellch24.html#x32-26200024
    | Int | Int8 | Int16 | Int32 | Int64 | Word | Word8 | Word16 | Word32 | Word64
    | Ptr | FunPtr | StablePtr
    ){{break}}

  prelude_functions: |-
    (?x:
      abs | acos | acosh | all | and | any | appendFile | asTypeOf | asin
    | asinh | atan | atan2 | atanh | break | ceiling | compare | concat
    | concatMap | const | cos | cosh | curry | cycle | decodeFloat | div
    | divMod | drop | dropWhile | either | elem | encodeFloat | enumFrom
    | enumFromThen | enumFromThenTo | enumFromTo | error | errorWithoutStackTrace
    | even | exp | exponent | fail | filter | flip | floatDigits | floatRadix
    | floatRange | floor | fmap | foldMap | foldl | foldl1 | foldr | foldr1
    | fromEnum | fromInteger | fromIntegral | fromRational | fst | gcd | getChar
    | getContents | getLine | head | id | init | interact | ioError
    | isDenormalized | isIEEE | isInfinite | isNaN | isNegativeZero | iterate
    | last | lcm | length | lex | lines | log | logBase | lookup | map | mapM
    | mapM_ | mappend | max | maxBound | maximum | maybe | mconcat | mempty
    | min | minBound | minimum | mod | negate | not | notElem | null | odd | or
    | pi | pred | print | product | properFraction | pure | putChar
    | putStr | putStrLn | quot | quotRem | read | readFile | readIO | readList
    | readLn | readParen | reads | readsPrec | realToFrac | recip | rem | repeat
    | replicate | return | reverse | round | scaleFloat | scanl | scanl1 | scanr
    | scanr1 | seq | sequence | sequenceA | sequence_ | show | showChar
    | showList | showParen | showString | shows | showsPrec | significand
    | signum | sin | sinh | snd | span | splitAt | sqrt | subtract | succ | sum
    | tail | take | takeWhile | tan | tanh | toEnum | toInteger | toRational
    | traverse | truncate | uncurry | undefined | unlines | until | unwords
    | unzip | unzip3 | userError | words | writeFile | zip | zip3 | zipWith
    | zipWith3
    ){{break}}

  unboxed_types: |-
    (?x:
    # GHC 6.2.2 The magic hash
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/magic_hash.html
      Addr | Array | Char | Double | Float | Int | Word
    # GHC 6.17.2.1 Unlifted FFI Types
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/ffi.html
    | ArrayArray | ByteArray | SmallArray | StablePtr
    | Mutable (?: ArrayArray | ByteArray | SmallArray)
    )(#){{break}}

###############################################################################

contexts:
  prototype:
    - include: comments
    - include: preprocessor-pragmas
    - include: preprocessor-directives

  main:
    - meta_include_prototype: false
    - match: ''
      push: [haskell, shebang]

  haskell:
    - include: modules
    - include: declarations
    - include: statements
    - include: expressions

  declarations:
    - include: classes
    - include: instances
    - include: datas
    - include: foreigns
    - include: imports
    - include: newtypes
    - include: types
    - include: functions

  statements:
    - include: blocks
    - include: defaults
    - include: deriving
    - include: statement-terminators

  expressions:
    - include: literal-chars
    - include: literal-strings
    - include: literal-numbers
    - include: type-forall
    - include: operators
    - include: brackets
    - include: parens
    - include: keywords
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-builtin-functions
    - include: ident-builtin-constants
    - include: ident-types
    - include: ident-variables

###[ COMMENTS ]################################################################

  comments:
    # 2.3 Comments
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
    - include: line-comments
    - include: block-comments

  block-comments:
    - match: \{-(?!#)
      scope: punctuation.definition.comment.begin.haskell
      push: block-comment-body

  block-comment-body:
    - meta_include_prototype: false
    - meta_scope: comment.block.haskell
    - match: -\}
      scope: punctuation.definition.comment.end.haskell
      pop: 1
    - match: \{-#
      push: block-comment-nested-body
    - include: block-comments

  block-comment-nested-body:
    - meta_include_prototype: false
    - match: -\}
      pop: 1
    - include: block-comments

  line-comments:
    - match: (--+)(?:{{comment_first_char}}.*)?$\n?
      scope: comment.line.double-dash.haskell
      captures:
        1: punctuation.definition.comment.haskell

  shebang:
    - match: ^\#!
      scope: punctuation.definition.comment.haskell
      set: shebang-body
    - match: ^|(?=\S)  # Note: Ensure to highlight shebang if Haskell is embedded.
      pop: 1

  shebang-body:
    - meta_scope: comment.line.shebang.haskell
    # Note: Keep sync with first_line_match!
    - match: \b(cabal|runhaskell|stack)\b
      scope: constant.language.shebang.haskell
    - match: \n
      pop: 1

###[ PREPROCESSOR ]############################################################

  preprocessor-directives:
    # In addition to Haskell's "native" syntax,
    # GHC permits the C preprocessor to be run on a source file.
    - match: ^\s*((#)\s*\w+)
      scope: meta.preprocessor.c
      captures:
        1: keyword.directive.other.c
        2: punctuation.definition.preprocessor.c

  preprocessor-pragmas:
    # GHC 6.20 Pragmas
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/pragmas.html
    - match: \{-#
      scope: punctuation.section.preprocessor.begin.haskell
      push: preprocessor-pragma-body

  preprocessor-pragma-body:
    - meta_include_prototype: false
    - meta_scope: meta.preprocessor.pragma.directive.haskell
    - include: comments
    # known directives
    - match: LANGUAGE{{break}}
      scope: keyword.directive.language.haskell
      set: preprocessor-pragma-language-value
    - match: (?:OPTIONS|OPTIONS_GHC|OPTIONS_HADDOCK){{break}}
      scope: keyword.directive.options.haskell
      set: preprocessor-pragma-options-value
    - match: (?:COMPLETE|INLINE|INLINABLE|MINIMAL|NOINLINE){{break}}
      scope:
        meta.preprocessor.pragma.directive.haskell
        keyword.directive.builtin.haskell
      embed: preprocessor-pragma-signature-value
      pop: 1
      escape: '#-\}'
      escape_captures:
        0: meta.preprocessor.pragma.value.haskell
           punctuation.section.preprocessor.end.haskell
    - match: (SPECIALIZE)(?:\s+(?:(INLINE|NOINLINE)|(instance)))?{{break}}
      scope: meta.preprocessor.pragma.directive.haskell
      captures:
        1: keyword.directive.builtin.haskell
        2: keyword.directive.builtin.haskell
        3: keyword.declaration.instance.haskell
      embed: preprocessor-pragma-signature-value
      pop: 1
      escape: '#-\}'
      escape_captures:
        0: meta.preprocessor.pragma.value.haskell
           punctuation.section.preprocessor.end.haskell
    - match: '{{pragma_directives}}'
      scope: keyword.directive.builtin.haskell
      set: preprocessor-pragma-other-value
    # maybe incomplete directive
    # maintain meta scope to support completions
    - match: \p{Lu}+|(?=\S)
      set: preprocessor-pragma-other-value

  preprocessor-pragma-language-value:
    - meta_include_prototype: false
    - meta_content_scope: meta.preprocessor.pragma.value.language.haskell
    - include: preprocessor-pragma-common
    - match: '{{pragma_extension_constants}}'
      scope: constant.language.extension.haskell
    - match: '{{pragma_deprecated_constants}}'
      scope: constant.language.extension.haskell invalid.deprecated.haskell

  preprocessor-pragma-options-value:
    - meta_include_prototype: false
    - meta_content_scope: meta.preprocessor.pragma.value.options.haskell
    - include: preprocessor-pragma-common
    - match: (-*)[-\w]+
      scope: constant.other.pragma.haskell
      captures:
        1: punctuation.definition.constant.haskell

  preprocessor-pragma-signature-value:
    - meta_include_prototype: false
    - meta_content_scope: meta.preprocessor.pragma.value.signature.haskell
    - include: comments
    - include: sequence-separators
    - include: functions
    - include: type-expressions

  preprocessor-pragma-other-value:
    - meta_include_prototype: false
    - meta_content_scope: meta.preprocessor.pragma.value.other.haskell
    - include: preprocessor-pragma-common
    - include: literal-numbers
    - include: literal-strings

  preprocessor-pragma-common:
    - match: '#-\}'
      scope:
        meta.preprocessor.pragma.value.haskell
        punctuation.section.preprocessor.end.haskell
      pop: 1
    - include: comments
    - include: sequence-separators

###[ MODULE DECLARATIONS ]#####################################################

  modules:
    # 5.1 Module Structure
    # https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-990005.1
    - match: module{{break}}
      scope:
        meta.declaration.module.haskell
        keyword.declaration.namespace.haskell
      push:
        - module-where
        - module-export
        - module-name
    # https://wiki.haskell.org/Module_signature
    - match: signature{{break}}
      scope:
        meta.declaration.signature.haskell
        keyword.declaration.namespace.haskell
      push:
        - signature-where
        - module-export
        - module-name

  module-name:
    - include: ident-namespaces
    - include: ident-module
    - include: else-pop

  module-export:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: module-export-body
    - include: else-pop

  module-export-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: range-tuples
    - include: prefix-parens-operators
    - include: sequence-separators
    - include: ident-namespaces
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: module-export-body
    - match: module{{break}}
      scope: keyword.declaration.namespace.haskell
    # class / constructor / data / module / type
    - match: '{{con_id}}'
      scope: entity.name.export.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    # function / pattern / variable
    - match: '{{var_id}}'
      scope: entity.name.export.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    - include: else-pop

  signature-where:
    - meta_content_scope: meta.declaration.signature.haskell
    - include: module-where

  module-where:
    - meta_content_scope: meta.declaration.module.haskell
    - match: where{{break}}
      scope: keyword.control.context.haskell
      set: module-block
    - include: else-pop

  module-block:
    # The module body may be wrapped into braces, which still needs to be
    # handled as top-level block containing top-level declarations.
    - match: \{
      scope: punctuation.section.block.begin.haskell
      set: module-block-body
    - include: else-pop

  module-block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: declarations
    - include: statements
    - include: expressions

###[ IMPORT DECLARATIONS ]#####################################################

  imports:
    # 5.3 Import Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3
    # GHC 6.18.3 Safe Imports
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/safe_haskell.html#safe-imports
    - match: import{{break}}
      scope: meta.import.haskell keyword.declaration.import.haskell
      push:
        - import-filter
        - import-hiding
        - import-alias
        - import-name
        - import-modifier
        - import-modifier

  import-modifier:
    - match: (?:qualified|safe){{break}}
      scope: storage.modifier.import.haskell
      pop: 1
    - include: else-pop

  import-name:
    - include: ident-namespaces
    - include: ident-import
    - include: else-pop

  import-alias:
    - meta_content_scope: meta.import.module.haskell
    - match: as{{break}}
      scope: keyword.declaration.import.as.haskell
      set: import-alias-name
    - include: else-pop

  import-alias-name:
    - meta_scope: meta.import.alias.haskell
    - include: import-name

  import-hiding:
    - match: hiding{{break}}
      scope: storage.modifier.import.haskell
      pop: 1
    - include: else-pop

  import-filter:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: import-filter-body
    - include: else-pop

  import-filter-body:
    - meta_scope: meta.import.filter.haskell meta.sequence.tuple.haskell
    - include: import-tuple-body

  import-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: range-tuples
    - include: prefix-parens-operators
    - include: sequence-separators
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      push: import-tuple-body
    - match: \.
      scope: invalid.illegal.accessor.haskell
    - match: module{{break}}
      scope: invalid.illegal.unexpected-keyword.haskell
    - match: newtype{{break}}
      scope: keyword.declaration.newtype.haskell
    - match: type{{break}}
      scope: keyword.declaration.type.haskell
    # class / constructor / data / module / type
    - match: '{{con_id}}'
      scope: entity.name.import.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    # function / pattern / variable
    - match: '{{var_id}}'
      scope: entity.name.import.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    - include: else-pop

###[ FOREIGN DECLARATIONS ]####################################################

  foreigns:
    # 8.4 Foreign Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1490008
    # GHC 6.17 Foreign function interface (FFI)
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/ffi.html
    - match: foreign{{break}}
      scope: storage.modifier.foreign.haskell
      branch_point: foreign
      branch:
        - foreign-import
        - foreign-export

  foreign-import:
    # 8.4.3 Import Declarations
    - meta_scope: meta.declaration.foreign.import.haskell
    - match: export{{break}}
      fail: foreign
    - match: import{{break}}
      scope: keyword.declaration.import.haskell
    - match: (?:interruptible|unsafe|safe){{break}}
      scope: storage.modifier.import.haskell
    - include: foreign-common

  foreign-export:
    # 8.4.4 Export Declarations
    - meta_scope: meta.declaration.foreign.export.haskell
    - match: export{{break}}
      scope: keyword.declaration.export.haskell
    - match: (?:interruptible|unsafe|safe){{break}}
      scope: invalid.illegal.unexpected-keyword.haskell
    - include: foreign-common

  foreign-common:
    - include: literal-strings
    - include: prefix-parens-operators
    - match: (?:capi|ccall|cplusplus|dotnet|jvm|stdcall){{break}}
      scope: constant.language.convention.haskell
    - match: '{{var_id}}'
      scope: entity.name.function.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    - include: else-pop

###[ CLASS DECLARATIONS ]######################################################

  classes:
    # 4.3.1 Class Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: class{{break}}
      scope:
        meta.declaration.class.haskell
        keyword.declaration.class.haskell
      branch_point: class-declaration
      branch:
        - class-signature
        - class-context

  class-context:
    - meta_content_scope: meta.declaration.class.context.haskell
    - match: '{{operator_big_arrow}}'
      scope:
        meta.declaration.class.haskell
        punctuation.separator.type.context.haskell
      set:
        - class-maybe-args
        - class-name
    - include: expressions

  class-signature:
    - meta_include_prototype: false
    - match: ''
      set:
        - class-expect-args
        - class-name

  class-name:
    - include: ident-namespaces
    - match: '{{con_id}}'
      scope: entity.name.class.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      pop: 1
    - include: else-pop

  class-expect-args:
    - meta_content_scope: meta.declaration.class.haskell
    - match: (?={{operator_big_arrow}})
      fail: class-declaration
    - include: class-type

  class-maybe-args:
    - meta_content_scope: meta.declaration.class.haskell
    - include: class-type

  class-type:
    - match: where{{break}}
      scope: keyword.control.context.haskell
      set: class-block
    - include: declaration-type

  class-block:
    - match: \{
      scope: punctuation.section.block.begin.haskell
      set: class-block-body
    - include: else-pop

  class-block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: functions
    - include: statements
    - include: expressions

###[ INSTANCE DECLARATIONS ]###################################################

  instances:
    # 4.3.2 Instance Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: instance{{break}}
      scope:
        meta.declaration.instance.haskell
        keyword.declaration.instance.haskell
      branch_point: instance-declaration
      branch:
        - instance-signature
        - instance-context

  instance-context:
    - meta_content_scope: meta.declaration.instance.context.haskell
    - match: '{{operator_big_arrow}}'
      scope:
        meta.declaration.instance.haskell
        punctuation.separator.type.context.haskell
      set: instance-maybe-type
    - include: expressions

  instance-signature:
    - meta_content_scope: meta.declaration.instance.haskell
    - match: (?={{operator_big_arrow}})
      fail: instance-declaration
    - include: class-type

  instance-maybe-type:
    - meta_content_scope: meta.declaration.instance.haskell
    - include: class-type

###[ DATA DECLARATIONS ]#######################################################

  datas:
    # 4.2.1 Algebraic Datatype Declarations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-680004.2
    - match: (data)(?:\s+(family|instance))?{{break}}
      scope: meta.declaration.data.haskell
      captures:
        1: keyword.declaration.data.haskell
        2: storage.modifier.family.haskell
      branch_point: data-declaration
      branch:
        - data-signature
        - data-context

  data-context:
    # A data declaration with optional `context` expression being present.
    - meta_content_scope: meta.declaration.data.context.haskell
    - match: '{{operator_big_arrow}}'
      scope: punctuation.separator.type.context.haskell
      set:
        - data-maybe-constructors
        - type-name
    - include: expressions

  data-signature:
    # A data declaration without optional `context` expression being present.
    # That's the more common use case and thus matched first.
    - meta_include_prototype: false
    - match: ''
      set:
        - data-expect-constructors
        - type-name

  data-expect-constructors:
    - meta_scope: meta.declaration.data.haskell
    - match: (?={{operator_big_arrow}})
      fail: data-declaration
    - include: data-maybe-constructors

  data-maybe-constructors:
    - meta_scope: meta.declaration.data.haskell
    - match: =
      scope: keyword.operator.haskell
      set:
        - constructors
        - constructor-or-type
    - include: declaration-type

###[ CONSTRUCTOR DECLARATIONS ]################################################

  constructors:
    - meta_content_scope: meta.declaration.data.haskell
    - match: \|
      scope: punctuation.separator.sequence.haskell
      push: constructor-or-type
    - include: declaration-type

  constructor-or-type:
    - match: (?={{con_id}})
      pop: 1
      branch_point: constructor-or-type
      branch:
        - constructor
        - ident-type
    - include: else-pop

  constructor:
    # Data constructors without arguments are also called constants.
    # Thus all data constructors are scoped as constant.
    - match: '{{con_id}}'
      scope: entity.name.constant.haskell
      set: constructor-parameters

  constructor-parameters:
    - match: \{
      scope: punctuation.section.block.begin.haskell
      set: record-body
    - match: (?=\S)
      set: constructor-body

  constructor-body:
    - include: declaration-end
    - include: type-lists
    - include: type-parens
    - include: ident-namespaces
    - include: ident-types
    - include: ident-variables
    - match: \!
      scope: keyword.operator.haskell
    # terminated by
    # - statement terminator
    # - constructor separator
    # - record block
    # - any (key)word
    - match: (?=[|{\w])
      pop: 1
    - match: (?=\S)
      fail: constructor-or-type

###[ DEFAULT DECLARATIONS ]####################################################

  defaults:
    # 4.3.4 Ambiguous Types, and Defaults for Overloaded Numeric Operations
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: default{{break}}
      scope: storage.modifier.haskell
      push:
        - default-meta
        - default-body

  default-meta:
    - meta_include_prototype: false
    - meta_scope: meta.declaration.default.haskell
    - include: immediately-pop

  default-body:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: type-tuple-body
    - include: else-pop

###[ DERIVING DECLARATIONS ]###################################################

  deriving:
    # 4.3.3 Derived Instances
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
    - match: (?:deriving|via){{break}}
      scope: storage.modifier.haskell
      push:
        - deriving-meta
        - deriving-begin

  deriving-meta:
    - meta_include_prototype: false
    - meta_scope: meta.declaration.deriving.haskell
    - include: immediately-pop

  deriving-begin:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: deriving-tuple-body
    - match: (?=\S)
      set: deriving-body

  deriving-body:
    - include: ident-namespaces
    - include: ident-type
    - include: else-pop

  deriving-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: sequence-separators
    - include: ident-namespaces
    - include: ident-types
    - include: else-pop

###[ FUNCTION DECLARATIONS ]###################################################

  functions:
    - match: (?={{var_id}}|\(\s*{{operator_parens}}\s*\))
      branch_point: functions
      branch:
        - variable-name
        - function-name

  function-name:
    - meta_content_scope: meta.function.identifier.haskell
    - match: '{{operator_double_colon}}'
      scope: punctuation.separator.type.haskell
      pop: 1
    - match: '{{var_id}}'
      scope: entity.name.function.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    - include: prefix-parens-operators
    - include: sequence-separators

  variable-name:
    - match: (\()\s*({{operator_parens}})\s*(\))
      scope: meta.prefix.haskell
      captures:
        1: punctuation.definition.prefix.begin.haskell
        2: keyword.operator.haskell
        3: punctuation.definition.prefix.end.haskell
      push: variable-name-end
    - match: '{{prelude_functions}}'
      scope: support.function.prelude.haskell
      push: variable-name-end
    - match: _\b
      scope: variable.language.anonymous.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      push: variable-name-end
    - match: '{{var_id}}'
      scope: variable.other.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      push: variable-name-end
    - include: sequence-separators
    - include: else-pop

  variable-name-end:
    - match: (?={{operator_double_colon}})
      fail: functions
    - match: (?=,)
      pop: 1
    - match: (?=\S)
      pop: 2

###[ NEWTYPE DECLARATIONS ]####################################################

  newtypes:
    - match: newtype{{break}}
      scope:
        meta.declaration.newtype.haskell
        keyword.declaration.newtype.haskell
      branch_point: newtype-declaration
      branch:
        - newtype-signature
        - newtype-context

  newtype-context:
    - meta_content_scope: meta.declaration.newtype.context.haskell
    - match: '{{operator_big_arrow}}'
      scope: punctuation.separator.type.context.haskell
      set:
        - newtype-maybe-args
        - type-name
    - include: expressions

  newtype-signature:
    - meta_include_prototype: false
    - match: ''
      set:
        - newtype-expect-args
        - type-name

  newtype-expect-args:
    - meta_scope: meta.declaration.newtype.haskell
    - match: (?={{operator_big_arrow}})
      fail: newtype-declaration
    - include: declaration-type

  newtype-maybe-args:
    - meta_scope: meta.declaration.newtype.haskell
    - include: declaration-type

###[ TYPE DECLARATIONS ]#######################################################

  types:
    # https://wiki.haskell.org/GHC/Type_families
    - match: (type)(?:\s+(family))?{{break}}
      scope: meta.declaration.type.haskell
      captures:
        1: keyword.declaration.type.haskell
        2: storage.modifier.family.haskell
      branch_point: type-declaration
      branch:
        - type-signature
        - type-context

  type-context:
    - meta_content_scope: meta.declaration.type.context.haskell
    - match: '{{operator_big_arrow}}'
      scope: punctuation.separator.type.context.haskell
      set:
        - type-maybe-args
        - type-name
    - include: expressions

  type-signature:
    - meta_include_prototype: false
    - match: ''
      set:
        - type-expect-args
        - type-name

  type-name:
    - include: ident-namespaces
    - match: '{{con_id}}'
      scope: entity.name.type.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      pop: 1
    - include: else-pop

  type-expect-args:
    - meta_scope: meta.declaration.type.haskell
    - match: (?={{operator_big_arrow}})
      fail: type-declaration
    - include: declaration-type

  type-maybe-args:
    - meta_scope: meta.declaration.type.haskell
    - include: declaration-type

###[ DECLARATION TYPE EXPRESSIONS ]############################################

  declaration-type:
    - include: declaration-end
    - include: right-arrow-operators
    - include: infix-quoted-operators
    - include: infix-operators
    - include: type-lists
    - include: type-parens
    - include: type-forall
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-types
    - include: ident-variables
    - match: \S
      scope: invalid.illegal.haskell

  declaration-end:
    - match: (?=;|=(?!{{symbol}})|{{operator_double_colon}}|{{operator_left_arrow}}|{{reserved_id}})
      pop: 1
    # pop context if beginning of a line looks like a function declaration or assignment expression
    - match: ^(?=\s*{{var_id}})
      branch_point: declaration-type-end
      branch:
        - declaration-type-variable
        - immediately-pop2

  declaration-type-variable:
    - match: '{{var_id}}'
      scope: variable.other.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      set: declaration-type-variable-after

  declaration-type-variable-after:
    - match: (?=,|=(?!{{symbol}})|{{operator_double_colon}}|{{operator_left_arrow}})
      fail: declaration-type-end
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-types
    - include: ident-variables
    - include: else-pop

###[ TYPE EXPRESSIONS ]########################################################

  type-expressions:
    - include: big-arrow-operators
    - include: right-arrow-operators
    - include: type-lists
    - include: type-parens
    - include: type-forall
    - include: ident-anonymous
    - include: ident-namespaces
    - include: ident-types
    - include: ident-variables

  type-forall:
    - match: forall{{break}}|∀(?!{{symbol}})
      scope: keyword.control.forall.haskell
      push: type-forall-body

  type-forall-body:
    # Note: This is the only situation a dot is allowed within type expressions.
    - match: \.
      scope: punctuation.separator.sequence.haskell
      pop: 1
    - include: ident-anonymous
    - include: ident-variables
    - include: else-pop

  type-lists:
    - include: empty-lists
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      push: type-list-body

  type-list-body:
    - meta_scope: meta.sequence.list.haskell
    - include: list-end
    - include: sequence-separators
    - include: type-expressions
    - include: else-pop

  type-parens:
    # 4.1.3 Syntax of Class Assertions and Contexts
    # https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-630004.1
    - include: empty-tuples
    - include: prefix-parens-operators
    - match: (?=\()
      branch_point: type-parens
      branch:
        - type-group
        - type-tuple

  type-group:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      set: type-group-body

  type-group-body:
    - meta_scope: meta.group.haskell
    - match: ',|:(?!{{symbol}})'
      fail: type-parens
    - include: group-end
    - include: type-expressions
    - include: else-pop

  type-tuple:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: type-tuple-body

  type-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: sequence-separators
    - include: type-expressions
    - include: else-pop

###[ BRACES ]##################################################################

  blocks:
    # 2.7 Layout
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: \{
      scope: punctuation.section.block.begin.haskell
      push: block-body

  block-end:
    - match: \}
      scope: punctuation.section.block.end.haskell
      pop: 1

  block-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: statements
    - include: expressions
    - include: else-pop

  records:
    - match: \{
      scope: punctuation.section.block.begin.haskell
      push: record-body

  record-body:
    - meta_scope: meta.block.haskell
    - include: block-end
    - include: expressions
    - include: else-pop

###[ BRACKETS ]################################################################

  brackets:
    - include: typed-quotes
    - include: overloaded-quotes
    - include: empty-lists
    - match: (?=\[)
      branch_point: list-or-quasiquote
      branch:
        - list
        - quasi-quote

  empty-lists:
    - match: (\[)(\])
      captures:
        0: meta.sequence.list.empty.haskell
        1: punctuation.section.sequence.begin.haskell
        2: punctuation.section.sequence.end.haskell

  list:
    # 3.7 Lists
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-340003.7
    - match: \[
      scope: punctuation.section.sequence.begin.haskell
      set: list-body

  list-body:
    - meta_scope: meta.sequence.list.haskell
    - include: list-fail
    - include: list-end
    - include: list-keywords
    - include: records
    - include: expressions
    - include: else-pop

  list-end:
    - match: \]
      scope: punctuation.section.sequence.end.haskell
      pop: 1

  list-fail:
    - match: \|\]
      fail: list-or-quasiquote

  list-keywords:
    # 6.2.7. Generalised (SQL-like) List Comprehensions
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/generalised_list_comprehensions.html
    - match: (?:group|by|using){{break}}
      scope: keyword.control.list.haskell

  quasi-quote:
    # https://wiki.haskell.org/Quasiquotation
    - match: \[
      scope: meta.quoted.quasi.haskell punctuation.section.quoted.begin.haskell
      set: quasi-quote-name

  quasi-quote-name:
    - meta_content_scope: meta.quoted.quasi.haskell
    - match: \|
      scope: meta.quoted.quasi.haskell punctuation.section.quoted.haskell
      set: quasi-quote-body
    - match: '[\w'']+'
      scope: variable.function.quasi-quoter.haskell
    - include: quasi-quote-end

  quasi-quote-body:
    - meta_content_scope: meta.quoted.quasi.haskell meta.string.haskell string.unquoted.haskell
    - include: quasi-quote-end

  quasi-quote-end:
    - match: \|\]
      scope: meta.quoted.quasi.haskell punctuation.section.quoted.end.haskell
      pop: 1

  overloaded-quotes:
    # https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0246-overloaded-bracket.rst
    - match: \[\|
      scope: punctuation.section.quoted.begin.haskell
      push: overloaded-quote-body

  overloaded-quote-body:
    - meta_scope: meta.quoted.overloaded.haskell
    - match: \|\]
      scope: punctuation.section.quoted.end.haskell
      pop: 1
    - include: expressions

  typed-quotes:
    # https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0246-overloaded-bracket.rst
    - match: \[\|\|(?!\])
      scope: punctuation.section.quoted.begin.haskell
      push: typed-quote-body

  typed-quote-body:
    - meta_scope: meta.quoted.typed.haskell
    - match: \|\|\]
      scope: punctuation.section.quoted.end.haskell
      pop: 1
    - include: expressions

###[ PARENTHESES ]#############################################################

  parens:
    # 3.8 Tuples
    # https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-360003.8
    - include: empty-tuples
    - include: unboxed-tuples
    - include: prefix-parens-operators
    - match: (?=\()
      branch_point: parens
      branch:
        - group
        - tuple

  group:
    - match: \(
      scope: punctuation.section.group.begin.haskell
      set: group-body

  group-end:
    - match: \)
      scope: punctuation.section.group.end.haskell
      pop: 1

  group-body:
    - meta_scope: meta.group.haskell
    - match: ',|:(?!{{symbol}})'
      fail: parens
    - include: group-end
    - include: records
    - include: expressions
    - include: else-pop

  tuple:
    - match: \(
      scope: punctuation.section.sequence.begin.haskell
      set: tuple-body

  tuple-end:
    - match: \)
      scope: punctuation.section.sequence.end.haskell
      pop: 1

  tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - include: tuple-end
    - include: records
    - include: expressions
    - include: else-pop

  empty-tuples:
    # 6.1.5 Unit Data Type
    # https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1200006.1.5
    - match: (\()(\))
      scope: meta.sequence.tuple.empty.haskell
      captures:
        1: punctuation.section.sequence.begin.haskell
        2: punctuation.section.sequence.end.haskell

  range-tuples:
    - match: (\()\s*(\.\.)\s*(\))
      scope: meta.sequence.tuple.haskell
      captures:
        1: punctuation.section.sequence.begin.haskell
        2: keyword.operator.haskell
        3: punctuation.section.sequence.end.haskell

  unboxed-tuples:
    # GHC 6.16.3 Unboxed tuples
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/primitives.html#unboxed-tuples
    - match: (\()(#)
      captures:
        1: punctuation.section.sequence.begin.haskell
        2: storage.modifier.unboxed.haskell
      push: unboxed-tuple-body

  unboxed-tuple-body:
    - meta_scope: meta.sequence.tuple.haskell
    - match: (#)(\))
      captures:
        1: storage.modifier.unboxed.haskell
        2: punctuation.section.sequence.end.haskell
      pop: 1
    - include: records
    - include: expressions
    - include: else-pop

###[ IDENTIFIERS ]#############################################################

  ident-anonymous:
    - match: _\b
      scope: variable.language.anonymous.haskell
      captures:
        1: storage.modifier.unboxed.haskell

  ident-builtin-constants:
    # Data constructors without arguments are also called constants.
    # Thus all data constructors are scoped as constant.
    - match: '{{prelude_constants}}'
      scope: support.constant.prelude.haskell

  ident-builtin-functions:
    - match: '{{prelude_functions}}'
      scope: support.function.prelude.haskell

  ident-namespaces:
    - match: ({{con_id}})(\.)
      captures:
        1: variable.namespace.haskell
        2: storage.modifier.haskell
        3: punctuation.accessor.dot.haskell

  ident-module:
    - match: '{{con_id}}'
      scope: entity.name.namespace.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      pop: 1

  ident-import:
    - match: '{{con_id}}'
      scope: variable.namespace.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      pop: 1

  ident-types:
    - include: ident-builtin-types
    - include: ident-user-types

  ident-builtin-types:
    # Prelude Class Types
    - match: '{{prelude_classes}}'
      scope: support.class.prelude.haskell
    # Prelude Data Types
    - match: '{{prelude_types}}'
      scope: support.type.prelude.haskell
    # Unboxed Data Types
    - match: '{{unboxed_types}}'
      scope: support.type.unboxed.haskell
      captures:
        1: storage.modifier.unboxed.haskell

  ident-user-types:
    - match: '{{con_id}}'
      scope: storage.type.haskell
      captures:
        1: storage.modifier.unboxed.haskell

  ident-type:
    - include: ident-builtin-type
    - include: ident-user-type

  ident-builtin-type:
    # Prelude Class Types
    - match: '{{prelude_classes}}'
      scope: support.class.prelude.haskell
      pop: 1
    # Prelude Data Types
    - match: '{{prelude_types}}'
      scope: support.type.prelude.haskell
      pop: 1
    # Unboxed Data Types
    - match: '{{unboxed_types}}'
      scope: support.type.unboxed.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      pop: 1

  ident-user-type:
    - match: '{{con_id}}'
      scope: storage.type.haskell
      captures:
        1: storage.modifier.unboxed.haskell
      pop: 1

  ident-variables:
    - match: '{{var_id}}'
      scope: variable.other.haskell
      captures:
        1: storage.modifier.unboxed.haskell

###[ LITERALS ]################################################################

  literal-numbers:
    # 2.5 Decimal floating point literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5
    - match: (\d{{dec_digit}}*(?:(\.){{dec_digit}}+{{dec_exponent}}?|{{dec_exponent}}))(#*)
      scope: meta.number.float.decimal.haskell
      captures:
        1: constant.numeric.value.haskell
        2: punctuation.separator.decimal.haskell
        3: constant.numeric.suffix.haskell
    # GHC 6.9.3 Hexadecimal floating point literals
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/hex_float_literals.html
    - match: (0[xX])({{hex_digit}}+(\.){{hex_digit}}+{{hex_exponent}}?)(#*)
      scope: meta.number.float.hexadecimal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
        3: punctuation.separator.decimal.haskell
        4: constant.numeric.suffix.haskell
    # GHC 6.9.2 Binary integer literals
    # https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/binary_literals.html
    - match: (0[bB])({{bin_digit}}+)(#*)
      scope: meta.number.integer.binary.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
        3: constant.numeric.suffix.haskell
    # 2.5 Numeric Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-190002.5
    - match: (0[oO])({{oct_digit}}+)(#*)
      scope: meta.number.integer.octal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
        3: constant.numeric.suffix.haskell
    - match: (0[xX])({{hex_digit}}+)(#*)
      scope: meta.number.integer.hexadecimal.haskell
      captures:
        1: constant.numeric.base.haskell
        2: constant.numeric.value.haskell
        3: constant.numeric.suffix.haskell
    - match: (\d{{dec_digit}}*)(#*)
      scope: meta.number.integer.decimal.haskell
      captures:
        1: constant.numeric.value.haskell
        2: constant.numeric.suffix.haskell

  literal-chars:
    # 2.6 Character and String Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
    - match: (')(?:([ [\S&&[^\\'']]])|{{escape_sequence}})?(?:(')(#*)|{{comment_ahead}})
      scope: meta.string.haskell string.quoted.single.haskell
      captures:
        1: punctuation.definition.string.begin.haskell
        2: constant.character.literal.haskell
        3: constant.character.escape.haskell
        4: constant.character.escape.decimal.haskell
        5: constant.character.escape.octal.haskell
        6: constant.character.escape.hexadecimal.haskell
        7: constant.character.escape.control.haskell
        8: punctuation.definition.string.end.haskell
        9: storage.modifier.unboxed.haskell

  literal-strings:
    # 2.6 Character and String Literals
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
    - match: \"
      scope: punctuation.definition.string.begin.haskell
      push: literal-string-body

  literal-string-body:
    - meta_include_prototype: false
    - meta_scope: meta.string.haskell string.quoted.double.haskell
    - match: (\")(#*)|$
      captures:
        1: punctuation.definition.string.end.haskell
        2: storage.modifier.unboxed.haskell
      pop: 1
    - match: '{{escape_sequence}}'
      captures:
        1: constant.character.escape.haskell
        2: constant.character.escape.decimal.haskell
        3: constant.character.escape.octal.haskell
        4: constant.character.escape.hexadecimal.haskell
        5: constant.character.escape.control.haskell
    - match: (\\)\s*$
      captures:
        1: punctuation.definition.continuation.begin.haskell
      push: linteral-string-continuation

  linteral-string-continuation:
    - clear_scopes: 2
    - meta_scope: meta.string.continuation.haskell
    - meta_include_prototype: false
    - match: \\
      scope: punctuation.definition.continuation.end.haskell
      pop: 1
    - match: \"
      scope: invalid.illegal.expect-continuation-end.haskell
      pop: 2
    - match: \S
      scope: invalid.illegal.expect-continuation-end.haskell
      pop: 1

###[ KEYWORDS AND OPERATORS ]##################################################

  keywords:
    - match: (?:mdo|do|in|rec|where){{break}}
      scope: keyword.control.context.haskell
    - match: (?:case|of){{break}}
      scope: keyword.control.conditional.select.haskell  # the construct is commonly called "select"
    - match: if{{break}}
      scope: keyword.control.conditional.if.haskell
    - match: then{{break}}
      scope: keyword.control.conditional.then.haskell
    - match: else{{break}}
      scope: keyword.control.conditional.else.haskell
    - match: let{{break}}
      scope: keyword.declaration.variable.haskell
    - match: proc{{break}}
      scope: keyword.declaration.function.haskell
    # 4.4.2 Fixity Declarations
    - match: infix[lr]?{{break}}
      scope: keyword.declaration.fixity.haskell

  operators:
    - include: sequence-separators
    - include: big-arrow-operators
    - include: left-arrow-operators
    - include: right-arrow-operators
    - include: prefix-parens-operators
    - include: infix-quoted-operators
    - include: infix-operators

  big-arrow-operators:
    - match: '{{operator_big_arrow}}'
      scope: punctuation.separator.type.context.haskell

  left-arrow-operators:
    - match: '{{operator_left_arrow}}'
      scope: keyword.operator.arrow.haskell

  right-arrow-operators:
    - match: '{{operator_right_arrow}}'
      scope: keyword.operator.arrow.haskell

  prefix-parens-operators:
    - match: (\()\s*({{operator_parens}})\s*(\))
      scope: meta.prefix.haskell
      captures:
        1: punctuation.definition.prefix.begin.haskell
        2: keyword.operator.haskell
        3: punctuation.definition.prefix.end.haskell

  infix-operators:
    # Match all not otherwise matched single quotes as promoition operator
    # Note: Found in real world code but not in specs so far.
    - match: \'
      scope: keyword.operator.haskell
    - match: '{{operator_double_colon}}'
      scope: punctuation.separator.type.haskell
    - match: '{{operator_symbol}}'
      scope: keyword.operator.haskell

  infix-quoted-operators:
    - match: (?=\`)
      branch_point: infix-quoted-operators
      branch:
        - infix-quoded-operators-begin
        - immediately-pop

  infix-quoded-operators-begin:
    - match: (\`)\s*
      captures:
        1: punctuation.definition.infix.begin.haskell
      set: infix-quoded-operators-body

  infix-quoded-operators-body:
    - meta_scope: meta.infix.haskell
    - match: \s*(\`)
      captures:
        1: punctuation.definition.infix.end.haskell
      pop: 1
    - include: ident-namespaces
    - match: '{{id}}'
      scope: keyword.operator.function.infix.haskell
      captures:
        1: storage.modifier.unboxed.haskell
    - match: ''
      fail: infix-quoted-operators

  statement-terminators:
    # Depending on layout, semicolon may be needed to terminate statements.
    # https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
    - match: ';'
      scope: punctuation.terminator.statement.haskell

  sequence-separators:
    - match: ',|\|(?!\|)'
      scope: punctuation.separator.sequence.haskell

###[ PROTOTYPES ]##############################################################

  else-pop:
    - match: (?=\S)
      pop: 1

  immediately-pop:
    - match: ''
      pop: 1

  immediately-pop2:
    - match: ''
      pop: 2

