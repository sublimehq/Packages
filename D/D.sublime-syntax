%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: D
comment: D language
file_extensions:
  - d
  - di
first_line_match: ^#!.*\bg?dmd\b.
scope: source.d
variables:
  name: '[[:alpha:]_][[:alpha:]0-9_]*'
  name_lookahead: '(?=\b{{name}}\b)'
  identifier_ref: '\.?\s*{{name}}(\s*\.\s*{{name}})*'
  string_postfix: '[cwd]?'
  escape_sequence: '\\([''"?\\0abfnrtv]|x\h{2}|[0-7]{1,3}|u\h{4}|U\h{8}|&\w+;)'

  # number lookaheads
  number_lookahead: '(?=(\b|\.)\d)'
  integer_lookahead: '(?=\b\d)'

  # number digits
  bin_digits: '(?:[01][01_]*)'
  hex_digits: '(?:\h[\h_]*)'
  dec_digits: '(?:\d[\d_]*)'
  dec_integer: '(?:0_*|[1-9][0-9_]*)'

  # number suffixes
  imaginary_suffix: '[fFL]?i'
  integer_suffix: 'L[uU]|[uU]L|[LuU]'
  integer_float_suffix: '[fFL]'
  float_suffix: '[fF]'

  # number exponents
  exponent: '[-+]??\d+'
  dec_exponent: '(?:[eE]{{exponent}})'
  hex_exponent: '(?:[pP]{{exponent}})'

  character_lookahead: (?=')
  string_lookahead: '(?=`|[rxq]?"|q{)'

  definitely_value_lookahead: '(?=!|~|\+|\-|\*|&|\bcast\b|\bdelete\b|\bnew\b|\bimport\b|\bmixin\b|\bis\b|\b__traits\b|\bfunction\b|\bdelegate\b|[0-9]|\[|\(|{{string_lookahead}}|\b({{language_constant}})\b|\b({{language_variable}})\b)'
  definitely_declaration_lookahead: '(?=({{name}}|\]|\))(\s+{{name}})|\b({{type_qualifier}})\b)'

  type_qualifier: 'const|immutable|inout|shared'
  type_qualifier_lookahead: '(?=\b({{type_qualifier}})\b)'
  attribute_lookahead: '(?=@|\b({{attributes}}|extern|align|deprecated|pragma|private|protected|public|export|package)\b)'
  attributes: 'static|abstract|final|override|synchronized|scope|__gshared|nothrow|pure|ref|return|auto'
  at_attributes: 'disable|nogc|property|safe|system|trusted'
  function_attribute_lookahead: '{{attribute_lookahead}}|{{type_qualifier_lookahead}}'
  parameter_attribute_lookahead: '(?=\b({{parameter_attribute}})\b)'
  parameter_attribute: 'in|lazy|out|alias'

  construction_lookahead: '(?=~?\s*this\s*\()'

  keyword: 'else|enum|export|extern|debug|default|delegate|delete|deprecated|do|body|break|case|cast|catch|class|const|continue|abstract|alias|align|asm|assert|auto|final|finally|for|foreach|foreach_reverse|function|goto|if|immutable|import|in|inout|interface|invariant|is|lazy|macro|mixin|module|new|nothrow|out|override|package|pragma|private|protected|public|pure|ref|return|scope|shared|static|struct|switch|synchronized|template|throw|try|typeid|typeof|union|unittest|version|while|with|__gshared|__traits|__vector|__parameters'
  basic_type: 'bool|byte|cdouble|cent|cfloat|char|creal|dchar|double|float|idouble|ifloat|int|ireal|long|real|short|ubyte|ucent|uint|ulong|ushort|void|wchar|string|dstring|wstring'
  language_constant: 'null|true|false|__FILE__|__FILE_FULL_PATH__|__MODULE__|__LINE__|__FUNCTION__|__PRETTY_FUNCTION__|__DATE__|__EOF__|__TIME__|__TIMESTAMP__|__VENDOR__|__VERSION__|__ctfe'
  language_variable: 'this|super'
  reserved: '{{keyword}}|{{basic_type}}|{{language_constant}}|{{language_variable}}'

  operator_overloads: 'opNeg|opCom|opPostInc|opPostDec|opCast|opAdd|opSub|opSub_r|opMul|opDiv|opDiv_r|opMod|opMod_r|opAnd|opOr|opXor|opShl|opShl_r|opShr|opShr_r|opUShr|opUShr_r|opCat|opCat_r|opEquals|opEquals|opCmp|opCmp|opCmp|opCmp|opAddAssign|opSubAssign|opMulAssign|opDivAssign|opModAssign|opAndAssign|opOrAssign|opXorAssign|opShlAssign|opShrAssign|opUShrAssign|opCatAssign|opIndex|opIndexAssign|opCall|opSlice|opSliceAssign|opPos|opAdd_r|opMul_r|opAnd_r|opOr_r|opXor_r'

  block_statement_loohahead: '(?={)'

contexts:
  prototype:
    - include: comment-in

  main:
    - match: '^#!'
      scope: punctuation.definition.comment.number-sign.d
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.number-sign.d
        - match: '$\n?'
          pop: true
    - include: module-in
    - include: statement-list-in
  module-in:
    - match: \bmodule\b
      scope: keyword.declaration.namespace.d
      push:
        - meta_scope: meta.namespace.d
        - match: '{{name}}(?=\s*(;|$))'
          scope: meta.path.d entity.name.namespace.d
        - match: '{{name}}'
          scope: meta.path.d variable.other.d
          push:
            - match: \.
              scope: meta.path.d punctuation.accessor.dot.d
              pop: true
            - include: not-whitespace-illegal-pop
        - include: expect-end-of-line

  statement-list-in:
    - include: import-in
    - include: alias-in
    - include: class-in
    - include: interface-in
    - include: struct-in
    - include: union-in
    - include: enum-in
    - include: conditional-declaration-in
    - include: static-foreach-in
    - include: static-assert-in
    - include: constructions-in
    - include: invariant-in
    - include: unittest-in
    - include: template-in
    - include: mixin-in
    - include: block-statement-in
    - include: conditional-in
    - include: loop-in
    - include: flow-statement-in
    - include: with-in
    - include: synchronized-in
    - include: try-in
    - include: throw-in
    - include: scope-in
    - include: asm-in
    - include: switch-in
    - include: attribute-specifier-in
    - include: statement-label-in
    - include: end-of-line-in
    - include: check-brackets-in
    - include: value-or-declaration-in

  block-statement-in:
    - match: '{{block_statement_loohahead}}'
      push: block-statement
  block-statement:
    - match: '{'
      scope: punctuation.section.block.begin.d
      set:
        - meta_scope: meta.block.d
        - match: '}'
          scope: punctuation.section.block.end.d
          pop: true
        - include: statement-list-in
    - include: not-whitespace-illegal-pop
  optional-block-statement:
    - match: '{{block_statement_loohahead}}'
      set: block-statement
    - match: '(?=\S)'
      pop: true

  optional-block-statement-or-label:
    - match: ':'
      scope: punctuation.separator.d
      pop: true
    - include: optional-block-statement

  comment-in:
    - match: /\*(\*(?!/))?
      scope: punctuation.definition.comment.d
      push:
        - meta_scope: comment.block.d
        - match: \*/
          scope: punctuation.definition.comment.d
          pop: true
        - match: ^\s*(\*)(?!/)
          captures:
            1: punctuation.definition.comment.d
    - match: (///?).*$\n?
      scope: comment.line.double-slash.d
      captures:
        1: punctuation.definition.comment.d
    - include: nested-comment
  nested-comment:
    - match: /\+(\+(?!/))?
      scope: punctuation.definition.comment.d
      push:
        - meta_scope: comment.block.nested.d
        - match: \+/
          scope: punctuation.definition.comment.d
          pop: true
        - match: ^\s*(\+)(?!/)
          captures:
            1: punctuation.definition.comment.d
        - include: nested-comment

  number-in:
    - match: '{{number_lookahead}}'
      push: number
  number-opt:
    - include: floating-point-opt
    - include: integer-opt
  number:
    - include: number-opt
    - include: not-whitespace-illegal-pop

  integer:
    - include: integer-opt
    - include: not-whitespace-illegal-pop
  integer-opt:
    - match: '(0[bB])(_?){{bin_digits}}({{integer_suffix}})?'
      scope: constant.numeric.integer.binary.d
      captures:
        1: punctuation.definition.numeric.base.d
        2: invalid.illegal.numeric.d
        3: storage.type.numeric.d
      pop: true
    - match: '(0[xX])(_?){{hex_digits}}({{integer_suffix}})?'
      scope: constant.numeric.integer.hexadecimal.d
      captures:
        1: punctuation.definition.numeric.base.d
        2: invalid.illegal.numeric.d
        3: storage.type.numeric.d
      pop: true
    - match: '{{dec_integer}}({{integer_suffix}})?'
      scope: constant.numeric.integer.decimal.d
      captures:
        1: storage.type.numeric.d
      pop: true

  floating-point:
    - include: floating-point-opt
    - include: not-whitespace-illegal-pop
  floating-point-opt:
    # decimal imaginary numbers
    - match: '{{dec_integer}}?(?:(\.){{dec_digits}}?)?{{dec_exponent}}?({{imaginary_suffix}})'
      scope: constant.numeric.imaginary.decimal.d
      captures:
        1: punctuation.separator.decimal.d
        2: storage.type.numeric.d
      pop: true
    # decimal floats
    - match: |-
        (?x:
          {{dec_integer}}
          (?:
            (?:
              (\.)
              (?:
                # 1.1, 1.1e1, 1.1e-1, 1.1f, 1.1e1f, 1.1e-1f, 1.1L, 1.1e1L, 1.1e-1L
                {{dec_digits}} {{dec_exponent}}?
                # 1.e1, 1.e-1, 1.e1f, 1.e-1f, 1.e1L, 1.e-1L
                | {{dec_exponent}}
                # 1., 1.f, 1.L # but not `..` or method/attribute access
                | (?!\.|\s*[[:alpha:]_]) )
              # 1e1 1e1f 1e1L
              | {{dec_exponent}}
            ) ({{integer_float_suffix}})?
            # 1f
            | ({{float_suffix}})
          )
          # .1, .1e1, .1e-1, .1f, .1e1f, .1e-1f, .1L, .1e1L, .1e-1L
          | (\.) {{dec_digits}} {{dec_exponent}}? ({{integer_float_suffix}})?
        )
      scope: constant.numeric.float.decimal.d
      captures:
        1: punctuation.separator.decimal.d
        2: storage.type.numeric.d
        3: storage.type.numeric.d
        4: punctuation.separator.decimal.d
        5: storage.type.numeric.d
      pop: true

    # hexadecimal imaginary numbers
    - match: (0[xX])(_?){{hex_digits}}?(?:(\.){{hex_digits}}?)?{{hex_exponent}}?({{imaginary_suffix}})
      scope: constant.numeric.imaginary.hexadecimal.d
      captures:
        1: punctuation.definition.numeric.base.d
        2: invalid.illegal.numeric.d
        3: punctuation.separator.decimal.d
        4: storage.type.numeric.d
      pop: true
    # hexadecimal floats
    - match: (0[xX])(_?){{hex_digits}}?(?:(\.){{hex_digits}}?)?{{hex_exponent}}({{integer_float_suffix}})?
      scope: constant.numeric.float.hexadecimal.d
      captures:
        1: punctuation.definition.numeric.base.d
        2: invalid.illegal.numeric.d
        3: punctuation.separator.decimal.d
        4: storage.type.numeric.d
      pop: true

    # binary imaginary numbers
    - match: (0[bB])(_?){{bin_digits}}({{imaginary_suffix}})
      scope: constant.numeric.imaginary.binary.d
      captures:
        1: punctuation.definition.numeric.base.d
        2: invalid.illegal.numeric.d
        3: storage.type.numeric.d
      pop: true
    # binary floats
    - match: (0[bB])(_?){{bin_digits}}({{float_suffix}})
      scope: constant.numeric.float.binary.d
      captures:
        1: punctuation.definition.numeric.base.d
        2: invalid.illegal.numeric.d
        3: storage.type.numeric.d
      pop: true

  character-in:
    - match: '{{character_lookahead}}'
      push: character
  character:
    - match: \'(?:({{escape_sequence}})|[^\\'])\'
      scope: meta.string.d string.quoted.single.d
      captures:
        1: constant.character.escape.d
      pop: true
    - match: \'[^']*\'
      scope: invalid.illegal.d
      pop: true
    - include: not-whitespace-illegal-pop

  string-in:
    - match: '{{string_lookahead}}'
      push: string
  string:
    - include: string-opt
    - include: not-whitespace-illegal-pop
  string-opt:
    # Regular string
    - match: '"'
      scope: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.d
        - match: '(")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
        - match: '{{escape_sequence}}'
          scope: constant.character.escape.d
        - match: \\.
          scope: invalid.illegal.unknown-escape.d
    # Wysiwyg string
    - match: (r)(")
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
    # Alternate Wysiwyg string
    - match: "`"
      scope: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.backtick.d
        - match: '(`)({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
    # Deprecated Hex string
    - match: (x)(")
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
        - match: '\h\s*\h'
          scope: constant.character.escape.d
        - match: '\S'
          scope: invalid.illegal.unknown-escape.d
    # Deliminated string with custom identifier
    - match: '(q)(")({{name}})(.*)$'
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
        3: constant.other.delimeter.d
        4: invalid.illegal.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(^\3)(")({{string_postfix}})'
          captures:
            1: constant.other.delimeter.d
            2: punctuation.definition.string.end.d
            3: storage.type.string.d
          pop: true
    # Nested Deliminated string
    - match: (q)("\[)
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(\]")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
    - match: (q)("\()
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(\)")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
    - match: (q)("<)
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(>")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
    - match: (q)("{)
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(}")({{string_postfix}})'
          captures:
            1: punctuation.definition.string.end.d
            2: storage.type.string.d
          pop: true
    # Other deliminated string
    - match: '(q)(")(.)'
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
        3: constant.other.delimeter.d
      set:
        - meta_include_prototype: false
        - meta_scope: meta.string.d string.quoted.double.raw.d
        - match: '(\3)(?:(")|(.))({{string_postfix}})'
          captures:
            1: constant.other.delimeter.d
            2: punctuation.definition.string.end.d
            3: invalid.illegal.d
            4: storage.type.string.d
          pop: true
    # Token string
    - match: '(q)({)'
      captures:
        1: storage.modifier.string.d
        2: punctuation.definition.string.begin.d
      scope: string.unquoted.embedded.d
      set:
        - meta_scope: meta.string.d
        - match: '}'
          scope: string.unquoted.embedded.d punctuation.definition.string.end.d
          pop: true
        - include: tokens-in

  # Purely a set of un-verified tokens
  tokens-in:
    - match: '\b({{keyword}})\b'
      scope: keyword.d
    - match: '\b({{basic_type}})\b'
      scope: storage.type.d
    - match: '\b({{language_constant}})\b'
      scope: constant.language.d
    - match: '\b({{language_variable}})\b'
      scope: variable.language.d
    - include: character-in
    - include: string-in
    - include: number-in
    - match: '{{name}}'
    - match: '(/|&|\||-|\+|<<|<>|>>|>>>||\*|%|\^|\^\^|~)='
      scope: keyword.operator.assignment.d
    - match: '(/|<=|>=|==|!<>=|!<=|!>=|\.\.\.|\.\.|&|&&|\||\|\||-|--|\+|\+\+|<|<<|<>|>|>>|>>>|!|!<>|!<|!>|\?|,|:|\$|\*|%|\^|\^\^|~|@|=>|#)'
      scope: keyword.operator.d
    - match: ';'
      scope: punctuation.terminator.d
    - match: '\.'
      scope: punctuation.accessor.dot.d
    - match: '\('
      scope: punctuation.section.parens.begin.d
      push:
        - match: '\)'
          scope: punctuation.section.parens.end.d
          pop: true
        - include: tokens-in
    - match: '\['
      scope: punctuation.section.brackets.begin.d
      push:
        - match: '\]'
          scope: punctuation.section.brackets.end.d
          pop: true
        - include: tokens-in
    - match: '\{'
      scope: punctuation.section.braces.begin.d
      push:
        - match: '\}'
          scope: punctuation.section.braces.end.d
          pop: true
        - include: tokens-in
    - include: not-whitespace-illegal

  attribute-specifier-in:
    - match: '{{attribute_lookahead}}'
      push: [attribute-specifier-after, attribute]
    - match: '\b({{type_qualifier}})\b(?!\s*\()'
      scope: storage.modifier.d
      push: attribute-specifier-after
  attribute-specifier-after:
    - match: ':'
      scope: punctuation.separator.d
      pop: true
    - include: end-of-line
    - match: '{{block_statement_loohahead}}'
      set: block-statement
    - match: '{{attribute_lookahead}}'
      push: attribute
    - match: '\b({{type_qualifier}})\b(?!\s*\()'
      scope: storage.modifier.d
    - match: '(?=\b({{reserved}})\b)'
      pop: true
    - match: '{{construction_lookahead}}'
      set: construction
    - match: '(?=\b{{name}}\b\s*[,=\()])'
      set: [function-or-variable-after-type]
    - match: '(?=\S)'
      set: [function-or-variable-after-type, type]
    - include: not-whitespace-illegal-pop

  parameter-attribute-in:
    - match: '{{attribute_lookahead}}'
      push: [parameter-attribute-after, attribute]
    - match: '\b({{parameter_attribute}})\b'
      scope: storage.modifier.d
      push: parameter-attribute-after
    - match: '\b({{type_qualifier}})\b(?!\s*\()'
      scope: storage.modifier.d
      push: parameter-attribute-after
  parameter-attribute-after:
    - match: '{{attribute_lookahead}}'
      set: [parameter-attribute-after, attribute]
    - match: '\b({{parameter_attribute}})\b'
      scope: storage.modifier.d
      set: parameter-attribute-after
    - match: '\b({{type_qualifier}})\b(?!\s*\()'
      scope: storage.modifier.d
      set: parameter-attribute-after
    - match: '(?=\S)'
      pop: true

  function-attribute-in:
    - include: attribute-in
    - match: '\b({{type_qualifier}})\b'
      scope: storage.modifier.d

  attribute-in:
    - match: '{{attribute_lookahead}}'
      push: attribute

  attribute:
    - match: '\b({{attributes}})\b'
      scope: storage.modifier.d
      pop: true
    - match: '@(?=\s*({{at_attributes}})\b)'
      scope: storage.modifier.d
      set: at-attribute
    - match: '@'
      scope: punctuation.definition.annotation.begin.d
      set: at-attribute
    - match: '\b(extern)\s*(\()'
      captures:
        1: keyword.other.external.d
        2: punctuation.section.parens.begin.d
      set: extern-attribute
    - match: '\b(extern)\b'
      scope: storage.modifier.external.d
      pop: true
    - match: '\b(align)\b'
      scope: keyword.other.alignment.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [align-attribute-after, value]
        - match: '(?=\S)'
          pop: true
    - match: '\b(deprecated)\b'
      scope: keyword.other.deprecated.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [deprecated-attribute-after, value]
        - match: '(?=\S)'
          pop: true
    - match: '\b(private|protected|public|export)\b'
      scope: storage.modifier.access-control.d
      pop: true
    - match: '\b(package)\b'
      scope: storage.modifier.access-control.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [attribute-parens-after, identifier]
        - match: (?=\S)
          pop: true
    - match: '\b(pragma)\b'
      scope: keyword.other.pragma.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: pragma-attribute
        - include: not-whitespace-illegal-pop
    - include: not-whitespace-illegal-pop
  attribute-parens-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  at-attribute:
    - match: '({{at_attributes}})\b'
      scope: storage.modifier.d
      pop: true
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [uda-after, value-list]
    - match: '({{name}})\s*(\()'
      scope: meta.function-call.d
      captures:
        1: meta.path.d storage.type.d
        2: punctuation.section.parens.begin.d
      set: [meta-function-call, uda-after, value-list]
    - match: '({{name}})\b'
      scope: meta.path.d storage.type.d
      pop: true
  uda-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  extern-attribute:
    - match: '(C\+\+|C|D|Windows|System|Objective-C)'
      scope: string.other.d
      set: extern-attribute-after
    - match: (?=\S)
      set: [extern-attribute-after, identifier]
  extern-attribute-after:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: extern-attribute
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  align-attribute-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
  deprecated-attribute-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
  pragma-attribute:
    - match: '\b({{name}})\b'
      scope: variable.function.d
      set:
        - match: '\)'
          scope: punctuation.section.parens.end.d
          pop: true
        - match: ','
          scope: punctuation.separator.sequence.d
          set: [pragma-attribute-after, value-list]
        - include: not-whitespace-illegal-pop
    - include: not-whitespace-illegal-pop
  pragma-attribute-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  # TODO: Maybe make imports non-indexed entities (as opposed to variables)
  import-in:
    - match: '\b(import)(?!\s*\()\b'
      scope: keyword.control.import.d
      push: [import-list, identifier]
  import-list:
    - match: ':'
      scope: punctuation.separator.import-binding.d
      set: [import-binding-list, identifier]
    - match: ','
      scope: punctuation.separator.sequence.d
      set: [import-list, identifier]
    - match: '='
      scope: keyword.operator.assignment.d
      set: [import-list-after-assignment, identifier]
    - include: expect-end-of-line
  import-list-after-assignment:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: [import-list, identifier]
    - include: expect-end-of-line
  import-binding-list:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: [import-binding-list, identifier]
    - match: '='
      scope: keyword.operator.assignment.d
      set: [import-binding-list-after-assignment, identifier]
    - include: expect-end-of-line
  import-binding-list-after-assignment:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: [import-binding-list, identifier]
    - include: expect-end-of-line

  type:
    - match: '\b({{type_qualifier}})\b'
      scope: storage.modifier.d
      set:
        - match: '\('
          scope: punctuation.section.group.begin.d
          set: [basic-type2, type-storage-modifier-end, type]
        - match: '(?=\S)'
          set: type
    - match: '(?=\S)'
      set: basic-type
  type-storage-modifier-end:
    - match: '\)'
      scope: punctuation.section.group.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  basic-type:
    - include: attribute-in
    - match: '\btypeof\b'
      scope: keyword.other.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [basic-type2, basic-type2-after-parens, typeof-value]
    - match: '\bauto\b'
      scope: keyword.other.d
      pop: true
    - match: '{{name_lookahead}}'
      set: [basic-type2, type-identifier-ref]
    - match: '(?=\S)'
      pop: true

  basic-type2:
    - match: '\*'
      scope: keyword.operator.pointer.d
    - match: '\['
      scope: punctuation.section.brackets.begin.d
      push: [basic-type2-after-brackets, value-list]
    - match: '\b(delegate|function)\b'
      scope: keyword.other.d
      set: [basic-type2, function-type]
    - match: '!(?!=|is\b)'
      scope: meta.function-call.d keyword.operator.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [basic-type2, basic-type2-after-call, value-list]
        - match: '(?=\S)'
          set: [basic-type2, meta-function-call, value-template-single]
    - match: '\.(?!\.\.)'
      scope: storage.type.d
      set:
        - match: '\b({{name}})\b'
          scope: storage.type.d
          set: basic-type2
    - match: '(?=\S)'
      pop: true
  basic-type2-after-brackets:
    - match: '\]'
      scope: punctuation.section.brackets.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  basic-type2-after-parens:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  basic-type2-after-call:
    - meta_scope: meta.function-call.d
    - include: basic-type2-after-parens

  typeof-value:
    - match: '\breturn\b'
      scope: keyword.other.d
      pop: true
    - include: value

  function-type:
    - match: (?=\()
      set: [function-type-after, function-type-argument-definition-list]
    - include: not-whitespace-illegal-pop
  function-type-after:
    - include: function-attribute-in
    - match: '(?=\S)'
      pop: true

  # Function type arguments are slightly different to regular function
  # arguments. With regular arguments a standalone "name" is asssumed to be a
  # template argument, but with function types they must be a type.
  function-type-argument-definition-list:
    - match: '\('
      scope: punctuation.section.group.begin.d
      set:
        - match: '\)'
          scope: punctuation.section.group.end.d
          pop: true
        - match: '(?=\S)'
          set: [function-type-argument, function-type-argument-type]
    - include: not-whitespace-illegal-pop
  function-type-argument-type:
    - include: parameter-attribute-in
    - match: '\.\.\.'
      scope: keyword.operator.variadic.d
      pop: true
    - include: type
  function-type-argument:
    - match: '\b{{name}}\b'
      scope: variable.parameter.d
      set:
        - match: '\.\.\.'
          scope: keyword.operator.variadic.d
        - match: ','
          scope: punctuation.separator.sequence.d
          set: [function-type-argument, function-type-argument-type]
        - match: '='
          scope: keyword.operator.assignment.d
          push: value
        - match: ':'
          scope: keyword.operator.comparison.d
          push: value
        - match: '\)'
          scope: punctuation.section.group.end.d
          pop: true
        - include: not-whitespace-illegal-pop
    - match: ','
      scope: punctuation.separator.sequence.d
      push: function-type-argument-type
    - match: '\)'
      scope: punctuation.section.group.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  function-or-variable-after-type:
    - match: '\b({{operator_overloads}})\s*(?=\(|$)'
      scope: meta.function.d
      captures:
        1: entity.name.function.operator.d
      set: function-definition-begin
    - match: '\b({{name}})\s*(?=\(|$)'
      scope: meta.function.d
      captures:
        1: entity.name.function.d
      set: function-definition-begin
    - match: '(?=\S)'
      set: variable-definition-begin
  function-definition-begin:
    - match: '(?=\()'
      set: [function-definition-after-first-argument-list, function-argument-definition-list]
    - include: not-whitespace-illegal-pop
  function-definition-after-first-argument-list:
    - match: '(?=\()'
      set: [function-definition-before-after-arguments, function-argument-definition-list]
    - match: '(?=\S)'
      set: function-definition-after-arguments
  function-definition-before-after-arguments:
    - match: ''
      set: function-definition-after-arguments
  function-definition-after-arguments:
    - meta_scope: meta.function.d
    - include: function-attribute-in
    - match: '='
      scope: keyword.operator.assignment.d
      set: [meta-function, expect-end-of-line, value]
    - match: '\bif\b'
      scope: keyword.control.conditional.d
      set: [meta-function, function-definition-after-condition, condition]
    - match: '(?=\S)'
      set: [meta-function, function-definition-after-condition]
  function-definition-after-condition:
    - match: '\bin\b'
      scope: keyword.control.conditional.d
      set:
        - match: '(?=\()'
          set: [function-definition-after-condition, assert-arguments]
        - match: '{{block_statement_loohahead}}'
          set: [function-definition-after-condition, block-statement]
        - include: not-whitespace-illegal-pop
    - match: '\bout\b'
      scope: keyword.control.conditional.d
      push: function-out-contract
    - match: '\b(do|body)\b'
      scope: keyword.other.d
      set: block-statement
    - match: '{{block_statement_loohahead}}'
      set: block-statement
    - include: expect-end-of-line
  function-out-contract:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set:
        - match: '{{name}}'
          scope: variable.parameter.d
          set:
            - match: ';'
              scope: punctuation.separator.sequence.d
              set: [function-out-contract-after, value-list]
            - match: '(?=\S)'
              set: [block-statement, function-out-contract-after]
        - match: ';'
          scope: punctuation.separator.sequence.d
          set: [function-out-contract-after, value-list]
        - include: not-whitespace-illegal-pop
    - match: '{{block_statement_loohahead}}'
      set: block-statement
    - include: not-whitespace-illegal-pop
  function-out-contract-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  function-argument-definition-list:
    - match: '\('
      scope: punctuation.section.group.begin.d
      set: function-argument-definition-list-content
    - include: not-whitespace-illegal-pop
  function-argument-definition-list-content:
    - meta_scope: meta.function.parameters.d
    - match: '\)'
      scope: punctuation.section.group.end.d
      pop: true
    - match: '(?=\S)'
      set: [meta-function-parameters, function-argument, function-argument-or-type]
  function-argument-or-type:
    - include: parameter-attribute-in
    - match: '\.\.\.'
      scope: keyword.operator.variadic.d
      pop: true
    - match: '(?={{name}}\s*([,=:\)]|\.\.\.))'
      pop: true
    - include: type
  function-argument:
    - match: '\b{{name}}\b'
      scope: variable.parameter.d
      set:
        - match: '\.\.\.'
          scope: keyword.operator.variadic.d
        - match: ','
          scope: punctuation.separator.sequence.d
          set: [function-argument, function-argument-or-type]
        - match: '='
          scope: keyword.operator.assignment.d
          push: value
        - match: ':'
          scope: keyword.operator.comparison.d
          push: value
        - match: '\)'
          scope: punctuation.section.group.end.d
          pop: true
        - include: not-whitespace-illegal-pop
    - match: ','
      scope: punctuation.separator.sequence.d
      push: type
    - match: '\)'
      scope: punctuation.section.group.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  optional-template-body-block:
    - match: '{{block_statement_loohahead}}'
      set: block-statement
    - match: '\bif\b'
      scope: keyword.control.conditional.d
      set: [block-statement, condition]
    - include: expect-end-of-line

  variable-definition-begin:
    - match: '\b{{name}}\b'
      scope: variable.other.d
      set:
        - match: '(?=,)'
          set: variable-definition-after
        - match: '='
          scope: keyword.operator.assignment.d
          set: [variable-definition-after, value]
        - include: expect-end-of-line
    - include: not-whitespace-illegal-pop
  variable-definition-after:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: variable-definition-begin
    - include: expect-end-of-line

  value-or-declaration-in:
    - match: '{{definitely_value_lookahead}}'
      push: [maybe-end-of-line, value-list]
    - match: '{{definitely_declaration_lookahead}}'
      push: [function-or-variable-after-type, type]
    - match: '(?=\S)'
      push: [maybe-end-of-line, first-value]

  # The first value in an expression ending with a * is always a function/variable definition, otherwise it could be either
  # We highlight as if it were a value, but switch to a definition if it turns out to be one
  first-value:
    - match: '\btypeof\b'
      scope: keyword.other.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [first-value-parens-after, typeof-value]
    - match: '\b({{basic_type}})\b'
      scope: storage.type.d
      set: first-value-after
    # Match a regular function call so we properly highlight the name as a
    # function
    - match: '(?=[[:alpha:]0-9_\.]+\s*\()'
      set: value-list
    - match: '{{name_lookahead}}'
      scope: variable.other.d
      set: [first-value-after, value-identifier]
    - match: '(?=\S)'
      set: value-list
  first-value-after:
    - match: '\.'
      scope: meta.path.d punctuation.accessor.dot.d
      push: value-identifier
    - match: '!(?!=|is\b)'
      scope: meta.function-call.d keyword.operator.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [first-value-call-after, value-list]
        - match: '(?=\S)'
          set: [first-value-after, meta-function-call, value-template-single]
    - match: '\['
      scope: punctuation.section.brackets.begin.d
      set: [first-value-bracket-after, value-list]
    - match: ','
      scope: punctuation.separator.sequence.d
      set: value-list
    # Attempt to match pointers
    - match: '(?=\*\s*([\*\[]|$))'
      set: [function-or-variable-after-type, basic-type2]
    - match: '(?=\*\s*{{name}}\s*[=;\(])'
      set: [function-or-variable-after-type, basic-type2]
    - match: '(?=\b(function|delegate)\b)'
      set: [value-list-after, value]
      scope: keyword.other.d
    - match: '(?={{name}}\s*([;=\(,]|$))'
      set: function-or-variable-after-type
    - match: '(?=\S)'
      set: [value-list-after, value-after]
  first-value-bracket-after:
    - match: '\]'
      scope: punctuation.section.brackets.end.d
      set: first-value-after
    - include: not-whitespace-illegal-pop
  first-value-parens-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: first-value-after
    - include: not-whitespace-illegal-pop
  first-value-call-after:
    - meta_scope: meta.function-call.d
    - include: first-value-parens-after

  value:
    - include: attribute-in
    - match: '!'
      scope: keyword.operator.logical.d
      set: value
    - match: '~'
      scope: keyword.operator.bitwise.d
      set: value
    - match: '(\+\+|--|\+|-)'
      scope: keyword.operator.arithmetic.d
      set: value
    - match: '(\*|&)'
      scope: keyword.operator.bitwise.d
      set: value
    - match: '\bcast\b'
      scope: keyword.operator.word.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [cast-after, type]
        - include: not-whitespace-illegal-pop
    - match: '\bdelete\b'
      scope: keyword.operator.word.d
      set: value
    - match: '\bnew\b'
      scope: keyword.operator.word.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [new-after-parens, value-list]
        - match: '(?=\S)'
          set: new-after
    - match: '\bimport\b'
      scope: keyword.control.import.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [value-parens-after, value]
        - include: not-whitespace-illegal-pop
    - match: '\bmixin\b'
      scope: keyword.control.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [value-parens-after, value-list]
        - include: not-whitespace-illegal-pop
    - match: \bassert\b
      scope: keyword.other.assert.d
      set: [value-after, assert-arguments]
    - match: '\bis\b'
      scope: keyword.other.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [value-after, is-after-type, type]
        - include: not-whitespace-illegal-pop
    - match: '\btypeof\b'
      scope: keyword.other.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [value-parens-after, typeof-value]
    - match: '\b__traits\b'
      scope: keyword.other.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set:
            - match: '\b{{name}}\b'
              scope: variable.function.d
              set:
                - match: ','
                  scope: punctuation.separator.sequence.d
                  set: [value-parens-after, value-list]
    - match: '\b(function|delegate)\b'
      scope: meta.function.d keyword.other.d
      set:
        - meta_scope: meta.function.d
        - match: '(?=\()'
          set: [value-after, function-definition-begin]
        - match: '(?=\S)'
          set: [value-after, function-definition-begin, meta-function, type]
    - match: '(\()\s*(\))'
      scope: meta.function.parameters.d
      captures:
        1: punctuation.section.parens.begin.d
        2: punctuation.section.parens.end.d
      set: [value-after, value-group-after-parens]
    - match: '\('
      scope: punctuation.section.group.begin.d
      set:
        - match: '{{parameter_attribute_lookahead}}'
          set: [value-group-after-parens, function-argument, function-argument-or-type]
        - match: '(?=\S)'
          set: [value-group-after, value]
    - match: '(?={)'
      set: [value-after, block-statement]
    - match: '\['
      scope: punctuation.section.brackets.begin.d
      set: [value-bracket-after, value-array-list]
    - match: '{{type_qualifier_lookahead}}'
      set: [value-after, type]
    - match: '{{number_lookahead}}'
      set: [value-after, number]
    - match: '{{character_lookahead}}'
      set: [value-after, character]
    - match: '{{string_lookahead}}'
      set: [value-after, string]
    - match: '\b({{language_constant}})\b'
      scope: constant.language.d
      set: value-after
    - match: '\b({{language_variable}})\b'
      scope: variable.language.d
      set: value-after
    - match: '\$'
      scope: variable.language.d
      set: value-after
    - match: '\b({{basic_type}})\b'
      scope: storage.type.d
      set: value-after
    - match: '\b({{name}})\s*(=>)'
      captures:
        1: variable.parameter.d
        2: storage.type.function.d keyword.declaration.function.lambda.d
      set: [meta-function, value]
    - match: \.
      scope: meta.path.d punctuation.accessor.dot.d
      set: [value-after, value-identifier]
    - match: '\b({{name}})\s*(:)'
      captures:
        1: variable.other.d
        2: punctuation.separator.mapping.key-value.d
      set: value
    - match: '{{name_lookahead}}'
      set: [value-after, value-identifier]
    - include: not-whitespace-illegal-pop
  cast-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: value
    - include: not-whitespace-illegal-pop
  new-after-parens:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: new-after
    - include: not-whitespace-illegal-pop
  new-after:
    - match: '\bclass\b'
      scope: meta.class.d storage.type.class.d keyword.declaration.class.d
      set: [meta-class, new-class]
    - match: (?={{identifier_ref}}\s*\()
      set: [new-after-named, new-type-identifier-ref]
    - match: (?=\S)
      set: [new-after-named, type]
  new-class:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [new-anonymous-after-args, value-list]
    - match: '(?={)'
      set: optional-template-body-block
    - match: '(?=\S)'
      set: [optional-template-body-block, base-class-list]
  new-after-named:
    - meta_scope: meta.function-call.d
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [value-call-parens-after, value-list]
    - match: (?=\S)
      set: value-after
  new-anonymous-after-args:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set:
        - match: '(?={)'
          set: optional-template-body-block
        - match: '(?=\S)'
          set: [optional-template-body-block, base-class-list]
    - include: not-whitespace-illegal-pop
  is-after-type:
    - match: '\b({{name}})\b'
      scope: variable.parameter.d
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - match: '\=\=|:'
      scope: keyword.operator.comparison.d
      set: [is-after, type-specialization]
  is-after:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: function-argument-definition-list-content
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop
  type-specialization:
    - match: '\b(?:__vector|function|delegate|__parameters)\b'
      scope: keyword.other.d
      set:
        - match: '(?=\))'
          pop: true
        - include: type-specialization
    - match: '\breturn\b'
      scope: keyword.control.flow.d
      set:
        - match: '(?=\))'
          pop: true
        - include: type-specialization
    - match: '\bsuper\b'
      scope: variable.language.d
      set:
        - match: '(?=\))'
          pop: true
        - include: type-specialization
    - match: '\b(?:struct|union|class|interface|enum)\b'
      scope: storage.type.d keyword.declaration.d
      set:
        - match: '(?=\))'
          pop: true
        - include: type-specialization
    - match: '(?=\S)'
      set: type
    - include: not-whitespace-illegal-pop
  value-group-after:
    - match: '\b(function|delegate)\b'
      scope: keyword.other.d
      set: [value-group-after, basic-type2, function-type]
    - match: '\)'
      scope: punctuation.section.group.end.d
      set: value-group-after-parens
    - match: '\b({{name}})\b'
      scope: variable.parameter.d
      set: value-group-after
    - match: ','
      scope: punctuation.separator.sequence.d
      set: [value-group-after-parens, function-argument, function-argument-or-type]
    - match: '\.\.\.'
      scope: keyword.operator.variadic.d
    - include: not-whitespace-illegal-pop
  value-group-after-parens:
    - match: '{{function_attribute_lookahead}}'
      set: value-group-after-lambda
    - match: (?={)
      set: [value-after, meta-function, block-statement]
    - match: '=>'
      scope: meta.function.d storage.type.function.d keyword.declaration.function.lambda.d
      set: [meta-function, value]
    - match: (?=\S)
      set: value-after
  value-group-after-lambda:
    - meta_scope: meta.function.d
    - include: function-attribute-in
    - match: (?={)
      set: [value-after, meta-function, block-statement]
    - match: '=>'
      scope: meta.function.d storage.type.function.d keyword.declaration.function.lambda.d
      set: [meta-function, value]
    - include: not-whitespace-illegal-pop
  value-identifier:
    - match: '\b{{name}}\b(?=\s*(\(|!(?!=|is\b)))'
      scope: meta.function-call.d meta.path.d variable.function.d
      pop: true
    - match: '\b{{name}}\b'
      scope: meta.path.d variable.other.d
      set:
        - match: \.(?!\.)
          scope: meta.path.d punctuation.accessor.dot.d
          set: value-identifier
        - match: (?=\S)
          pop: true
    - include: not-whitespace-illegal-pop
  value-after:
    - match: '\.\.(?!\.)'
      scope: keyword.operator.slice.d
      set: value
    - match: '\.(?!\.\.)'
      scope: meta.path.d punctuation.accessor.dot.d
      set: [value-after, value-identifier]
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [value-call-parens-after, value-list]
    - match: '\['
      scope: punctuation.section.brackets.begin.d
      set: [value-bracket-after, value-list]
    - match: '(\+\+|--)'
      scope: keyword.operator.arithmetic.d
      set: value-after
    - match: '(&&|\|\|)'
      scope: keyword.operator.logical.d
      set: value
    - match: '(\+|-|/|%|\*|&|\||\^\^|\^|~|<<|>>>|>>)='
      scope: keyword.operator.assignment.d
      set: value
    - match: '(\+|\-|/|%|\^\^)'
      scope: keyword.operator.arithmetic.d
      set: value
    - match: '~'
      scope: keyword.operator.concatenation.d
      set: value
    - match: '(<<|>>>|>>|\||\^|&)'
      scope: keyword.operator.bitwise.d
      set: value
    - match: '(==|!=|\bis\b|!is\b|<=|<|>=|>|\bin\b|!in\b)'
      scope: keyword.operator.comparison.d
      set: value
    - match: '='
      scope: keyword.operator.assignment.d
      set: value
    - match: '!'
      scope: meta.function-call.d punctuation.section.generic.begin.d
      set:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [value-call-parens-after, value-list]
        - match: '(?=\S)'
          set: [value-after, meta-function-call, value-template-single]
    - match: \*(?=\s*[\),;\]\*])
      scope: keyword.operator.pointer.d
      set: value-maybe-pointer-after
    - match: \*
      scope: keyword.operator.arithmetic.d
      set: value-maybe-pointer-after
    - match: '\?'
      scope: keyword.operator.ternary.d
      set: [value-condition-after, value]
    - match: '(?=\b(function|delegate)\b)'
      set: [value-after, basic-type2]
    - match: '(?=\S)'
      pop: true
  value-template-single:
    - match: '\b({{basic_type}})\b'
      scope: storage.type.d
      pop: true
    - match: '{{number_lookahead}}'
      set: number
    - match: '{{character_lookahead}}'
      set: character
    - match: '{{string_lookahead}}'
      set: string
    - match: '\b({{language_constant}})\b'
      scope: constant.language.d
      pop: true
    - match: '\b({{language_variable}})\b'
      scope: variable.language.d
      pop: true
    - match: '{{name_lookahead}}|\.'
      set: identifier-ref
    - include: not-whitespace-illegal-pop
  value-maybe-pointer-after:
    # This can also be a pointer in some situations
    - match: '(?=[\),;\]])'
      pop: true
    - match: '(?=\*)'
      set: basic-type2
    - match: '(?=\S)'
      set: value
  value-condition-after:
    - match: ':'
      scope: keyword.operator.ternary.d
      set: value
    - include: not-whitespace-illegal-pop
  value-parens-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: value-after
    - include: not-whitespace-illegal-pop
  value-call-parens-after:
    - meta_scope: meta.function-call.d
    - include: value-parens-after
  value-bracket-after:
    - match: '\]'
      scope: punctuation.section.brackets.end.d
      set: value-after
    - include: not-whitespace-illegal-pop

  value-list:
    - match: '(?=\)|}|]|;|:)'
      pop: true
    - match: '(?=\S)'
      set: [value-list-after, value]
  value-list-after:
    - match: '(?=\)|}|]|;|:)'
      pop: true
    - match: ','
      scope: punctuation.separator.sequence.d
      set: value-list
    - include: not-whitespace-illegal-pop

  value-array-list:
    - match: '(?=\])'
      pop: true
    - match: '(?=\S)'
      set: [value-array-list-after, value]
  value-array-list-after:
    - match: ':'
      scope: punctuation.separator.mapping.key-value.d
      set: [value-array-list-after-value, value]
    - include: value-array-list-after-value
  value-array-list-after-value:
    - match: '(?=\])'
      pop: true
    - match: ','
      scope: punctuation.separator.sequence.d
      set: value-array-list
    - include: not-whitespace-illegal-pop

  alias-in:
    - match: '\b(alias)\b(?=[^;]*\bthis\s*;)'
      scope: keyword.control.alias.d
      push:  [alias-this-after, identifier]
    - match: '\b(alias)\b'
      scope: keyword.control.alias.d
      push:
        - match: '{{type_qualifier_lookahead}}'
          set: [alias-old, type]
        - match: '\b({{name}})\s*(?=\(|=)'
          captures:
            1: entity.name.type.d
          set: alias-new
        - match: (?=\S)
          set: [alias-old, type]
  alias-this-after:
    - match: \b(this)\b
      scope: keyword.control.alias.d
      set: expect-end-of-line
    - include: not-whitespace-illegal-pop
  alias-old:
    - match: '\b({{name}})\b'
      scope: entity.name.type.d
      set:
        - match: ','
          scope: punctuation.separator.sequence.d
          set: alias-old
        - include: expect-end-of-line
    - include: not-whitespace-illegal-pop
  alias-new:
    - match: '(?=\()'
      push: function-argument-definition-list
    - match: '(?==)'
      set: alias-new-assign
    - include: not-whitespace-illegal-pop
  alias-new-assign:
    - match: '='
      scope: keyword.operator.assignment.d
      set: [alias-new-after-type, value]
    - include: not-whitespace-illegal-pop
  alias-new-after-type:
    - match: ','
      scope: punctuation.separator.sequence.d
      set:
        - match: '\b{{name}}\b'
          scope: entity.name.type.d
          set: alias-new
        - include: not-whitespace-illegal-pop
    - include: expect-end-of-line

  class-in:
    - match: '\b(class)\b'
      scope: storage.type.class.d keyword.declaration.class.d
      push: [meta-class, class-name]
  class-name:
    - match: '\b({{name}})\b'
      scope: entity.name.class.d
      set:
        - match: '(?=\()'
          set: [class-after, function-argument-definition-list]
        - match: '(?=\S)'
          set: class-after
    - include: not-whitespace-illegal-pop
  class-after:
    - include: end-of-line
    - match: ':'
      scope: punctuation.separator.mapping.d
      set: [optional-template-body-block, base-class-list]
    - match: '(?=\S)'
      set: optional-template-body-block

  base-class-list:
    - match: ''
      set: [base-class-list-after, basic-type]
  base-class-list-after:
    - match: ','
      scope: punctuation.separator.sequence.d
      set: base-class-list
    - match: '(?={)'
      pop: true
    - include: not-whitespace-illegal-pop

  interface-in:
    - match: '\b(interface)\b'
      scope: storage.type.interface.d keyword.declaration.interface.d
      push: [meta-interface, interface-name]
  interface-name:
    - match: '\b({{name}})\b'
      scope: entity.name.interface.d
      set:
        - match: '(?=\()'
          set: [interface-after, function-argument-definition-list]
        - match: '(?=\S)'
          set: interface-after
    - include: not-whitespace-illegal-pop
  interface-after:
    - match: ':'
      scope: punctuation.separator.mapping.d
      set: [optional-template-body-block, base-class-list]
    - match: '(?={)'
      set: optional-template-body-block
    - include: expect-end-of-line

  struct-in:
    - match: '\b(struct)\b'
      scope: storage.type.struct.d keyword.declaration.struct.d
      push: [meta-struct, struct-name]
  struct-name:
    - match: '\b({{name}})\b'
      scope: entity.name.struct.d
      set:
        - match: '(?=\()'
          set: [optional-template-body-block, function-argument-definition-list]
        - match: '(?=\S)'
          set: optional-template-body-block
    - match: '(?={)'
      set: optional-template-body-block
    - include: not-whitespace-illegal-pop

  union-in:
    - match: '\b(union)\b'
      scope: storage.type.union.d keyword.declaration.union.d
      push: [meta-union, union-name]
  union-name:
    - match: '\b({{name}})\b'
      scope: entity.name.union.d
      set:
        - match: '(?=\()'
          set: [optional-template-body-block, function-argument-definition-list]
        - match: '(?=\S)'
          set: optional-template-body-block
    - match: '(?={)'
      set: optional-template-body-block
    - include: not-whitespace-illegal-pop

  enum-in:
    - match: '\b(enum)\b'
      scope: storage.type.enum.d keyword.declaration.enum.d
      push: [meta-enum, enum-after-kw]
  enum-after-kw:
    - match: '(?=\b({{basic_type}})\b)'
      push: type
    - match: '{{type_qualifier_lookahead}}'
      push: type
    - match: '\b({{name}})(?=\s*({|:|=|\(|;|$))\b'
      scope: entity.name.enum.d
      set: enum-after
    - match: ':'
      scope: punctuation.separator.mapping.d
      set: [enum-body, type]
    - match: '(?={)'
      set: anonymous-enum-body
    - match: '(?=\S)'
      push: type
  enum-after:
    - match: '(?={)'
      set: enum-body
    - match: ':'
      scope: punctuation.separator.mapping.d
      set: [enum-body, type]
    - match: '(?==|\()'
      set: enum-assignment
    - match: '\b({{name}})\b'
      scope: entity.name.enum.d
    - include: expect-end-of-line

  enum-body:
    - match: '{'
      scope: punctuation.section.block.begin.d
      set:
        - match: '}'
          scope: punctuation.section.block.end.d
          pop: true
        - match: '(?=\b({{name}})\b)'
          push: enum-member
        - include: not-whitespace-illegal
    - include: expect-end-of-line

  enum-assignment:
    - match: '='
      scope: keyword.operator.assignment.d
      set: [enum-assignment-after, value]
    - match: '(?=\()'
      push: function-argument-definition-list
    - include: not-whitespace-illegal-pop
  enum-assignment-after:
    - match: ','
      scope: punctuation.separator.sequence.d
      set:
        - match: '\b({{name}})\b'
          scope: entity.name.enum.d
          set: enum-assignment
        - include: not-whitespace-illegal-pop
    - include: expect-end-of-line

  anonymous-enum-body:
    - match: '{'
      scope: punctuation.section.block.begin.d
      set:
        - match: '}'
          scope: punctuation.section.block.end.d
          pop: true
        - include: attribute-in
        - match: '(?=\b({{name}})\s*(=|,|}|/|$))'
          push: enum-member
        - match: '(?=\S)'
          push: [enum-member, type]
    - include: not-whitespace-illegal-pop

  enum-member:
    - match: '\b({{name}})\b'
      scope: entity.name.constant.d
      set:
        - match: '='
          scope: keyword.operator.assignment.d
          set: [enum-member-after, value]
        - match: ','
          scope: punctuation.separator.sequence.d
          pop: true
        - match: '(?=})'
          pop: true
        - include: not-whitespace-illegal-pop
    - include: not-whitespace-illegal-pop
  enum-member-after:
    - match: ','
      scope: punctuation.separator.sequence.d
      pop: true
    - match: '(?=})'
      pop: true
    - include: not-whitespace-illegal-pop

  conditional-declaration-in:
    - match: '\bversion\b'
      scope: keyword.control.conditional.d
      push: version-condition
    - match: '\bdebug\b'
      scope: keyword.control.conditional.d
      push: debug-condition
  conditional-declaration-after-parens:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: optional-block-statement-or-label
    - include: not-whitespace-illegal-pop
  conditional-declaration-assignment:
    - match: '\b{{name}}\b'
      scope: entity.name.constant.d
      set: expect-end-of-line
    - match: '{{integer_lookahead}}'
      set: [expect-end-of-line, integer]
    - include: not-whitespace-illegal-pop
  version-condition:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set:
        - match: \bunittest\b
          scope: keyword.control.conditional.d
          set: conditional-declaration-after-parens
        - match: \bassert\b
          scope: keyword.other.assert.d
          set: conditional-declaration-after-parens
        - match: '\b({{name}})\b'
          scope: constant.other.d
          set: conditional-declaration-after-parens
        - match: '{{integer_lookahead}}'
          set: [conditional-declaration-after-parens, integer]
        - include: not-whitespace-illegal
    - match: '='
      scope: keyword.operator.assignment.d
      set: conditional-declaration-assignment
    - include: not-whitespace-illegal-pop
  debug-condition:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set:
        - match: '\b({{name}})\b'
          scope: constant.other.d
          set: conditional-declaration-after-parens
        - match: '{{integer_lookahead}}'
          set: [conditional-declaration-after-parens, integer]
        - include: not-whitespace-illegal
    - match: '='
      scope: keyword.operator.assignment.d
      set: conditional-declaration-assignment
    - match: '(?=\S)'
      set: optional-block-statement-or-label

  static-foreach-in:
    - match: '\b(static)\s+(foreach|foreach_reverse)\b'
      captures:
        1: keyword.control.loop.d
        2: keyword.control.loop.d
      push: [optional-block-statement, foreach-arguments]

  static-assert-in:
    - match: '\b(static)\s+(assert)\b'
      captures:
        1: keyword.other.assert.d
        2: keyword.other.assert.d
      push: [expect-end-of-line, assert-arguments]

  constructions-in:
    - match: '{{construction_lookahead}}'
      push: construction
  construction:
    # Post-blit constructor
    - match: '\b(this)\s*(\()\s*(this)\s*(\))'
      captures:
        1: meta.function.d entity.name.function.post-blit.d
        2: meta.function.parameters.d punctuation.section.group.begin.d
        3: meta.function.parameters.d variable.language.d
        4: meta.function.parameters.d punctuation.section.group.end.d
      set: function-definition-after-arguments
    - match: '\b(this)\s*(?=\(|$)'
      captures:
        1: meta.function.d entity.name.function.constructor.d
        2: punctuation.section.group.begin.d
      set: constructor-argument-list
    - match: '~\s*this'
      scope: meta.function.d entity.name.function.destructor.d
      set: destructor-arguments
    - include: not-whitespace-illegal-pop
  # This could either be function/template parameters or arguments. Assume
  # arguments and switch to parameters when possible
  constructor-argument-list:
    - meta_scope: meta.function.parameters.d
    - match: '\('
      scope: punctuation.section.group.begin.d
      set:
        - meta_scope: meta.function.parameters.d
        - match: '\)'
          scope: punctuation.section.group.end.d
          set: function-definition-after-first-argument-list
        - match: '{{parameter_attribute_lookahead}}'
          set: [function-definition-after-first-argument-list, meta-function-parameters, function-argument-definition-list-content]
        - match: '(?=\S)'
          set: [constructor-argument-list-after-value, value]
    - include: not-whitespace-illegal-pop
  constructor-argument-list-after-value:
    - meta_scope: meta.function.parameters.d
    - match: ','
      scope: punctuation.separator.sequence.d
      set: [constructor-argument-list-after-value, value]
    - match: '\)'
      scope: punctuation.section.group.end.d
      set: function-definition-after-first-argument-list
    - match: '(?=\S)'
      set: [function-definition-after-first-argument-list, meta-function-parameters, function-argument]
  destructor-arguments:
    - match: '\('
      scope: meta.function.parameters.d punctuation.section.group.begin.d
      set:
        - meta_scope: meta.function.parameters.d
        - match: '\)'
          scope: punctuation.section.group.end.d
          set: function-definition-after-arguments
        - include: not-whitespace-illegal-pop
    - include: not-whitespace-illegal-pop

  invariant-in:
    - match: '\b(invariant)\b'
      scope: keyword.other.invariant.d
      push:
        - match: '(?=\()'
          set: [invariant-block, assert-arguments]
        - match: '(?={)'
          set: invariant-block
        - include: not-whitespace-illegal-pop
  invariant-block:
    - match: '{'
      scope: punctuation.section.block.begin.d
      set:
        - match: '}'
          scope: punctuation.section.block.end.d
          pop: true
        - include: statement-list-in
    - include: expect-end-of-line

  unittest-in:
    - match: '\b(unittest)\b'
      scope: keyword.control.conditional.d
      push:
        - match: '(?={)'
          set: block-statement
        - include: attribute-in
        - include: not-whitespace-illegal-pop

  template-in:
    - match: '\b(template)\b'
      scope: storage.type.d keyword.declaration.template.d
      push: template
  template:
    - match: '\b({{name}})\b'
      scope: entity.name.template.d
      set: template-definition-begin
    - include: not-whitespace-illegal-pop
  template-definition-begin:
    - match: '(?=\()'
      set: [optional-template-body-block, function-argument-definition-list]
    - include: not-whitespace-illegal-pop

  mixin-in:
    - match: '\b(mixin)\s+(template)\b'
      captures:
        1: keyword.control.d
        2: storage.type.d keyword.declaration.template.d
      push: template
    - match: '\b(mixin)(?!\s*\()'
      scope: keyword.control.d
      push: [mixin-after, value]
  mixin-after:
    - match: '\b({{name}})\b'
      scope: variable.other.d
      set: expect-end-of-line
    - include: expect-end-of-line

  statement-label-in:
    - match: '\b({{name}})\s*(:)'
      captures:
        1: entity.name.label.d
        2: punctuation.separator.d

  conditional-in:
    - match: '\bif\b'
      scope: keyword.control.conditional.d
      push: [optional-block-statement-or-label, condition]
    - match: '\belse\b'
      scope: keyword.control.conditional.d
      push: optional-block-statement-or-label

  loop-in:
    - match: '\bwhile\b'
      scope: keyword.control.loop.d
      push: [optional-block-statement, condition]
    - match: '\bdo\b'
      scope: keyword.control.loop.d
      push: optional-block-statement
    - match: '\bfor\b'
      scope: keyword.control.loop.d
      push: [optional-block-statement, for-arguments]
    - match: '\b(foreach|foreach_reverse)\b'
      scope: keyword.control.loop.d
      push: [optional-block-statement, foreach-arguments]

  flow-statement-in:
    - match: '\b(continue|break)\b'
      scope: keyword.control.flow.d
      push:
        - match: \b{{name}}\b
          scope: variable.other.constant.d
          set: expect-end-of-line
        - include: expect-end-of-line
    - match: '\breturn\b'
      scope: keyword.control.flow.d
      push:
        - include: end-of-line
        - match: '(?=\S)'
          set: [expect-end-of-line, value]
    - match: '\bgoto\b'
      scope: keyword.control.flow.d
      push:
        - match: '\bdefault\b'
          scope: keyword.control.flow.d
          set: expect-end-of-line
        - match: '\bcase\b'
          scope: keyword.control.flow.d
          set:
            - include: end-of-line
            - match: '(?=\S)'
              set: [expect-end-of-line, value]
        - match: '\b{{name}}\b'
          scope: variable.other.constant.d
          set: expect-end-of-line
        - include: not-whitespace-illegal-pop

  with-in:
    - match: '\bwith\b'
      scope: keyword.other.with.d
      push:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [with-after, value]
        - include: not-whitespace-illegal-pop
  with-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: optional-block-statement
    - include: not-whitespace-illegal-pop

  synchronized-in:
    - match: '\bsynchronized\b'
      scope: keyword.other.synchronized.d
      push:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [synchronized-after, value]
        - match: '(?=\S)'
          set: optional-block-statement
  synchronized-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: optional-block-statement
    - include: not-whitespace-illegal-pop

  try-in:
    - match: '\btry\b'
      scope: keyword.control.exception.d
      push: optional-block-statement
    - match: '\bcatch\b'
      scope: keyword.control.exception.d
      push: [optional-block-statement, catch-arguments]
    - match: '\bfinally\b'
      scope: keyword.control.exception.d
      push: optional-block-statement
  catch-arguments:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [catch-arguments-after, type]
    - include: not-whitespace-illegal-pop
  catch-arguments-after:
    - match: '\b{{name}}\b'
      scope: variable.parameter.d
      set:
        - match: '\)'
          scope: punctuation.section.parens.end.d
          pop: true
        - include: not-whitespace-illegal-pop
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  throw-in:
    - match: '\bthrow\b'
      scope: keyword.control.flow.exception.d
      push: [expect-end-of-line, value]

  scope-in:
    - match: '\b(scope)\s*(\()\s*(exit|success|failure)\s*(\))'
      captures:
        1: keyword.control.flow.d
        2: punctuation.section.parens.begin.d
        3: keyword.control.flow.d
        4: punctuation.section.parens.end.d
      push: optional-block-statement

  asm-in:
    - match: '\basm\b'
      scope: keyword.declaration.asm.d
      push:
        - include: attribute-in
        - match: '{'
          scope: punctuation.section.block.begin.d
          set:
            - match: '}'
              scope: punctuation.section.block.end.d
              pop: true
            - include: tokens-in
        - include: not-whitespace-illegal-pop

  switch-in:
    - match: '\bswitch\b'
      scope: keyword.control.flow.d
      push:
        - match: '\('
          scope: punctuation.section.parens.begin.d
          set: [switch-after, value]
    - match: '\bcase\b'
      scope: keyword.control.flow.d
      push: [case-after, value-list]
    - match: '\bdefault\b'
      scope: keyword.control.flow.d
      push:
        - match: ':'
          scope: punctuation.separator.case-statement.d
          pop: true
        - include: not-whitespace-illegal-pop
  switch-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      set: optional-block-statement
    - include: not-whitespace-illegal-pop
  case-after:
    - match: ':'
      scope: punctuation.separator.case-statement.d
      set:
        - match: '\.\.(?!\.)'
          scope: keyword.operator.d
          set:
            - match: '\bcase\b'
              scope: keyword.control.flow.d
              set: [case-after, value]
            - include: not-whitespace-illegal-pop
        - match: '(?=\S)'
          pop: true
    - include: not-whitespace-illegal-pop

  for-arguments:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set:
        - match: '\)'
          scope: punctuation.section.parens.end.d
          pop: true
        - include: statement-list-in
    - include: not-whitespace-illegal-pop

  foreach-arguments:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [foreach-arguments-end, foreach-parameter-list]
    - include: not-whitespace-illegal-pop
  foreach-parameter-list:
    - match: '(?=;)'
      pop: true
    - match: '(?=\b{{name}}\s*[;,])'
      set: foreach-parameter-after-type
    - include: parameter-attribute-in
    - match: '(?=\S)'
      set: [foreach-parameter-after-type, type]
  foreach-parameter-after-type:
    - match: '\b({{name}})\b'
      scope: variable.parameter.d
      set:
        - match: ','
          scope: punctuation.separator.sequence.d
          set: foreach-parameter-list
        - match: '(?=;)'
          pop: true
        - include: not-whitespace-illegal-pop
    - include: not-whitespace-illegal-pop
  foreach-arguments-end:
    - match: ';'
      scope: punctuation.separator.sequence.d
      set: [foreach-arguments-after, value]
    - include: not-whitespace-illegal-pop
  foreach-arguments-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  assert-arguments:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [assert-arguments-after, value-list]
    - include: not-whitespace-illegal-pop
  assert-arguments-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  condition:
    - match: '\('
      scope: punctuation.section.parens.begin.d
      set: [condition-after, value]
    - include: not-whitespace-illegal-pop
  condition-after:
    - match: '\)'
      scope: punctuation.section.parens.end.d
      pop: true
    - include: not-whitespace-illegal-pop

  identifier:
    - match: '\b{{name}}\b'
      scope: meta.path.d variable.other.d
      set:
        - match: \.
          scope: meta.path.d punctuation.accessor.dot.d
          set: identifier
        - match: '(?=\S)'
          pop: true
    - include: not-whitespace-illegal-pop
  identifier-ref:
    - match: \.
      scope: meta.path.d punctuation.accessor.dot.d
      set: identifier
    - match: '(?=\S)'
      set: identifier

  type-identifier:
    - match: '\b{{name}}\b(?=\s*!)'
      scope: meta.function-call.d meta.path.d variable.function.d
      pop: true
    - match: '\b{{name}}\b'
      scope: meta.path.d storage.type.d
      set:
        - match: \.
          scope: meta.path.d punctuation.accessor.dot.d
          set: type-identifier
        - match: '(?=\S)'
          pop: true
    - include: not-whitespace-illegal-pop
  type-identifier-ref:
    - match: \.
      scope: meta.path.d punctuation.accessor.dot.d
      set: type-identifier
    - match: '(?=\S)'
      set: type-identifier

  new-type-identifier:
    - match: '\b{{name}}(?=\s*\()'
      scope: meta.function-call.d meta.path.d variable.function.d
      pop: true
    - match: '\b{{name}}\b'
      scope: meta.path.d storage.type.d
      set:
        - match: \.
          scope: meta.path.d punctuation.accessor.dot.d
          set: new-type-identifier
        - match: '(?=\S)'
          pop: true
    - include: not-whitespace-illegal-pop
  new-type-identifier-ref:
    - match: \.
      scope: meta.path.d punctuation.accessor.dot.d
      set: new-type-identifier
    - match: '(?=\S)'
      set: new-type-identifier

  not-whitespace-illegal:
    - match: '\S'
      scope: invalid.illegal.d
  not-whitespace-illegal-pop:
    - match: '\S'
      scope: invalid.illegal.d
      pop: true

  end-of-line-in:
    - match: ';'
      scope: punctuation.terminator.d
  end-of-line:
    - match: ';'
      scope: punctuation.terminator.d
      pop: true
  expect-end-of-line:
    - include: end-of-line
    - include: not-whitespace-illegal-pop
  maybe-end-of-line:
    - include: end-of-line
    - match: '(?=\S)'
      pop: true

  check-brackets-in:
    - match: '[\}\]\)]'
      scope: invalid.illegal.d

  meta-function:
    - meta_scope: meta.function.d
    - match: ''
      pop: true

  meta-function-parameters:
    - meta_scope: meta.function.parameters.d
    - match: ''
      pop: true

  meta-function-call:
    - meta_scope: meta.function-call.d
    - match: ''
      pop: true

  meta-class:
    - meta_scope: meta.class.d
    - match: ''
      pop: true

  meta-interface:
    - meta_scope: meta.interface.d
    - match: ''
      pop: true

  meta-struct:
    - meta_scope: meta.struct.d
    - match: ''
      pop: true

  meta-union:
    - meta_scope: meta.union.d
    - match: ''
      pop: true

  meta-enum:
    - meta_scope: meta.enum.d
    - match: ''
      pop: true
