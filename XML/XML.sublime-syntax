%YAML 1.2
---
name: XML
file_extensions:
  - xml
  - xsd
  - xslt
  - tld
  - dtml
  - rss
  - opml
  - svg
first_line_match: |-
    (?x)
    ^(?:
        <\?xml\s
     |  \s*<([\w-]+):Envelope\s+xmlns:\1\s*=\s*"http://schemas.xmlsoap.org/soap/envelope/"\s*>
     )
scope: text.xml
variables:
  # The atomic part of a tag or attribute name without namespace separator `:`
  identifier: '[[:alpha:]_][[:alnum:]_.-]*'
  # This is the full XML Name production, but should not be used where namespaces
  # are possible. Those locations should use a qualified_name.
  name: '[[:alpha:]:_][[:alnum:]:_.-]*'
  # This is the form that allows a namespace prefix (ns:) followed by a local
  # name. The captures are:
  #  1: namespace prefix name
  #  2: namespace prefix colon
  #  3: local tag name
  qualified_name: (?:({{identifier}})(:))?({{identifier}})
  # The qualified tag name allows a namespace prefix (ns:) followed by a local
  # name while both parts are validated separately. The namespace is optional,
  # but is matched valid if not followed by a localname in order to not disturb
  # writing.
  qualified_tag_name: |-
    (?x)
    (?:
      (?:
        ({{identifier}})           # 1: valid namespace
        |
        ([^?!/<>\s][^:/<>\s]*)     # 2: invalid namespace
      )(:)
    )?                             # namespace is optional
    (?:
      ({{identifier}})(?=[/<>\s])  # 3: valid localname
      |
      ([^?!/<>\s][^/<>\s]*)        # 4: invalid localname
    )

contexts:

  # prototype:
  #   # Inject consistent comment scopes for syntax test rules into
  #   # the XML syntax without interfering with existing features.
  #   #
  #   # NOTE
  #   #   Without this rule, some test cases will fail due to
  #   #   restricted syntax definitions of certain tags!
  #   #
  #   # CAUTION
  #   #   COMMENT THIS RULE OUT IN PRODUCTION BUILTS!
  #   - match: ^## *[<^]+.*
  #     scope: comment.line.double-dash.test-case.xml

  main:
    - include: preprocessor
    - include: doctype
    - include: comment
    - include: cdata
    - include: tag
    - include: entity
    - include: should-be-entity

###[ CDATA ]##################################################################

  cdata:
    - match: '<!\[CDATA\['
      scope: punctuation.definition.string.begin.xml
      push:
        - meta_scope: string.unquoted.cdata.xml
        - match: ']]>'
          scope: punctuation.definition.string.end.xml
          pop: true
    - match: ']]>'
      scope: invalid.illegal.missing-entity.xml

###[ COMMENT ]################################################################

  comment:
    - match: '<!--'
      scope: punctuation.definition.comment.begin.xml
      push:
        - meta_scope: comment.block.xml
        - match: '-->'
          scope: punctuation.definition.comment.end.xml
          pop: true
        - match: '-{2,}'
          scope: invalid.illegal.double-hyphen-within-comment.xml

###[ DOCTYPE DECLARATION ]####################################################

  doctype:
    # see: https://www.quackit.com/xml/tutorial/dtd_doctype.cfm
    - match: '(<!)(DOCTYPE)(?:\s+({{name}}))?'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.doctype.xml
        3: variable.documentroot.xml
      push:
        - meta_scope: meta.tag.sgml.doctype.xml
        - match: \s*(>)
          captures:
            1: punctuation.definition.tag.end.xml
          pop: true
        - include: internal-subset

  internal-subset:
    - match: \[
      scope: punctuation.definition.constant.xml
      push:
        - meta_scope: meta.internalsubset.xml
        - match: \]
          pop: true
        - include: comment
        - include: entity-decl
        - include: element-decl
        - include: attlist-decl
        - include: notation-decl
        - include: parameter-entity

  entity-decl:
    - match: '(<!)(ENTITY)\s+(%\s+)?({{name}})(\s+(?:SYSTEM|PUBLIC)\s+)?'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.entity.xml
        3: punctuation.definition.entity.xml
        4: variable.entity.xml
        5: keyword.entitytype.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: string-double-quoted
        - include: string-single-quoted

  element-decl:
    - match: '(<!)(ELEMENT)\s+({{name}})\s+'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.element.xml
        3: variable.element.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - match: '\b(EMPTY|ANY)\b'
          scope: constant.other.xml
        - include: element-parens

  element-parens:
    - match: \(
      scope: punctuation.definition.group.xml
      push:
        - match: (\))([*?+])?
          captures:
            1: punctuation.definition.group.xml
            2: keyword.operator.xml
          pop: true
        - match: '#PCDATA'
          scope: constant.other.xml
        - match: '[*?+]'
          scope: keyword.operator.xml
        - match: '[,|]'
          scope: punctuation.separator.xml
        - include: element-parens

  attlist-decl:
    - match: '(<!)(ATTLIST)\s+({{name}})\s+({{name}})'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.attlist.xml
        3: variable.element.xml
        4: variable.attribute-name.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: string-double-quoted
        - include: string-single-quoted

  notation-decl:
    - match: '(<!)(NOTATION)\s+({{name}})'
      captures:
        1: punctuation.definition.tag.begin.xml
        2: keyword.notation.xml
        3: variable.notation.xml
      push:
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: string-double-quoted
        - include: string-single-quoted

  parameter-entity:
    - match: '(%){{name}}(;)'
      scope: constant.character.entity.parameter.xml
      captures:
        1: punctuation.definition.entity.xml
        2: punctuation.terminator.entity.xml

###[ XML PREPROCESSOR ]#######################################################

  preprocessor:
    # Prolog tags like <?xml...?> without respect of details
    # Examples:
    #   <?xml version="1.0" ?>
    #   <?xml-model href='freb.xsl'?>
    #   <?xml-stylesheet type='text/xsl' href='freb.xsl'?>
    #   <?xml-third-party ... ?>
    - match: |-
        (?x)
        (<\?) # opening <? punctuation
        (?:
          # valid lowercase prolog tag name
          (xml(?:-[_a-z][-_a-z0-9]*)?)(?=[?<>\s])
          |
          # invalid mixed or uppercase tag name
          ([xX][mM][lL][^?<>\s]*)
        )
      captures:
        1: punctuation.definition.tag.begin.xml
        2: entity.name.tag.xml
        3: invalid.illegal.bad-tag-name.xml
      push:
        - meta_scope: meta.tag.preprocessor.xml
        - include: preprocessor-end
        - include: tag-attribute
    # Processing instructions like <?...?>
    # meta tag without internal highlighting
    - match: (<\?)({{name}})\b
      captures:
        1: punctuation.definition.tag.begin.xml
        2: entity.name.tag.xml
      push:
        - meta_scope: meta.tag.preprocessor.xml
        - include: preprocessor-end

  preprocessor-end:
    - match: \?>
      scope: punctuation.definition.tag.end.xml
      pop: true

###[ XML TAGS ]###############################################################

  tag:
    # end-tag without attribute support
    - match: (</){{qualified_tag_name}}
      captures:
        1: punctuation.definition.tag.begin.xml
        2: entity.name.tag.namespace.xml
        3: invalid.illegal.bad-tag-name.xml
        4: entity.name.tag.xml punctuation.separator.namespace.xml
        5: entity.name.tag.localname.xml
        6: invalid.illegal.bad-tag-name.xml
      push:
        - meta_scope: meta.tag.xml
        - match: '>'
          scope: punctuation.definition.tag.end.xml
          pop: true
        - match: '[/\?]>'
          scope: invalid.illegal.bad-tag-end.xml
          pop: true
        - match: \S
          scope: invalid.illegal.unexpected-attribute.xml
    # opening maybe self-closing tag with optional attributes
    - match: (<){{qualified_tag_name}}
      captures:
        1: punctuation.definition.tag.begin.xml
        2: entity.name.tag.namespace.xml
        3: invalid.illegal.bad-tag-name.xml
        4: entity.name.tag.xml punctuation.separator.namespace.xml
        5: entity.name.tag.localname.xml
        6: invalid.illegal.bad-tag-name.xml
      push:
        - meta_scope: meta.tag.xml
        - match: /?>
          scope: punctuation.definition.tag.end.xml
          pop: true
        - include: tag-attribute

  tag-attribute:
    - match: '(?:\s+|^){{qualified_name}}\s*(=)'
      captures:
        1: entity.other.attribute-name.namespace.xml
        2: entity.other.attribute-name.xml punctuation.separator.namespace.xml
        3: entity.other.attribute-name.localname.xml
        4: punctuation.separator.key-value.xml
    - match: '(?:\s+|^)([[:alnum:]:_.-]+)\s*(=)'
      captures:
        1: invalid.illegal.bad-attribute-name.xml
        2: punctuation.separator.key-value.xml
    - include: string-double-quoted
    - include: string-single-quoted

  entity:
    - match: (&#[xX])\h+(;)
      scope: constant.character.entity.hexadecimal.xml
      captures:
        1: punctuation.definition.entity.xml
        2: punctuation.terminator.entity.xml
    - match: (&#)[0-9]+(;)
      scope: constant.character.entity.decimal.xml
      captures:
        1: punctuation.definition.entity.xml
        2: punctuation.terminator.entity.xml
    - match: (&)[a-zA-Z0-9]+(;)
      scope: constant.character.entity.named.xml
      captures:
        1: punctuation.definition.entity.xml
        2: punctuation.terminator.entity.xml

  should-be-entity:
    - match: '&'
      scope: invalid.illegal.bad-ampersand.xml
    - match: '<'
      scope: invalid.illegal.missing-entity.xml

  string-double-quoted:
    - match: '"'
      scope: punctuation.definition.string.begin.xml
      push:
        - meta_scope: string.quoted.double.xml
        - match: '"'
          scope: punctuation.definition.string.end.xml
          pop: true
        - include: entity
        - include: should-be-entity

  string-single-quoted:
    - match: "'"
      scope: punctuation.definition.string.begin.xml
      push:
        - meta_scope: string.quoted.single.xml
        - match: "'"
          scope: punctuation.definition.string.end.xml
          pop: true
        - include: entity
        - include: should-be-entity

