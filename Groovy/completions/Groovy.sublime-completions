{
    "scope": "source.groovy",
    "completions":
    [
        { "trigger": "#!\t#!/usr/bin/env groovy -w", "contents": "#!/usr/bin/env groovy -w\n\n$0" },
        { "trigger": "all\tall { … }", "contents": "all {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "replace\treplace(dir: …, includes: …, token: …, value: …)", "contents": "replace(dir:\"${1:dirName}\", includes:\"${2:*.*}\", token:\"${3:tokenName}\", value:\"\\${${4:value}}\")$0" },
        { "trigger": "any\tany { … }", "contents": "any {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "as\tas BigDecimal", "contents": "as BigDecimal" },
        { "trigger": "as\tas BigInteger", "contents": "as BigInteger" },
        { "trigger": "as\tas Double", "contents": "as Double" },
        { "trigger": "as\tas Float", "contents": "as Float" },
        { "trigger": ".as\tasImmutable()", "contents": ".asImmutable()" },
        { "trigger": "as\tas Set", "contents": "as Set" },
        { "trigger": "as\tas String", "contents": "as String" },
        { "trigger": ".as\tasSynchronized()", "contents": ".asSynchronized()" },
        { "trigger": "as\tas Writable", "contents": "as Writable" },
        { "trigger": "!\tassert", "contents": "assert ${1:test}${2/(.+)/(?1: \\: \")/}${2:Failure message}${2/(.+)/(?1:\")/}$0" },
        { "trigger": "ase\tassertEquals", "contents": "assertEquals(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:expected}, ${3:actual})$0" },
        { "trigger": "asf\tassertFalse", "contents": "assertFalse(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:test})$0" },
        { "trigger": "asne\tassertNotEquals", "contents": "assertNotEquals(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:unexpected}, ${3:actual})$0" },
        { "trigger": "asnn\tassertNotNull", "contents": "assertNotNull(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:instance})$0" },
        { "trigger": "asn\tassertNull", "contents": "assertNull(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:instance})$0" },
        { "trigger": "ass\tassertSame", "contents": "assertSame(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:expected}, ${3:actual})$0" },
        { "trigger": "ast\tassertTrue", "contents": "assertTrue(${1/(.+)/(?1:\")/}${1:message}${1/(.+)/(?1:\", )/}${2:test})$0" },
        { "trigger": "doc\tDoc Block", "contents": "/**\n * $0\n */" },
        { "trigger": "case\tcase … break", "contents": "case ${1:CASE_NAME}:\n\t$2\nbreak$0" },
        { "trigger": "instance\tinstance … (Singleton)", "contents": "private static ${1:${TM_FILENAME/(.*?)(\\..+)/$1/}} instance\n\nstatic $1 getInstance(${2:args}) {\n\tif (!instance) instance = new $1(${2:args})\n\treturn instance\n}" },
        { "trigger": "cl\tclass { … }", "contents": "$1${1/(.+)/(?1: )/}class ${2:${TM_FILENAME/(.*?)(\\..+)/$1/}} ${3:extends ${4:Parent} }${5:implements ${6:Interface} }{\n\n\t$0\n\n}" },
        { "trigger": "tc\tclass … extends GroovyTestCase { … }", "contents": "class ${2:${TM_FILENAME/(.*?)(\\..+)/$1/}} extends GroovyTestCase {\n\n\t$0\n}" },
        { "trigger": "col\tcollect { … }", "contents": "collect {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "con\tconstructor() { … }", "contents": "${1:private}${1/(.+)/(?1: )/}${2:${TM_FILENAME/(.*?)(\\..+)/$1/}}(${3:args}) {\n\t$0\n}" },
        { "trigger": "copy\tcopy(file: …, tofile: …)", "contents": "copy(file:\"${1:sourceFile}\", tofile:\"${2:targetFile}\"" },
        { "trigger": "copy\tcopy(todir: …) { fileset(dir: …) { include … exclude }", "contents": "copy(todir:\"${1:targetDir}\") {\n\tfileset(dir:\"${2:sourceDir}\") {\n\t\tinclude(name:\"${3:includeName}\")\n\t\texclude(name:\"${4:excludeName}\")\n\t}\n}" },
        { "trigger": "copy\tcopy(todir: …) { fileset:dir …) }", "contents": "copy(todir:\"${1:targetDir}\") {\n\tfileset(dir:\"${2:sourceDir}\")\n}" },
        { "trigger": "cv\tclosure = { … }", "contents": "def ${1:closureName} = { ${2:args} ->\n\t$0\n}" },
        { "trigger": "m\tmethod() { … }", "contents": "${1:def} ${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "dt\tdownto() { … }", "contents": "downto(${1:0}) {${2/(.+)/(?1: )/}${2:i}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "ea\teach { … }", "contents": "each {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eab\teachByte { … }", "contents": "eachByte {${1/(.+)/(?1: )/}${1:byte}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "ead\teachDir { … }", "contents": "eachDir {${1/(.+)/(?1: )/}${1:dir}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eadm\teachDirMatch { … }", "contents": "eachDirMatch(${1:filter}) {${2/(.+)/(?1: )/}${2:dir}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eadr\teachDirRecurse { … }", "contents": "eachDirRecurse {${1/(.+)/(?1: )/}${1:dir}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eaf\teachFile { … }", "contents": "eachFile {${1/(.+)/(?1: )/}${1:file}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eafm\teachFileMatch { … }", "contents": "eachFileMatch(${1:filter}) {${2/(.+)/(?1: )/}${2:file}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eafr\teachFileRecurse { … }", "contents": "eachFileRecurse {${1/(.+)/(?1: )/}${1:file}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eak\teachKey { … }", "contents": "eachKey {${1/(.+)/(?1: )/}${1:key}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eal\teachLine { … }", "contents": "eachLine {${1/(.+)/(?1: )/}${1:line}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eam\teachMatch(regex) { … }", "contents": "eachMatch(/${1:regex}/) {${2/(.+)/(?1: )/}${2:match}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eao\teachObject { … }", "contents": "eachObject {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eav\teachValue { … }", "contents": "eachValue {${1/(.+)/(?1: )/}${1:value}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "eawi\teachWithIndex { … }", "contents": "eachWithIndex { ${1:obj}, ${2:i} ->\n\t$0\n}" },
        { "trigger": "el\telse", "contents": "else {\n\t$0\n}" },
        { "trigger": "elif\telse if", "contents": "else if (${1:condition}) {\n\t$0\n}" },
        { "trigger": "every\tevery { … }", "contents": "every {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "fm\tfinal method() { … }", "contents": "final ${1:void} ${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "fv\tfinal var", "contents": "final ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${4:null}}" },
        { "trigger": "find\tfind { … }", "contents": "find {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "finda\tfindAll { … }", "contents": "findAll {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "forin\tfor(… in …) { … }", "contents": "for(${1:element} in ${2:collection}) {\n\t$0\n}" },
        { "trigger": "grep\tgrep(filter) { … }", "contents": "grep(${1:filter}) {${2/(.+)/(?1: )/}${2:obj}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": ":\tkey: \"value\" (Hash Pair)", "contents": "${1:key}: ${2:\"${3:value}\"}" },
        { "trigger": "ifel\tif … else", "contents": "if(${1:condition}) {\n\t$2\n} else {\n\t$3\n}" },
        { "trigger": "if\tif", "contents": "if (${1:condition}) {\n\t$0\n}" },
        { "trigger": "im\timport", "contents": "import $0" },
        { "trigger": "mkdir\tmkdir(dir: …)", "contents": "mkdir(dir:\"${1:dirName}\")" },
        { "trigger": "File\tnew File(…).eachLine { … }", "contents": "new File(${1:\"${2:path/to/file}\"}).eachLine {${3/(.+)/(?1: )/}${3:line}${3/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "pa\tpackage", "contents": "package $0" },
        { "trigger": "p\tprint", "contents": "print $0" },
        { "trigger": "pl\tprintln", "contents": "println $0" },
        { "trigger": "pfm\tprivate final method() { … }", "contents": "final ${1:def} ${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "pfv\tprivate final var", "contents": "private final ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${4:null}}$0" },
        { "trigger": "pm\tprivate method() { … }", "contents": "private ${1:void}${1/(.+)/(?1: )/}${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "psfm\tprivate static final method() { … }", "contents": "private static final ${1:void}${1/(.+)/(?1: )/}${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "psfv\tprivate static final var", "contents": "private static final ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${4:null}}$0" },
        { "trigger": "psm\tprivate static method() { … }", "contents": "private static ${1:void}${1/(.+)/(?1: )/}${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "psv\tprivate static var", "contents": "private static ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${4:null}}$0" },
        { "trigger": "pv\tprivate var", "contents": "private ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${0:null}}" },
        { "trigger": "replace\treplaceAll(regex) { … }", "contents": "replaceAll(/${1:regex}/) {${2/(.+)/(?1: )/}${2:match}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "rea\treverseEach { … }", "contents": "reverseEach {${1/(.+)/(?1: )/}${1:obj}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "runa\trunAfter() { … }", "contents": "runAfter(${1:delay}) {\n\t$0\n}" },
        { "trigger": "setup\tsetUp() { … }", "contents": "void setUp() {\n\t$0\n}" },
        { "trigger": "sf\tshouldFail { … }", "contents": "shouldFail${1/(.+)/(?1:\\()/}${1:Exception}${1/(.+)/(?1:\\))/} {\n\t$0\n}" },
        { "trigger": "sleep\tsleep(secs) { … // on interrupt do }", "contents": "sleep(${1:secs}) {\n\t${2:// on interrupt do}\n}" },
        { "trigger": "sleep\tsleep(secs)", "contents": "sleep(${1:secs})" },
        { "trigger": "sort\tsort { … }", "contents": "sort {\n\t$0\n}" },
        { "trigger": "sel\tsplitEachLine(separator) { … }", "contents": "splitEachLine(${1:separator}) {${2/(.+)/(?1: )/}${2:obj}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "sfm\tstatic final method() { … }", "contents": "static final ${1:void}${1/(.+)/(?1: )/}${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "sfv\tstatic final var", "contents": "static final ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${4:null}}$0" },
        { "trigger": "main\tstatic main() { … }", "contents": "static main(args) {\n\t$0\n}" },
        { "trigger": "sm\tstatic method() { … }", "contents": "static ${1:void}${1/(.+)/(?1: )/}${2:methodName}(${3:args}) {\n\t$0\n}" },
        { "trigger": "sv\tstatic var", "contents": "static ${1:String}${1/(.+)/(?1: )/}${2:var}${3: = ${0:null}}" },
        { "trigger": "step\tstep(to,amount) { … }", "contents": "step(${1:to}, ${2:amount}) {${3/(.+)/(?1: )/}${3:i}${3/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "switch\tswitch … case", "contents": "switch(${1:value}) {\n\tcase ${2:CASE}:\n\t\t$3\n\tbreak$0\n}" },
        { "trigger": "switch\tswitch … case … default", "contents": "switch(${1:value}) {\n\tcase ${3:CASE}:\n\t\t$4\n\tbreak$0\n\tdefault:\n\t\t$2\n\tbreak\n}" },
        { "trigger": "tear\ttearDown() { … }", "contents": "void tearDown() {\n\t$0\n}" },
        { "trigger": "t\ttest()", "contents": "void test$1() {\n\t$0\n}" },
        { "trigger": "thread\tThread.start { … }", "contents": "Thread.start {\n\t$0\n}" },
        { "trigger": "thread\tThread.startDaemon { … }", "contents": "Thread.startDaemon {\n\t$0\n}" },
        { "trigger": "times\ttimes { … }", "contents": "times {${1/(.+)/(?1: )/}${1:i}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "to\tto Array", "contents": "toArray()" },
        { "trigger": "to\tto BigDecimal", "contents": "toBigDecimal()" },
        { "trigger": "to\tto BigInteger", "contents": "toBigInteger()" },
        { "trigger": "to\tto Boolean", "contents": "toBoolean()" },
        { "trigger": "to\tto Character", "contents": "toCharacter()" },
        { "trigger": "to\tto Double", "contents": "toDouble()" },
        { "trigger": "to\tto Float", "contents": "toFloat()" },
        { "trigger": "to\tto Integer", "contents": "toInteger()" },
        { "trigger": "to\tto List", "contents": "toList()" },
        { "trigger": "to\tto String", "contents": "toString()" },
        { "trigger": "to\tto URI", "contents": "toURI()" },
        { "trigger": "to\tto URL", "contents": "toURL()" },
        { "trigger": "try\ttry … catch … finally", "contents": "try {\n\t$0\n}\ncatch(${1:Exception} e) {\n\t$2\n}\nfinally {\n\t$3\n}" },
        { "trigger": "try\ttry … catch", "contents": "try {\n\t$0\n}\ncatch(${1:Exception} e) {\n\t$2\n}" },
        { "trigger": "ut\tupto() { … }", "contents": "upto(${1:0}) {${2/(.+)/(?1: )/}${2:i}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "v\tvar", "contents": "${1:def} ${2:var}${3: = ${0:null}}" },
        { "trigger": "while\twhile() { … }", "contents": "while(${1:condition}) {\n\t$0\n}" },
        { "trigger": "with\twithInputStream { … }", "contents": "withInputStream {${1/(.+)/(?1: )/}${1:in}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithOutputStream { … }", "contents": "withOutputStream {${1/(.+)/(?1: )/}${1:out}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithPrintWriter { … }", "contents": "withPrintWriter {${1/(.+)/(?1: )/}${1:writer}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithReader { … }", "contents": "withReader {${1/(.+)/(?1: )/}${1:reader}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithStream { … }", "contents": "withStream {${1/(.+)/(?1: )/}${1:stream}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithStreams { … }", "contents": "withStreams {${1/(.+)/(?1: )/}${1:socket}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithWriter(charset) { … }", "contents": "withWriter(${1:charset}) {${2/(.+)/(?1: )/}${2:writer}${2/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithWriter { … }", "contents": "withWriter {${1/(.+)/(?1: )/}${1:writer}${1/(.+)/(?1: ->)/}\n\t$0\n}" },
        { "trigger": "with\twithWriterAppend(charset) { … }", "contents": "withWriterAppend(${1:charset}) {${2/(.+)/(?1: )/}${2:writer}${2/(.+)/(?1: ->)/}\n\t$0\n}" }
    ]
}
