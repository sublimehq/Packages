{
    "scope": "source.ruby",
    "completions":
    [
        { "trigger": "rb\t#!/usr/bin/env ruby -wKU", "contents": "#!/usr/bin/env ruby${TM_RUBY_SWITCHES: -wKU}" },
        { "trigger": "ife\tif … else … end", "contents": "if ${1:condition}\n\t$2\nelse\n\t$3\nend" },
        { "trigger": "if\tif … end", "contents": "if ${1:condition}\n\t$0\nend" },
        { "trigger": "case\tcase … end", "contents": "case ${1:object}\nwhen ${2:condition}\n\t$0\nend" },
        { "trigger": "#\tAdd ‘# =>’ Marker", "contents": "# => $0" },
        { "trigger": "am\talias_method …", "contents": "alias_method :${1:new_name}, :${0:old_name}" },
        { "trigger": "all\tall? { |e| … }", "contents": "all? { |${1:e}| $0 }" },
        { "trigger": "any\tany? { |e| … }", "contents": "any? { |${1:e}| $0 }" },
        { "trigger": "app\tapplication { … }", "contents": "if __FILE__ == \\$PROGRAM_NAME\n\t$0\nend" },
        { "trigger": "Array\tArray.new(10) { |i| … }", "contents": "Array.new(${1:10}) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:i}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "as\tassert(…)", "contents": "assert(${1:test}, \"${0:Failure message.}\")" },
        { "trigger": "ase\tassert_equal(…)", "contents": "assert_equal(${1:expected}, ${0:actual})" },
        { "trigger": "asid\tassert_in_delta(…)", "contents": "assert_in_delta(${1:expected_float}, ${2:actual_float}, ${0:2 ** -20})" },
        { "trigger": "asio\tassert_instance_of(…)", "contents": "assert_instance_of(${1:ExpectedClass}, ${0:actual_instance})" },
        { "trigger": "asko\tassert_kind_of(…)", "contents": "assert_kind_of(${1:ExpectedKind}, ${0:actual_instance})" },
        { "trigger": "asm\tassert_match(…)", "contents": "assert_match(/${1:expected_pattern}/, ${0:actual_string})" },
        { "trigger": "asn\tassert_nil(…)", "contents": "assert_nil(${0:instance})" },
        { "trigger": "asnm\tassert_no_match(…)", "contents": "assert_no_match(/${1:unexpected_pattern}/, ${0:actual_string})" },
        { "trigger": "asne\tassert_not_equal(…)", "contents": "assert_not_equal(${1:unexpected}, ${0:actual})" },
        { "trigger": "asnn\tassert_not_nil(…)", "contents": "assert_not_nil(${0:instance})" },
        { "trigger": "asns\tassert_not_same(…)", "contents": "assert_not_same(${1:unexpected}, ${0:actual})" },
        { "trigger": "asnr\tassert_nothing_raised(…) { … }", "contents": "assert_nothing_raised(${1:Exception}) { $0 }" },
        { "trigger": "asnt\tassert_nothing_thrown { … }", "contents": "assert_nothing_thrown { $0 }" },
        { "trigger": "aso\tassert_operator(…)", "contents": "assert_operator(${1:left}, :${2:operator}, ${0:right})" },
        { "trigger": "asr\tassert_raise(…) { … }", "contents": "assert_raise(${1:Exception}) { $0 }" },
        { "trigger": "asrt\tassert_respond_to(…)", "contents": "assert_respond_to(${1:object}, :${0:method})" },
        { "trigger": "ass\tassert_same(…)", "contents": "assert_same(${1:expected}, ${0:actual})" },
        { "trigger": "ass\tassert_send(…)", "contents": "assert_send([${1:object}, :${2:message}, ${0:args}])" },
        { "trigger": "ast\tassert_throws(…) { … }", "contents": "assert_throws(:${1:expected}) { $0 }" },
        { "trigger": "rw\tattr_accessor …", "contents": "attr_accessor :${0:attr_names}" },
        { "trigger": "r\tattr_reader …", "contents": "attr_reader :${0:attr_names}" },
        { "trigger": "w\tattr_writer …", "contents": "attr_writer :${0:attr_names}" },
        { "trigger": "bm-\tBenchmark.bmbm do … end", "contents": "TESTS = ${1:10_000}\nBenchmark.bmbm do |results|\n\t$0\nend" },
        { "trigger": "cla-\tclass … < DelegateClass … initialize … end", "contents": "class ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}} < DelegateClass(${2:ParentClass})\n\tdef initialize${3/(^.*?\\S.*)|.*/(?1:\\()/}${3:args}${3/(^.*?\\S.*)|.*/(?1:\\))/}\n\t\tsuper(${4:del_obj})\n\n\t\t$0\n\tend\nend" },
        { "trigger": "cla\tclass … end", "contents": "class ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}}\n\t$0\nend" },
        { "trigger": "cla\tclass … initialize … end", "contents": "class ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}}\n\tdef initialize${2/(^.*?\\S.*)|.*/(?1:\\()/}${2:args}${2/(^.*?\\S.*)|.*/(?1:\\))/}\n\t\t$0\n\tend\nend" },
        { "trigger": "cla\tclass BlankSlate … initialize … end", "contents": "class ${1:BlankSlate}\n\tinstance_methods.each { |meth| undef_method(meth) unless meth =~ /\\A__/ }\n\n\tdef initialize${2/(^.*?\\S.*)|.*/(?1:\\()/}${2:args}${2/(^.*?\\S.*)|.*/(?1:\\))/}\n\t\t@${3:delegate} = ${4:delegate_object}\n\n\t\t$0\n\tend\n\n\tdef method_missing(meth, *args, &block)\n\t\t@${3:delegate}.send(meth, *args, &block)\n\tend\n\nend" },
        { "trigger": "cla\tclass … < ParentClass … initialize … end", "contents": "class ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}} < ${2:ParentClass}\n\tdef initialize${3/(^.*?\\S.*)|.*/(?1:\\()/}${3:args}${3/(^.*?\\S.*)|.*/(?1:\\))/}\n\t\t$0\n\tend\n\n\nend" },
        { "trigger": "cla\tClassName = Struct … do … end", "contents": "${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}} = Struct.new(:${2:attr_names}) do\n\tdef ${3:method_name}\n\t\t$0\n\tend\n\nend" },
        { "trigger": "tc\tclass … < Test::Unit::TestCase … end", "contents": "require \"test/unit\"\n\nrequire \"${1:library_file_name}\"\n\nclass Test${2:${1/([\\w&&[^_]]+)|./\\u$1/g}} < Test::Unit::TestCase\n\tdef test_${3:case_name}\n\t\t$0\n\tend\nend" },
        { "trigger": "cla\tclass << self … end", "contents": "class << ${1:self}\n\t$0\nend" },
        { "trigger": "clafn\tclass_from_name()", "contents": "split(\"::\").inject(Object) { |par, const| par.const_get(const) }" },
        { "trigger": "cl\tclassify { |e| … }", "contents": "classify { |${1:e}| $0 }" },
        { "trigger": "col\tcollect { |e| … }", "contents": "collect { |${1:e}| $0 }" },
        { "trigger": "deec\tdeep_copy(…)", "contents": "Marshal.load(Marshal.dump(${0:obj_to_copy}))" },
        { "trigger": "def\tdef … end", "contents": "def ${1:method_name}\n\t$0\nend" },
        { "trigger": "defmm\tdef method_missing … end", "contents": "def method_missing(meth, *args, &blk)\n\t$0\nend" },
        { "trigger": "defs\tdef self … end", "contents": "def self.${1:class_method_name}\n\t$0\nend" },
        { "trigger": "deft\tdef test_ … end", "contents": "def test_${1:case_name}\n\t$0\nend" },
        { "trigger": "defd\tdef_delegator …", "contents": "def_delegator :${1:@del_obj}, :${2:del_meth}, :${3:new_name}" },
        { "trigger": "defds\tdef_delegators …", "contents": "def_delegators :${1:@del_obj}, :${0:del_methods}" },
        { "trigger": "deli\tdelete_if { |e| … }", "contents": "delete_if { |${1:e}| $0 }" },
        { "trigger": "det\tdetect { |e| … }", "contents": "detect { |${1:e}| $0 }" },
        { "trigger": "Dir\tDir.glob(\"…\") { |file| … }", "contents": "Dir.glob(${1:\"${2:dir/glob/*}\"}) { |${3:file}| $0 }" },
        { "trigger": "Dir\tDir[\"…\"]", "contents": "Dir[${1:\"${2:glob/**/*.rb}\"}]" },
        { "trigger": "dir\tdirectory()", "contents": "File.dirname(__FILE__)" },
        { "trigger": "dob\tInsert do |variable| … end", "contents": "do${1/(^.+$)|^$/(?1: |)/}${1:variable}${1/(^.+$)|^$/(?1:|)/}\n\t$0\nend" },
        { "trigger": "dow\tdownto(0) { |n| … }", "contents": "downto(${1:0}) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:n}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "ea\teach { |e| … }", "contents": "each { |${1:e}| $0 }" },
        { "trigger": "eab\teach_byte { |byte| … }", "contents": "each_byte { |${1:byte}| $0 }" },
        { "trigger": "eac-\teach_char { |chr| … }", "contents": "each_char { |${1:chr}| $0 }" },
        { "trigger": "eac-\teach_cons(…) { |group| … }", "contents": "each_cons(${1:2}) { |${2:group}| $0 }" },
        { "trigger": "eai\teach_index { |i| … }", "contents": "each_index { |${1:i}| $0 }" },
        { "trigger": "eak\teach_key { |key| … }", "contents": "each_key { |${1:key}| $0 }" },
        { "trigger": "eal\teach_line { |line| … }", "contents": "each_line$1 { |${2:line}| $0 }" },
        { "trigger": "eap\teach_pair { |name, val| … }", "contents": "each_pair { |${1:name}, ${2:val}| $0 }" },
        { "trigger": "eas-\teach_slice(…) { |group| … }", "contents": "each_slice(${1:2}) { |${2:group}| $0 }" },
        { "trigger": "eav\teach_value { |val| … }", "contents": "each_value { |${1:val}| $0 }" },
        { "trigger": "eawi\teach_with_index { |e, i| … }", "contents": "each_with_index { |${1:e}, ${2:i}| $0 }" },
        { "trigger": "elsif\telsif …", "contents": "elsif ${1:condition}\n\t$0" },
        { "trigger": "Forw-\textend Forwardable", "contents": "extend Forwardable" },
        { "trigger": "fet\tfetch(name) { |key| … }", "contents": "fetch(${1:name}) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:key}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "File\tFile.foreach (\"…\") { |line| … }", "contents": "File.foreach(${1:\"${2:path/to/file}\"}) { |${3:line}| $0 }" },
        { "trigger": "File\tFile.open(\"…\") { |file| … }", "contents": "File.open(${1:\"${2:path/to/file}\"}${3/(^[rwab+]+$)|.*/(?1:, \")/}${3:w}${3/(^[rwab+]+$)|.*/(?1:\")/}) { |${4:file}| $0 }" },
        { "trigger": "File\tFile.read(\"…\")", "contents": "File.read(${1:\"${2:path/to/file}\"})" },
        { "trigger": "fil\tfill(range) { |i| … }", "contents": "fill(${1:range}) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:i}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "fin\tfind { |e| … }", "contents": "find { |${1:e}| $0 }" },
        { "trigger": "fina\tfind_all { |e| … }", "contents": "find_all { |${1:e}| $0 }" },
        { "trigger": "flao\tflatten_once()", "contents": "inject(Array.new) { |${1:arr}, ${2:a}| ${1:arr}.push(*${2:a}) }" },
        { "trigger": "fl\tflunk(…)", "contents": "flunk(\"${0:Failure message.}\")" },
        { "trigger": "gre\tgrep(/pattern/) { |match| … }", "contents": "grep(${1:/${2:pattern}/}) { |${3:match}| $0 }" },
        { "trigger": "gsu\tgsub(/…/) { |match| … }", "contents": "gsub(/${1:pattern}/) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:match}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": ":\tHash Pair — :key => \"value\"", "contents": ":${1:key} => ${2:\"${3:value}\"}${4:, }" },
        { "trigger": "Hash\tHash.new { |hash, key| hash[key] = … }", "contents": "Hash.new { |${1:hash}, ${2:key}| ${1:hash}[${2:key}] = $0 }" },
        { "trigger": "Comp\tinclude Comparable …", "contents": "include Comparable\n\ndef <=>(other)\n\t$0\nend" },
        { "trigger": "Enum\tinclude Enumerable …", "contents": "include Enumerable\n\ndef each(&block)\n\t$0\nend" },
        { "trigger": "inj\tinject(init) { |mem, var| … }", "contents": "inject${1/.+/(/}${1:init}${1/.+/)/} { |${2:mem}, ${3:var}| $0 }" },
        { "trigger": "lam\tlambda { |args| … }", "contents": "lambda { ${1/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${1:args}${1/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "loo\tloop { … }", "contents": "loop { $0 }" },
        { "trigger": "map\tmap { |e| … }", "contents": "map { |${1:e}| $0 }" },
        { "trigger": "mapwi\tmap_with_index { |e, i| … }", "contents": "enum_with_index.map { |${1:e}, ${2:i}| $0 }" },
        { "trigger": "Md\tMarshal.dump(…, file)", "contents": "File.open(${1:\"${2:path/to/file}.dump\"}, \"wb\") { |${3:file}| Marshal.dump(${4:obj}, ${3:file}) }" },
        { "trigger": "Ml\tMarshal.load(obj)", "contents": "File.open(${1:\"${2:path/to/file}.dump\"}, \"rb\") { |${3:file}| Marshal.load(${3:file}) }" },
        { "trigger": "max\tmax { |a, b| … }", "contents": "max { |a, b| $0 }" },
        { "trigger": "min\tmin { |a, b| … }", "contents": "min { |a, b| $0 }" },
        { "trigger": "mod\tmodule … ClassMethods … end", "contents": "module ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}}\n\tmodule ClassMethods\n\t\t$0\n\tend\n\n\tmodule InstanceMethods\n\n\tend\n\n\tdef self.included(receiver)\n\treceiver.extend         ClassMethods\n\treceiver.send :include, InstanceMethods\n\tend\nend" },
        { "trigger": "mod\tmodule … end", "contents": "module ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}}\n\t$0\nend" },
        { "trigger": "mod\tmodule … module_function … end", "contents": "module ${1:${TM_FILENAME/(?:\\A|_)([A-Za-z0-9]+)(?:\\.rb)?/(?2::\\u$1)/g}}\n\tmodule_function\n\n\t$0\nend" },
        { "trigger": "nam\tnamespace :… do … end", "contents": "namespace :${1:${TM_FILENAME/\\.\\w+//}} do\n\t$0\nend" },
        { "trigger": "ope\topen(\"path/or/url\", \"w\") { |io| … }", "contents": "open(${1:\"${2:path/or/url/or/pipe}\"}${3/(^[rwab+]+$)|.*/(?1:, \")/}${3:w}${3/(^[rwab+]+$)|.*/(?1:\")/}) { |${4:io}| $0 }" },
        { "trigger": "{\tInsert { |variable| … }", "contents": "{ ${1/(^(?<var>\\s*[a-z_][a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${1:variable}${1/(^(?<var>\\s*[a-z_][a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}${2:$TM_SELECTED_TEXT}" },
        { "trigger": "optp\toption_parse { … }", "contents": "require \"optparse\"\n\noptions = {${1::default => \"args\"}}\n\nARGV.options do |opts|\n\topts.banner = \"Usage:  #{File.basename(\\$PROGRAM_NAME)} [OPTIONS]${2/^\\s*$|(.*\\S.*)/(?1: )/}${2:OTHER_ARGS}\"\n\n\topts.separator \"\"\n\topts.separator \"Specific Options:\"\n\n\t$0\n\n\topts.separator \"Common Options:\"\n\n\topts.on( \"-h\", \"--help\", \"Show this message.\" ) do\n\t\tputs opts\n\t\texit\n\tend\n\n\tbegin\n\t\topts.parse!\n\trescue\n\t\tputs opts\n\t\texit\n\tend\nend" },
        { "trigger": "par\tpartition { |e| … }", "contents": "partition { |${1:e}| $0 }" },
        { "trigger": "patfh\tpath_from_here( … )", "contents": "File.join(File.dirname(__FILE__), *%w[${1:rel path here}])" },
        { "trigger": "Pn-\tPStore.new( … )", "contents": "PStore.new(${1:\"${2:file_name.pstore}\"})" },
        { "trigger": "ran\trandomize()", "contents": "sort_by { rand }" },
        { "trigger": "=b\tNew Block", "contents": "`[[ $TM_LINE_INDEX != 0 ]] && echo; echo`=begin rdoc\n\t$0\n=end" },
        { "trigger": "rej\treject { |e| … }", "contents": "reject { |${1:e}| $0 }" },
        { "trigger": "req\trequire \"…\"", "contents": "require \"$0\"" },
        { "trigger": "ts\trequire \"tc_…\" …", "contents": "require \"test/unit\"\n\nrequire \"tc_${1:test_case_file}\"\nrequire \"tc_${2:test_case_file}\"" },
        { "trigger": "reqg-\trequire_gem \"…\"", "contents": "require \"$0\"" },
        { "trigger": "rep\tresults.report(…) { … }", "contents": "results.report(\"${1:name}:\") { TESTS.times { $0 } }" },
        { "trigger": "reve\treverse_each { |e| … }", "contents": "reverse_each { |${1:e}| $0 }" },
        { "trigger": "sca\tscan(/…/) { |match| … }", "contents": "scan(/${1:pattern}/) { |${2:match}| $0 }" },
        { "trigger": "sel\tselect { |e| … }", "contents": "select { |${1:e}| $0 }" },
        { "trigger": "sinc\tsingleton_class()", "contents": "class << self; self end" },
        { "trigger": "sor\tsort { |a, b| … }", "contents": "sort { |a, b| $0 }" },
        { "trigger": "sorb\tsort_by { |e| … }", "contents": "sort_by { |${1:e}| $0 }" },
        { "trigger": "ste\tstep(2) { |e| … }", "contents": "step(${1:2}) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:n}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "sub\tsub(/…/) { |match| … }", "contents": "sub(/${1:pattern}/) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:match}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "tas\ttask :task_name => [:dependent, :tasks] do … end", "contents": "desc \"${1:Task description}\"\ntask :${2:${3:task_name} => ${4:[:${5:dependent, :tasks}]}} do\n\t$0\nend" },
        { "trigger": "tim\ttimes { |n| … }", "contents": "times { ${1/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${1:n}${1/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "tra\ttransaction( … ) { … }", "contents": "transaction${1/(^.*?\\S.*)|.*/(?1:\\()/}${1:true}${1/(^.*?\\S.*)|.*/(?1:\\))/} { $0 }" },
        { "trigger": "unif\tunix_filter { … }", "contents": "ARGF.each_line$1 do |${2:line}|\n\t$0\nend" },
        { "trigger": "unless\tunless … end", "contents": "unless ${1:condition}\n\t$0\nend" },
        { "trigger": "until\tuntil … end", "contents": "until ${1:condition}\n\t$0\nend" },
        { "trigger": "opt\toption(…)", "contents": "opts.on( \"-${1:o}\", \"--${2:long-option-name}\"${3/^\\s*$|(.*\\S.*)/(?1:, )/}${3:String},\n\t\t\"${4:Option description.}\" ) do |${6:opt}|\n\t$0\nend" },
        { "trigger": "upt\tupto(1.0/0.0) { |n| … }", "contents": "upto(${1:1.0/0.0}) { ${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:|)/}${2:n}${2/(^(?<var>\\s*(?:\\*|\\*?[a-z_])[a-zA-Z0-9_]*\\s*)(,\\g<var>)*,?\\s*$)|.*/(?1:| )/}$0 }" },
        { "trigger": "usai\tusage_if()", "contents": "if ARGV.$1\n\tabort \"Usage:  #{\\$PROGRAM_NAME} ${2:ARGS_GO_HERE}\"\nend" },
        { "trigger": "usau\tusage_unless()", "contents": "unless ARGV.$1\n\tabort \"Usage:  #{\\$PROGRAM_NAME} ${2:ARGS_GO_HERE}\"\nend" },
        { "trigger": "when\twhen …", "contents": "when ${1:condition}\n\t$0" },
        { "trigger": "while\twhile … end", "contents": "while ${1:condition}\n\t$0\nend" },
        { "trigger": "begin\tbegin … rescue … end", "contents": "${TM_SELECTED_TEXT/([\\t ]*).*/$1/m}begin\n\t${3:${TM_SELECTED_TEXT/(\\A.*)|(.+)|\\n\\z/(?1:$0:(?2:\\t$0))/g}}\n${TM_SELECTED_TEXT/([\\t ]*).*/$1/m}rescue ${1:Exception}${2/.+/ => /}${2:e}\n${TM_SELECTED_TEXT/([\\t ]*).*/$1/m}\t$0\n${TM_SELECTED_TEXT/([\\t ]*).*/$1/m}end" },
        { "trigger": "xml-\txmlread(…)", "contents": "REXML::Document.new(File.read(${1:\"${2:path/to/file}\"}))" },
        { "trigger": "xpa\txpath(…) { … }", "contents": "elements.each(${1:\"${2://XPath}\"}) do |${3:node}|\n\t$0\nend" },
        { "trigger": "Yd-\tYAML.dump(…, file)", "contents": "File.open(${1:\"${2:path/to/file}.yaml\"}, \"w\") { |${3:file}| YAML.dump(${4:obj}, ${3:file}) }" },
        { "trigger": "Yl-\tYAML.load(file)", "contents": "File.open(${1:\"${2:path/to/file}.yaml\"}) { |${3:file}| YAML.load(${3:file}) }" },
        { "trigger": "y\t:yields:", "contents": " :yields: ${0:arguments}" },
        { "trigger": "zip\tzip(enums) { |row| … }", "contents": "zip(${1:enums}) { |${2:row}| $0 }" }
    ]
}
