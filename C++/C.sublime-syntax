%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: C
scope: source.c

file_extensions:
  - c
  - h

first_line_match: |-
  (?xi:
    ^ \s* // .*? -\*- .*? \bc\b(?![#+]) .*? -\*-  # editorconfig
  )

variables:
  identifier: \b[[:alpha:]_][[:alnum:]_]*\b
  likely_macro: \b[[:upper:]][[:upper:][:digit:]_]+\b

  bin_suffix: '[2-9a-zA-Z_][[:alnum:]_]*'
  oct_suffix: '[8-9g-zG-Z_][[:alnum:]_]*'
  dec_suffix: '[a-zA-Z_][[:alnum:]_]*'
  hex_suffix: '[g-zG-Z_][[:alnum:]_]*'
  double_suffix: '[fFlL]'
  float_suffix: '[fF]'
  integer_suffix: '(?:(?:ll|LL)(?!\s*[lL])|(?i)(?:u(?!\w*u)|l(?!\w*l)|i(?!\w*[ij])|j(?!\w*[ij])))+\b'
  dec_exponent: '(?:[eE][-+]?\d*)'
  hex_exponent: '(?:[pP][-+]?\d*)'

contexts:
  # Helpers

  pop-immediately:
    - match: ""
      pop: true
  else-pop:
    - match: (?=\S)
      pop: true

  # Basic Objects

  string.escape:
    - match: \\([abfnrtv\\'\"?]|[eE]|\d{1,3}|x[0-9A-Fa-f]+|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c
  string.format:
    - match: |-
        (?x)%
          (\d+\$)?                                      # field (argument #)
          [#0\- +']*                                    # flags
          [,;:_]?                                       # separator character (AltiVec)
          ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
          (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
          (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
          (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
      scope: constant.other.placeholder.c
  string:
    - match: (L|u8?|U)?(\")
      captures:
        1: storage.type.string.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.double.c
        - include: string.escape
        - include: string.format
        - match: \"
          scope: punctuation.definition.string.end.c
          pop: true
    - match: (L?)(\')
      captures:
        1: storage.type.string.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.double.c
        - include: string.escape
        - match: \'
          scope: punctuation.definition.string.end.c
          pop: true

  operator.assignment:
    - match: =
      scope: keyword.operator.assignment.c
    - match: \+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|>>=
      scope: keyword.operator.assignment.augmented.c
  operator.arithmetic:
    - match: \+|-|\*|/|%|!
      scope: keyword.operator.arithmetic.c
  operator.logical:
    - match: \&\&|\|\|
      scope: keyword.operator.logical.c
  operator.bitwise:
    - match: \&|\||\^|~|<<|>>|>>
      scope: keyword.operator.bitwise.c
  operator.comparison:
    - match: ==|!=|<=|>=|<|>
      scope: keyword.operator.comparison.c
  operator.word:
    - match: \bsizeof|_Alignof|alignof|offsetof\b
      scope: keyword.operator.word.c
  operator.ternary:
    - match: '\?|\:'
      scope: keyword.operator.ternary.c
  operator.variadic:
    - match: \.\.\.
      scope: keyword.operator.variadic.c
  operator.increment-decrement:
    - match: \+\+|--
      scope: keyword.operator.arithmetic.c
  operator.accessor:
    - match: \.|\-\>
      scope: punctuation.accessor.c
  operator.pointer:
    - match: \&|\*
      scope: keyword.operator.arithmetic.c
  operator:
    - include: operator.accessor
    - include: operator.assignment
    - include: operator.arithmetic
    - include: operator.logical
    - include: operator.bitwise
    - include: operator.comparison
    - include: operator.word
    - include: operator.ternary
    - include: operator.variadic
    - include: operator.increment-decrement

  punctuation.comma:
    - match: ','
      scope: punctuation.separator.c
  punctuation.semicolon:
    - match: ;
      scope: punctuation.terminator.c
  punctuation:
    - include: punctuation.comma
    - include: punctuation.semicolon

  number:
    # decimal floats
    - match: |-
        (?x:
          \b(\d+)
          (?:
            ( (\.)
              (?:
                # 1.1, 1.1e1, 1.1e-1, 1.1f, 1.1e1f, 1.1e-1f, 1.1L, 1.1e1L, 1.1e-1L
                \d+ {{dec_exponent}}?
                # 1.e1, 1.e-1, 1.e1f, 1.e-1f, 1.e1L, 1.e-1L
                | {{dec_exponent}}
                # 1., 1.f, 1.L # but not `..`
                | (?!\.)
              )
              # 1e1 1e1f 1e1L
              | {{dec_exponent}}
            ) ({{double_suffix}})?
            # 1f
            | ({{float_suffix}})
          ) ({{dec_suffix}})?
          # .1, .1e1, .1e-1, .1f, .1e1f, .1e-1f, .1L, .1e1L, .1e-1L
          | ( (\.) \d+ {{dec_exponent}}? ) (?: ({{double_suffix}}) | ({{dec_suffix}}) )?
        )
      scope: meta.number.float.decimal.c
      captures:
        1: constant.numeric.value.c
        2: constant.numeric.value.c
        3: punctuation.separator.decimal.c
        4: constant.numeric.suffix.c
        5: constant.numeric.suffix.c
        6: invalid.illegal.numeric.suffix.c
        7: constant.numeric.value.c
        8: punctuation.separator.decimal.c
        9: constant.numeric.suffix.c
        10: invalid.illegal.numeric.suffix.c
    # hexadecimal float
    - match: \b(0[xX])(\h*(\.)\h*{{hex_exponent}})(?:([fFlL]\b)|({{dec_suffix}}))?
      scope: meta.number.float.hexadecimal.c
      captures:
        1: constant.numeric.base.c
        2: constant.numeric.value.c
        3: punctuation.separator.decimal.c
        4: constant.numeric.suffix.c
        5: invalid.illegal.numeric.suffix.c
    # binary integer (C23)
    - match: \b(0[bB])([0-1]*)(?:({{integer_suffix}})|({{bin_suffix}}))?
      scope: meta.number.integer.binary.c
      captures:
        1: constant.numeric.base.c
        2: constant.numeric.value.c
        3: constant.numeric.suffix.c
        4: invalid.illegal.numeric.suffix.c
    # hexadecimal integer
    - match: \b(0[xX])(\h*)(?:({{integer_suffix}})|({{hex_suffix}}))?
      scope: meta.number.integer.hexadecimal.c
      captures:
        1: constant.numeric.base.c
        2: constant.numeric.value.c
        3: constant.numeric.suffix.c
        4: invalid.illegal.numeric.suffix.c
    # octal integer
    - match: \b(0)([0-7]+)(?:({{integer_suffix}})|({{oct_suffix}}))?
      scope: meta.number.integer.octal.c
      captures:
        1: constant.numeric.base.c
        2: constant.numeric.value.c
        3: constant.numeric.suffix.c
        4: invalid.illegal.numeric.suffix.c
    # decimal integer
    - match: \b(\d+)(?:({{integer_suffix}})|({{dec_suffix}}))?
      scope: meta.number.integer.decimal.c
      captures:
        1: constant.numeric.value.c
        2: constant.numeric.suffix.c
        3: invalid.illegal.numeric.suffix.c

  constant:
    - match: \b(true|TRUE)\b
      scope: constant.language.boolean.true.c
    - match: \b(false|FALSE)\b
      scope: constant.language.boolean.false.c
    - match: \bNULL\b
      scope: constant.language.null.c
    - match: \b__(func)__\b
      scope: constant.language.c
    - match: \b(__[a-zA-Z_]+__|__cplusplus)\b
      scope: support.constant.c
    - match: '\bk[A-Z]\w*\b'
      scope: constant.other.variable.mac-classic.c

  declspec:
    - meta_scope: meta.group.c
    - match: \b(allocator|appdomain|deprecated|dllimport|dllexport|empty_bases|hybrid_patchable|jitintrinsic|naked|noalias|noinline|noreturn|nothrow|novtable|no_sanitize_address|process|restrict|safebuffers|selectany|thread)\b
      scope: constant.other.c
    - match: \b(align|allocate|code_seg|spectre|uuid|deprecated)\s*(\()
      captures:
        1: storage.modifier.c
        2: punctuation.section.group.begin.c
      push: enclosure.parenthesis

    - match: \b(property)\s*(\()
      captures:
        1: storage.modifier.c
        2: punctuation.section.group.begin.c
      push:
        - match: \b(get|put)\b
          scope: variable.parameter.c
        - include: enclosure.parenthesis

    - include: expression
    - match: \)
      scope: punctuation.section.group.end.c
      pop: 2

  gnu-attribute:
    - meta_scope: meta.group.c meta.attribute.c
    # too many attributes, these are the ones commonly used
    - include: punctuation.comma
    - match: \b(noreturn|pure|const|malloc|cold|hot|deprecated|always_inline|noinline|packed|unused|used|leaf|artificial|flatten|noclone|returns_twice|weak|no_reorder|minsize|externally_visible|constructor|destructor)\b
      scope: constant.other.c
    - match: \b(aligned|format|nonnull|section|visibility|alias|ifunc|target|alloc_size|cleanup|warning|error|cold_hot_partitioning|no_sanitize|optimize)\s*(\()
      captures:
        1: storage.modifier.c
        2: punctuation.section.group.begin.c
      push: enclosure.parenthesis
    - match: \)\)
      scope: punctuation.section.group.end.c
      pop: 2

  keyword.storage:
    - match: \bauto\b
      scope: storage.type.c
    - match: \b(const|volatile|restrict|_Atomic|register|static|inline|extern|register|thread_local|_Thread_local|_Noreturn|noreturn|_Alignas)\b
      scope: storage.modifier.c

    - match: \b__declspec\b
      scope: storage.modifier.c
      push:
        - match: \(
          scope: punctuation.section.group.begin.c
          push: declspec
    # __attribute__ alone will already be storage.modifier.c from constant
    - match: \b(__attribute__)\s*(\(\()
      captures:
        1: storage.modifier.c
        2: punctuation.section.group.begin.c
      push: gnu-attribute
  keyword.declaration:
    - match: \b(struct|enum|union)\b
      scope: keyword.declaration.c
    - match: \btypedef\b
      scope: keyword.declaration.type.c
  keyword.control-flow:
    - match: \bcontinue\b
      scope: keyword.control.flow.continue.c
    - match: \bbreak\b
      scope: keyword.control.flow.break.c
    - match: \breturn\b
      scope: keyword.control.flow.return.c
    - match: \bgoto\b
      scope: keyword.control.flow.goto.c
  keyword.control:
    - match: \b(?:if|else|for|while|do|switch|case|default)\b
      scope: keyword.control.c
  keyword.asm:
    - match: \b(asm|__asm|__asm__)\b
      scope: keyword.control.import.c
  keyword.type:
    - match: \b(?:bool|void|char|short|int|long|float|double|signed|unsigned|_Complex|_Imaginary|_Bool)\b
      scope: storage.type.c
    - match: \b(u?intptr|u?intmax|ptrdiff|nullptr|max_align|size|u?int(_fast|_least)?(8|16|32|64))_t\b
      scope: support.type.stdint.c
    - match: \b(typeof_unqual|__typeof__|__typeof|typeof)\b
      scope: keyword.declaration.type.c
  keyword:
    - include: keyword.control-flow
    - include: keyword.control
    - include: keyword.storage
    - include: keyword.declaration
    - include: keyword.asm
    - include: keyword.type

  # More complicated structures

  enclosure.parenthesis:
    - meta_scope: meta.group.c
    - include: expression
    - match: \)
      scope: punctuation.section.group.end
      pop: 1
  enclosure.brackets:
    - meta_scope: meta.brackets.square.c
    - include: expression
    - match: \]
      scope: punctuation.section.brackets.end
      pop: 1
  enclosure.block:
    - meta_scope: meta.block.c
    - include: expression
    - match: \}
      scope: punctuation.section.block.end
      pop: 1
  enclosure:
    - match: \(
      scope: punctuation.section.group.begin
      push: enclosure.parenthesis
    - match: \[
      scope: punctuation.section.brackets.begin
      push: enclosure.brackets
    - match: \{
      scope: punctuation.section.block.begin
      push: enclosure.block

  type.enum-body:
    - meta_content_scope: meta.block.c
    - meta_include_prototype: false
    - match: \b{{identifier}}\b
      scope: entity.name.constant.c
      push:
        - match: (?=,|})
          pop: true
        - include: expression
    - include: punctuation.comma
    - match: \}
      scope: punctuation.section.block.end.c
      pop: 1
  type.enum:
    - meta_scope: meta.enum.c
    - include: expression.call
    - match: ({{identifier}})\s*(?=;)
      captures:
        1: entity.name.enum.forward-decl.c
      pop: true
    - match: (?:{{identifier}}\s*)*?({{identifier}})?\s*(?:{{likely_macro}}\s*)*(?=\{|$)
      captures:
        1: entity.name.enum.c
      set:
        - match: \{
          scope: meta.enum.c punctuation.section.block.begin.c
          set: type.enum-body
        - match: (?=\S)
          fail: enum
    - match: (?=\S)
      fail: enum
  type.struct:
    - meta_scope: meta.struct.c
    - include: expression.call
    - match: ({{identifier}})\s*(?=;)
      captures:
        1: entity.name.enum.forward-decl.c
      pop: true
    - match: (?:{{identifier}}\s*)*?({{identifier}})?\s*(?:{{likely_macro}}\s*)*(?=\{|$)
      captures:
        1: entity.name.struct.c
      set:
        - match: \{
          scope: meta.struct.c punctuation.section.block.begin.c
          set: enclosure.block
        - match: (?=\S)
          fail: struct
    - match: (?=\S)
      fail: struct
  type.union:
    - meta_scope: meta.union.c
    - include: expression.call
    - match: ({{identifier}})\s*(?=;)
      captures:
        1: entity.name.enum.forward-decl.c
      pop: true
    - match: (?:{{identifier}}\s*)*?({{identifier}})?\s*(?:{{likely_macro}}\s*)*(?=\{|$)
      captures:
        1: entity.name.union.c
      set:
        - match: \{
          scope: meta.union.c punctuation.section.block.begin.c
          set: enclosure.block
        - match: (?=\S)
          fail: union
    - match: (?=\S)
      fail: union
  type:
    - match: \benum\b
      scope: keyword.declaration.enum.c
      branch_point: enum
      branch: [type.enum, pop-immediately]
    - match: \bstruct\b
      scope: keyword.declaration.struct.c
      branch_point: struct
      branch: [type.struct, pop-immediately]
    - match: \bunion\b
      scope: keyword.declaration.union.c
      branch_point: union
      branch: [type.union, pop-immediately]

  generic.body:
    - match: ':'
      scope: keyword.operator.c
      push:
        - match: ({{identifier}})\s*(?=,|\))
          captures:
            1: variable.function.c
          pop: true
    - include: expression

  generic:
    - match: \b(_Generic)\s*(\()
      captures:
        1: keyword.declaration.c
        2: punctuation.section.group.begin.c
      push: generic.body

  # Expression objects

  expression-identifiers:
    - include: operator.word
    - include: type
    - include: keyword
    - include: constant

  expression.call:
    - match: \b({{identifier}})\s*(\()
      captures:
        1: variable.function.c
        2: punctuation.section.group.begin.c
      push: enclosure.parenthesis
  expression:
    - include: number
    - include: string
    - include: type
    - include: keyword
    - include: constant
    - include: operator
    - include: punctuation
    - include: generic
    - include: expression.call
    - include: enclosure

  function.label:
    - match: '({{identifier}})\s*(:)'
      captures:
        1: entity.name.label.c
        2: punctuation.separator.c
  function.body:
    - meta_scope: meta.function.c meta.block.c
    - match: \}
      scope: punctuation.section.block.end.c
      pop: true
    - include: expression
    - include: function.label
  function.tail:
    - meta_scope: meta.function.c
    - match: ;
      pop: true
    - match: \{
      scope: punctuation.section.block.begin
      set: function.body
    - include: expression
  function.params:
    - meta_content_scope: meta.function.parameters.c meta.group.c
    - match: \)
      scope: punctuation.section.group.end.c
      set: function.tail

    - match: ({{identifier}})(?=\[)
      captures:
        1: variable.parameter.c
      push:
        - match: (?=[,\)]|$)
          pop: true
        - include: enclosure

    - match: ({{identifier}})\b(?=[,\)]|$)
      captures:
        1: variable.parameter.c
    - include: expression
  function:
    - include: expression-identifiers
    - include: operator.pointer
    - match: ({{identifier}})\s*(\()
      captures:
        1: entity.name.function.c
        2: punctuation.section.group.begin.c
      push: function.params
    - match: \b{{identifier}}\b

  statement:
    - match: (?=\S)
      push:
        - match: ;
          scope: punctuation.terminator.c
          pop: true
        - include: expression

  main:
    - include: preprocessor
    - include: function
    - include: statement

  prototype:
    - include: preprocessor.comment
    - match: \\$
      scope: punctuation.separator.continuation.c
      push:
        - match: ^
          pop: true

  # Everything after this comment needs to be rewritten so don't pay too much mind

  preprocessor:
    - include: preprocessor.comment
    - match: ^\s*#\s*(?=(if|elif|endif|else|ifndef|ifdef|undef|include(_next)?|define|error|warning|pragma)\b)
      scope: keyword.control.import.c
      push: preprocessor.directive
  preprocessor.directive:
    - meta_scope: meta.preprocessor.c

    - match: \bifndef|ifdef|if|elif\b
      scope: keyword.control.import.c
      set:
        - match: ^
          pop: true

    - match: \belse|endif\b
      scope: keyword.control.import.c
      pop: true

    - match: \b(warning|error)\b
      scope: meta.preprocessor.diagnostic.c keyword.control.import.error.c
      set:
        - meta_content_scope: meta.preprocessor.diagnostic.c string.quoted.c
        - include: string
        - match: $
          pop: true

    - match: \binclude(_next)?\b
      scope: meta.preprocessor.include.c keyword.control.import.include.c
      set:
        - meta_content_scope: meta.preprocessor.include.c
        - match: <
          push:
            - meta_scope: string.quoted.c
            - match: ">"
              pop: true
        - match: \"
          push:
            - meta_scope: string.quoted.c
            - match: \"
              pop: true

        - match: ^
          pop: true

    - match: \bundef|pragma\b
      scope: keyword.control.import.c
      set:
        - meta_content_scope: meta.preprocessor.c
        - match: ^
          pop: true

    - match: \bdefine\b
      scope: keyword.control.import.c
      set:
        - match: ^
          pop: true
  preprocessor.comment:
    - match: /\*
      scope: punctuation.definition.comment.c
      push:
        - meta_scope: comment.block.c
        - match: '\\$\n'
          scope: punctuation.separator.continuation.c
        - match: \*/
          scope: punctuation.definition.comment.c
          pop: true
    - match: //
      scope: punctuation.definition.comment.c
      push:
        - meta_scope: comment.line.double-slash.c
        - match: '(\\)$\n'
          captures:
            1: punctuation.separator.continuation.c
          pop: true
        - match: (?=\n)
          pop: true

