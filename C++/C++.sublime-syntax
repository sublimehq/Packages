%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: C++
scope: source.c++
version: 2
extends: Packages/C++/C.sublime-syntax

file_extensions:
  - cpp
  - cc
  - cp
  - cxx
  - c++
  - C
  - h
  - hh
  - hpp
  - hxx
  - h++
  - inl
  - ipp
  - ixx
  - cppm

first_line_match: |-
  (?xi:
    ^ \s* // .*? -\*- .*? \b(c\+\+|cpp\b) .*? -\*-  # editorconfig
  )

contexts:
  function:
    - include: expression-identifiers
    - include: operator.pointer
    - match: ({{identifier}})\s*(\()
      captures:
        1: entity.name.function.c
        2: punctuation.section.group.begin.c
      push: [function.tail, function.params]
    - match: (?={{identifier}}\s*<)
      branch_point: try-template
      branch: [function.try-template, function.consume-ident]
    - match: \b{{identifier}}\b
  function.consume-ident:
    - match: \b{{identifier}}\b
    - include: pop-immediately
  function.try-template:
    - match: ({{identifier}})(?=\s*<)
      scope: entity.name.function.cpp
      set: function.try-template.body
  function.try-template.body:
        - include: template
        - match: \(
          scope: punctuation.section.group.begin.cpp
          push: [pop-twice, function.tail, function.params]
        - match: (?=\S)
          fail: try-template

  call:
    - meta_prepend: true
    - match: \b(?={{identifier}}\s*<)
      branch_point: template-call
      branch: [call.template-call, qualified-ident]
  call.template-call:
    - match: \b{{identifier}}\b
      scope: entity.name.function.cpp
      set: call.template-call.body
  call.template-call.body:
    - include: template
    - match: \(
      scope: punctuation.section.group.begin.cpp
      set: enclosure.parenthesis
    - match: (?=\S)
      fail: template-call
  call.multi-line:
    - meta_prepend: true
    - include: template

  expression-identifiers:
    - meta_append: true
    - include: punctuation.qualifier
    - include: template

  type:
    - meta_prepend: true
    - match: \bnamespace\b
      scope: keyword.declaration.namesace.cpp
      branch_point: namespace
      branch: [type.namespace, pop-immediately]
    - match: \b(using)\s+(namespace)\b
      captures:
        1: keyword.declaration.cpp
        2: keyword.declaration.cpp
      push: type.using-namespace
    - match: \busing\b
      scope: keyword.declaration.cpp
      push: type.using
    - match: \bclass\b
      scope: keyword.declaration.cpp
      push: class
  type.namespace:
    - meta_scope: meta.namespace.cpp
    - match: (?={{qualified}})
      push:
        - meta_scope: entity.name.namespace.cpp
        - include: qualified-ident
        - include: else-pop
    - match: \{
      scope: punctuation.section.block.begin.cpp
      push: [pop-twice, enclosure.block]
    - match: (?=\S)
      fail: namespace
  type.using:
    - meta_scope: meta.using.cpp
    - meta_content_scope: entity.name.using.cpp
    - match: (?={{qualified}})
      push: qualified-ident
    - include: else-pop
  type.using-namespace:
    - meta_scope: meta.using.cpp
    - meta_content_scope: entity.name.namespace.cpp
    - match: (?={{qualified}})
      push: qualified-ident
    - include: else-pop

  class:
    - match: ({{identifier}})(?=\s*;)
      scope: entity.name.class.forward-declare.cpp
      pop: 1
    - match: (?={{identifier}})
      set: [class.body-start, class.inherit, class.final, class.name, class.likely-macro]
  class.likely-macro:
    - match: '{{likely_macro}}'
    - include: else-pop
  class.name:
    - match: ({{identifier}})
      scope: entity.name.class.cpp
      set:
        - include: qualified-ident
        - include: else-pop
    - include: else-pop
  class.final:
    - match: \bfinal(?!\s*;)\b
      scope: storage.modifier.cpp
    - include: else-pop
  class.inherit:
    - match: ':'
      scope: punctuation.separator.inheritance.cpp
      push: class.inherit.body
    - include: else-pop
  class.inherit.body:
    - include: keyword.storage
    - include: punctuation.comma
    - match: (?={{qualified}})
      push:
        - meta_scope: entity.other.inherited-class.cpp
        - include: qualified-ident
    - include: else-pop
  class.body-start:
    - match: \{
      scope: punctuation.section.block.begin.cpp
      set: class.body
    - include: else-pop
  class.body:
    - meta_scope: meta.block.cpp meta.class.cpp
    - include: expression-identifiers
    - match: ({{identifier}})\s*(\()
      captures:
        1: entity.name.function.constructor.cpp
        2: punctuation.section.group.begin.c
      push: [constructor.tail, function.params]
    - match: (\~{{identifier}})\s*(\()
      captures:
        1: entity.name.function.destructor.cpp
        2: punctuation.section.group.begin.c
      push: [function.tail, function.params]
    - include: function
    - include: expression
    #- include: enclosure.block

  constructor.tail:
    - match: ':'
      scope: punctuation.separator.initializer-list.begin.cpp
      push: constructor.initializer-list
    - include: function.tail
  constructor.initializer-list:
    - meta_scope: meta.method.constructor.initializer-list.cpp
    - match: \b{{identifier}}\b
      scope: variable.other.readwrite.member.cpp
    - include: template
    - match: \(
      scope: punctuation.section.group.begin.c
      set: enclosure.parenthesis
    - include: else-pop

  qualified-ident:
    - match: (::)
      scope: punctuation.separator.qualifier.cpp
    - match: '{{identifier}}'
      push: qualified-ident.body
    - include: else-pop
  qualified-ident.body:
    - match: (::)
      scope: punctuation.separator.qualifier.cpp
      pop: 1
    - include: template
    - match: (?=\S)
      pop: 2

  template:
    - match: (?=<([^<]|$))
      branch_point: template
      branch: [try-template, template.fail]
  try-template:
    - meta_scope: meta.template.cpp
    - match: <
      scope: punctuation.definition.generic.begin.cpp
      set: try-template.body
  try-template.body:
    - match: (?=\)|\}|\]|\|\||;|\band\b|\bor\b)
      fail: template
    - match: (?=\&\&\s*[^>])
      fail: template
    - match: (>)
      scope: punctuation.definition.generic.end.cpp
      pop: true
    - include: expression
  template.fail:
    - match: <
      scope: keyword.operator.comparison.cpp
    - include: pop-immediately

  label:
    - match: '({{identifier}})\s*(:)(?!:)'
      captures:
        1: entity.name.label.c
        2: punctuation.separator.c

  keyword:
    - meta_append: true
    - match: \b(export|friend|operator|noexcept)\b
      scope: keyword.other.cpp
  keyword.type:
    - meta_prepend: true
    - match: \b(w?char(8|16|32)_t)|wchar_t\b
      scope: storage.type.cpp
    - match: decltype
      scope: keyword.declaration.type.cpp
  keyword.storage:
    - meta_prepend: true
    - match: '\b(private|protected|public):'
      scope: storage.modifier.cpp
    - match: \b(const(expr|eval|init)|explicit|mutable|private|protected|public|virtual)\b
      scope: storage.modifier.cpp
  keyword.control:
    - meta_prepend: true
    - match: '\b(catch)\s*(\()'
      captures:
        1: keyword.control.exception.cpp
        2: punctuation.section.group.begin.cpp
      push: function.params
    - match: \b(try|catch|finally|throw)\b
      scope: keyword.control.exception.cpp
    - match: \bco_(wait|yield|return)\b
      scope: keyword.control.cpp

  constant:
    - meta_prepend: true
    - match: \bthis\b
      scope: variable.language.cpp

  punctuation:
    - meta_prepend: true
    - include: punctuation.qualifier
  punctuation.qualifier:
    - match: (::)
      scope: punctuation.separator.qualifier.cpp

  keyword.operator: # needs precedence over the < comparison
    - meta_prepend: true
    - include: template
  operator.bitwise:
    - meta_append: true
    - match: \b(bit(and|or)|compl)\b
      scope: keyword.operator.bitwise.cpp
    - match: \bxor(_eq)\b
      scope: keyword.operator.bitwise.cpp
  operator.logical:
    - meta_append: true
    - match: \b(and|x?or|not)(_eq)?\b
      scope: keyword.operator.logical.cpp
  operator.word:
    - meta_prepend: true
    - match: \b((const|static|reinterpret|dynamic)_cast|static_assert|delete|new|typeid)\b
      scope: keyword.operator.word.cpp

  string:
    - meta_prepend: true
    - match: (R)(\")([^\s]*)(\()
      captures:
        1: storage.type.string.cpp
        2: punctuation.definition.string.begin.cpp
        3: constant.other.placeholder.cpp
        4: constant.other.placeholder.cpp
      push: string.raw
  string.raw:
    - meta_scope: string.quoted.raw.c
    - match: (\)\3)(\")
      captures:
        1: constant.other.placeholder.cpp
        2: punctuation.definition.string.end.cpp
      pop: true
variables:
  qualified: (?:::\s*)?(?:{{identifier}}(?:\s*:{0,2}\s*)?)+
