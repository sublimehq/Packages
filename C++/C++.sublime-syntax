%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: C++
scope: source.c++
version: 2
extends: Packages/C++/C.sublime-syntax

file_extensions:
  - cpp
  - cc
  - cp
  - cxx
  - c++
  - C
  - h
  - hh
  - hpp
  - hxx
  - h++
  - inl
  - ipp
  - ixx
  - cppm

first_line_match: |-
  (?xi:
    ^ \s* // .*? -\*- .*? \b(c\+\+|cpp\b) .*? -\*-  # editorconfig
  )

contexts:
  main:
    - meta_prepend: true
    - include: module
    - include: requires-fn

  function:
    - match: \b(operator)\s*([<>=+\-*/%&|^!]=?|[+\-&|<>]{2}|<<=|>>=|<=>|~|->\*?|\(\)|\[\])\s*(\()
      captures:
        1: keyword.operator.c++
        2: entity.name.function.c++
        3: meta.group.c++ punctuation.section.group.begin.c++
      push: [function.tail, function.params]

    - include: expression-identifiers
    - include: operator.pointer
    - match: (~?{{identifier}})\s*(\()
      captures:
        1: entity.name.function.c++
        2: meta.group.c++ punctuation.section.group.begin.c++
      push: [function.tail, function.params]
    - match: (?={{identifier}}\s*<)
      branch_point: try-template
      branch: [function.try-template, consume-ident]
    - match: \b{{identifier}}\b
  function.try-template:
    - match: ({{identifier}})(?=\s*<)
      scope: entity.name.function.c++
      set: function.try-template.body
  function.try-template.body:
        - include: template
        - match: \(
          scope: meta.group.c++ punctuation.section.group.begin.c++
          push: [pop-twice, function.tail, function.params]
        - match: (?=\S)
          fail: try-template

  function.params: # Add default parameters
    - meta_content_scope: meta.function.parameters.c meta.group.c++
    - match: \)
      scope: punctuation.section.group.end.c++
      pop: 1
    - match: \}|\] # Fallback
      scope: invalid.illegal.stray-bracket-end.c++
      pop: 2
    - match: ; # Fallback
      scope: invalid.illegal.unexpected-terminator.c++
      pop: 2

    - match: (?={{identifier}}\s*(?!\s*[\[,\)=]|$))
      push:
        - match: \b
          set: function.params.name
        - include: expression
    - include: expression
  function.params.name:
    - match: (?=[\]\}\);]) # Fallback
      pop: 1
    - include: expression-identifiers
    - match: ({{identifier}})\s*(\[)
      captures:
        1: variable.parameter.c++
        2: meta.brackets.square.c++ punctuation.section.brackets.begin.c++
      set: enclosure.brackets
    - match: ({{identifier}})\s*(?=[,\)=]|$)
      captures:
        1: variable.parameter.c++
      pop: 1
    - include: expression

  function.tail:
    - meta_prepend: true
    - match: \b(override|final|noexcept)\b
      scope: storage.modifier.c++
    - match: ':'
      scope: punctuation.separator.initializer-list.begin.c++
      push: constructor.initializer-list
    - match: \brequires\b
      scope: storage.modifier.c++
      push: function.tail.requires
    - match: \-\>
      scope: keyword.operator.arrow.c++
      push: function.tail.return
  function.tail.return:
    - meta_scope: meta.function.return-type.c++
    - match: (?=\brequires\b)
      pop: 1
    - match: (?={)
      pop: 1
    - include: expression
  function.tail.requires:
    - meta_scope: meta.function.requires.c++
    - match: (?={)
      pop: 1
    - include: expression
  constructor.initializer-list:
    - meta_scope: meta.method.constructor.initializer-list.c++
    - match: \b{{identifier}}\b
      scope: variable.other.readwrite.member.c++
      push: constructor.initializer-list.body
    - include: punctuation.comma
    - include: else-pop
  constructor.initializer-list.body:
    - include: template
    - match: \(
      scope: meta.group.c++ punctuation.section.group.begin.c++
      set: enclosure.parenthesis
    - match: \{
      scope: meta.block.c++ punctuation.section.block.begin.c++
      set: enclosure.block
    - include: else-pop

  call:
    - meta_prepend: true
    - match: \b(?={{identifier}}\s*<)
      branch_point: template-call
      branch: [call.template-call, qualified-ident]
    - match: (~{{identifier}})\s*(\()
      captures:
        1: variable.function.c
        2: punctuation.section.group.begin.c
      push: enclosure.parenthesis
  call.template-call:
    - match: \b{{identifier}}\b
      scope: entity.name.function.c++
      set: call.template-call.body
  call.template-call.body:
    - include: template
    - match: \(
      scope: meta.group.c++ punctuation.section.group.begin.c++
      set: enclosure.parenthesis
    - match: (?=\S)
      fail: template-call
  call.multi-line:
    - meta_prepend: true
    - include: template

  expression-identifiers:
    - meta_append: true
    - include: punctuation.qualifier
    - include: template
  expression:
    - meta_prepend: true
    - include: template
    - include: module
    - include: type
    - include: requires-fn
    - match: \+\s*(\[)
      captures:
        1: meta.brackets.square.c++ punctuation.section.brackets.begin.c++
      push: lambda

  module:
    - match: \bmodule\b
      scope: keyword.declaration.module.c++
      push: module.name
    - match: \b(import)\s*(?=<)
      scope: keyword.other.import.c++
      push: string.angled
    - match: \bimport\b
      scope: keyword.other.import.c++
      push: module.name
  module.name:
    - meta_content_scope: entity.name.module.c++
    - match: '{{identifier}}'
    - match: \.
      scope: punctuation.accessor.dot.c++
    - include: else-pop
  type:
    - meta_prepend: true
    - match: \bnamespace\b
      scope: keyword.declaration.namesace.c++
      branch_point: namespace
      branch: [type.namespace, pop-immediately]
    - match: \b(using)\s+(namespace)\b
      captures:
        1: keyword.declaration.c++
        2: keyword.declaration.c++
      push: type.using-namespace
    - match: \busing\b
      scope: keyword.declaration.c++
      push: type.using
    - match: \b(class|struct)\b
      scope: keyword.declaration.c++
      push: class
    - match: \btemplate\b
      scope: keyword.declaration.c++
      push: type.template
    - match: \bconcept\b
      scope: keyword.declaration.c++
      push: type.concept
  type.namespace:
    - meta_scope: meta.namespace.c++
    - match: (?={{qualified}})
      push:
        - meta_scope: entity.name.namespace.c++
        - include: qualified-ident
        - include: else-pop
    - match: \{
      scope: meta.block.c++ punctuation.section.block.begin.c++
      push: [pop-twice, enclosure.outer-block]
    - match: =
      scope: keyword.operator.assignment.c++
      pop: 1
    - match: (?=\S)
      fail: namespace
  type.using:
    - meta_scope: meta.using.c++
    - meta_content_scope: entity.name.using.c++
    - match: (?={{qualified}})
      push: qualified-ident
    - include: else-pop
  type.using-namespace:
    - meta_scope: meta.using.c++
    - meta_content_scope: entity.name.namespace.c++
    - match: (?={{qualified}})
      push: qualified-ident
    - include: else-pop
  type.template:
    - meta_scope: meta.template.c++
    - match: \<
      scope: punctuation.definition.generic.begin.c++
      push: [type.template.requires, type.template.body]
    - include: else-pop
  type.template.body:
    - match: \>
      scope: punctuation.section.generic.end.c++
      pop: 1
    - match: \}|\]|\) # Fallback
      scope: invalid.illegal.stray-bracket-end.c++
      pop: 2
    - match: ; # Fallback
      scope: invalid.illegal.unexpected-terminator.c++
      pop: 2
    - match: (?={{identifier}}\s*(?!\s*[,\>=]|$))
      push:
        - match: \b
          set: type.template.name
        - include: expression
    - match: \b(typename|class)\b
      scope: keyword.declaration.type.c++
    - include: expression
  type.template.requires:
    - match: \brequires\b
      scope: storage.modifier.c++
      pop: 1
    - include: else-pop
  type.template.name:
    - match: (?=[\]\}\);]) # Fallback
      pop: 1
    - match: \b(typename|class)\b
      scope: keyword.declaration.type.c++
    - include: expression-identifiers
    - match: ({{identifier}})\s*(\[)
      captures:
        1: variable.parameter.type.c++
        2: meta.brackets.square.c++ punctuation.section.brackets.begin.c++
      set: enclosure.brackets
    - match: ({{identifier}})\s*(?=[,\>=]|$)
      captures:
        1: variable.parameter.type.c++
      pop: 1
    - include: expression
  type.concept:
    - meta_scope: meta.concept.c++
    - match: '{{identifier}}'
      scope: entity.name.concept.c++
      push: type.concept.body
    - include: else-pop
  type.concept.body:
    - include: requires-fn
    - include: expression
    - match: (?=;|\)|\]|\})
      pop: 1

  enum-def:
    - match: \b(enum)(?:\s*(class))?\b
      captures:
        1: keyword.declaration.enum.c
        2: keyword.declaration.class.c++
      branch_point: enum
      branch: [type.enum, pop-immediately]


  requires-fn:
    - match: \b(requires)\s*(\()\b
      captures:
        1: keyword.operator.word.c++
        2: meta.group.c++ punctuation.section.group.begin.c++
      push: function.params

  enclosure:
    - meta_prepend: true
    - include: lambda-enclosure
  enclosure.brackets:
    - meta_prepend: true
    - match: (\])\s*(<)
      fail: lambda
    - match: (\])\s*(\()
      captures:
        1: punctuation.section.brackets.end.c++
        2: meta.group.c++ punctuation.section.group.begin.c++
      set: [lambda.try-not, enclosure.parenthesis]
  enclosure.outer-block:
    - meta_content_scope: meta.block.c++
    - match: \}
      scope: meta.block.c++ punctuation.section.block.end.c++
      pop: 1
    - include: main

  lambda-enclosure: # for ObjC++
    - match: \[
      branch_point: lambda
      scope: meta.brackets.square.c++ punctuation.section.brackets.begin.c++
      branch: [enclosure.brackets, lambda]

  lambda.try-not:
    - include: expression-identifiers
    - match: \-\>
      fail: lambda
    - match: \{
      fail: lambda
    - include: else-pop
  lambda:
    - meta_scope: meta.lambda.c++
    - match: '[&=](?=\s*[,\]])'
      scope: storage.modifier.capture.c++
    - match: (?=\S)
      set: [function.tail, function.params, lambda.template, lambda.captures]
  lambda.captures:
    - match: '{{identifier}}'
      scope: entity.other.lambda-capture.c++ variable.parameter.c++
    - match: \]
      scope: punctuation.section.brackets.end.c++
      pop: 1
    - match: (?=\=)
      push:
        - match: (?=[,\]])
          pop: 1
        - include: expression
    - include: expression
  lambda.template:
    - match: (?=\<)
      push: type.template
    - match: \(
      scope: meta.group.c++ punctuation.section.group.begin.c++
      pop: 1
    - include: expression-identifiers
    - match: \{
      push: function.body

  class:
    - match: ({{identifier}})(?=\s*;)
      scope: entity.name.class.forward-declare.c++
      pop: 1
    - match: (?={{identifier}}|:|\{)
      set: [class.body-start, class.inherit, class.final, class.likely-macro, class.name, class.likely-macro]
  class.likely-macro:
    - match: '{{likely_macro}}'
    - match: '({{identifier}})\s*(\()'
      captures:
        1: variable.function.c++
        2: meta.group.c++ punctuation.section.group.begin.c++
      push: enclosure.parenthesis
    - include: else-pop
  class.name:
    - include: punctuation.qualifier
    - match: (?={{identifier}})
      branch_point: class-name
      branch: [class.name.body, consume-ident]
    - include: else-pop
  class.name.body:
    - match: ({{identifier}})
      scope: entity.name.class.c++
      set:
        - include: template
        - match: (::)
          fail: class-name
        - match: (?=\S)
          pop: 2
    - match: (::)
      fail: class-name
    - include: else-pop
  class.final:
    - match: \bfinal(?!\s*;)\b
      scope: storage.modifier.c++
    - include: else-pop
  class.inherit:
    - match: ':'
      scope: punctuation.separator.inheritance.c++
      push: class.inherit.body
    - include: else-pop
  class.inherit.body:
    - include: keyword.storage
    - include: punctuation.comma
    - match: (?={{qualified}})
      push:
        - meta_scope: entity.other.inherited-class.c++
        - include: qualified-ident
    - include: else-pop
  class.body-start:
    - meta_scope: meta.class.c++
    - match: \{
      scope: meta.block.c++ punctuation.section.block.begin.c++
      set: class.body
    - include: else-pop
  class.body:
    - meta_scope: meta.block.c++ meta.class.c++
    - include: enclosure.outer-block

  qualified-ident:
    - match: \btypename\b
      scope: storage.modifier.c++
    - match: (::)
      scope: punctuation.accessor.double-colon.c++
    - match: '{{identifier}}'
      push: qualified-ident.body
    - include: else-pop
  qualified-ident.body:
    - match: (::)
      scope: punctuation.accessor.double-colon.c++
      pop: 1
    - include: template
    - match: (?=\S)
      pop: 2

  template:
    - match: (?=<([^<=]|$))
      branch_point: template
      branch: [try-template, template.fail]
  try-template:
    - meta_scope: meta.template.c++
    - match: <
      scope: punctuation.definition.generic.begin.c++
      set: try-template.body
  try-template.body:
    - match: (?=\)|\}|\]|\|\||;|\band\b|\bor\b)
      fail: template
    - match: (?=\&\&\s*[^>])
      fail: template
    - match: (>)
      scope: punctuation.definition.generic.end.c++
      pop: true
    - include: expression
  template.fail:
    - match: <
      scope: keyword.operator.comparison.c++
    - include: pop-immediately

  label:
    - match: '({{identifier}})\s*(:)(?!:)'
      captures:
        1: entity.name.label.c++
        2: punctuation.separator.c++

  dot-access.body:
    - meta_prepend: true
    - match: \<
      fail: dot-access

  keyword:
    - meta_append: true
    - match: \b(export|friend|operator|import)\b
      scope: keyword.other.c++
  keyword.type:
    - meta_prepend: true
    - match: \b(w?char(8|16|32)_t)|wchar_t\b
      scope: storage.type.c++
    - match: decltype
      scope: keyword.declaration.type.c++
  keyword.storage:
    - meta_prepend: true
    - match: '\b(private|protected|public)\s*:'
      scope: storage.modifier.c++
    - match: \b(const(expr|eval|init)|explicit|mutable|private|protected|public|virtual|typename|alignas)\b
      scope: storage.modifier.c++
  keyword.control:
    - meta_prepend: true
    - match: '\b(catch)\s*(\()'
      captures:
        1: keyword.control.exception.c++
        2: meta.group.c++ punctuation.section.group.begin.c++
      push: function.params
    - match: \b(try|catch|finally|throw)\b
      scope: keyword.control.exception.c++
    - match: \bco_(wait|yield|return)\b
      scope: keyword.control.c++

  constant:
    - meta_prepend: true
    - match: \bthis\b
      scope: variable.language.c++
    - match: \bm_[[:alpha:]_$][[:alnum:]_$]*\b
      scope: variable.other.readwrite.member.c++

  punctuation:
    - meta_prepend: true
    - include: punctuation.qualifier
  punctuation.qualifier:
    - match: (::)
      scope: punctuation.accessor.double-colon.c++

  keyword.operator: # needs precedence over the < comparison
    - meta_prepend: true
    - include: template
  operator.bitwise:
    - match: \&|\||\^|~(?!{{identifier}}\s*\()|<<|>>
      scope: keyword.operator.bitwise.c
    - match: \b(bit(and|or)|compl)\b
      scope: keyword.operator.bitwise.c++
    - match: \bxor(_eq)\b
      scope: keyword.operator.bitwise.c++
  operator.logical:
    - meta_append: true
    - match: \b(and|x?or|not)(_eq)?\b
      scope: keyword.operator.logical.c++
  operator.word:
    - meta_prepend: true
    - match: \b((const|static|reinterpret|dynamic)_cast|static_assert|delete|new|typeid|noexcept|requires)\b
      scope: keyword.operator.word.c++
  operator.comparison:
    - meta_prepend: true
    - match: <=>
      scope: keyword.operator.comparison.c++

  string:
    - meta_prepend: true
    - match: (R)(\")([^\s]*)(\()
      captures:
        1: storage.type.string.c++
        2: punctuation.definition.string.begin.c++
        3: constant.other.placeholder.c++
        4: constant.other.placeholder.c++
      push: string.raw
  string.raw:
    - meta_scope: string.quoted.raw.c++
    - match: (\)\3)(\")
      captures:
        1: constant.other.placeholder.c++
        2: punctuation.definition.string.end.c++
      pop: true

  consume-ident:
    - match: \b{{identifier}}\b
    - include: pop-immediately
variables:
  identifier: (?:\b|(?=\$))[[:alpha:]_$][[:alnum:]_$]*(?:\b|\$)
  qualified: (?:::\s*)?(?:{{identifier}}(?:\s*:{0,2}\s*)?)+
