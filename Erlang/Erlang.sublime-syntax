%YAML 1.2
---
# https://www.erlang.org/doc/reference_manual
# https://www.sublimetext.com/docs/syntax.html
name: Erlang
scope: source.erlang
version: 2

file_extensions:
  - erl
  - hrl
  - escript

hidden_file_extensions:
  - Emakefile

first_line_match: |-
  (?xi:
    ^ \#! .* \b(erlang|escript)\b               # shebang
  | ^ \s* \%+ .*? -\*- .*? \berlang\b .*? -\*-  # editorconfig
  )

###############################################################################

variables:
  # https://www.erlang.org/doc/reference_manual/data_types.html#atom
  # an atom starts with lowercase alphanumeric
  atom_unquoted: '[a-z]{{ident_char}}*'

  # https://www.erlang.org/doc/reference_manual/expressions.html#variables
  # a variable starts with uppercase alphanumeric or underscore
  variable: '[_A-Z]{{ident_char}}*'

  # an identifier can contain lowercase, uppercase, digits, underscore and @
  ident_char: '[_A-Za-z\d@]'
  # the character which identifies the end of an identifier
  # Note: need the character as embedded positvie lookaheads don't work
  ident_break_char: '[^{{ident_char}}]'
  # end of identifier lookahead
  # Note: avoid negative lookahead as it is 6-8% slower
  ident_break: (?={{ident_break_char}})
  # a quoted identifier with possibly escaped single quote
  # preceeded by an arbitary number of excaped backslashes
  ident_quoted: \'((?:\\\\)*\\\'|[^''])*\'
  # an identifier can be an atom or a variable
  ident_unquoted: '[_A-Za-z]{{ident_char}}*'
  # all characters not being used to indicate a context change
  illegal_ident: '[^\s,:.;''(){}\[\]%=|/]+'
  # quoted/unquoted/macro identifier
  ident: \?{,2}(?:{{ident_unquoted}}|{{ident_quoted}})

  # https://www.erlang.org/doc/reference_manual/macros.html#predefined-macros
  erlang_macros: |-
    (?x:
      MODULE|FUNCTION_NAME|FUNCTION_ARITY|MODULE_STRING|
      FILE|LINE|MACHINE|OTP_RELEASE
    ){{ident_break}}

  # https://www.erlang.org/doc/man/erlang.html#exports
  erlang_functions: |-
    (?x:
      abs|adler32|adler32_combine|append_element|apply|atom_to_binary|atom_to_list|
      binary_part|binary_to_atom|binary_to_existing_atom|binary_to_float|
      binary_to_integer|binary_to_list|binary_to_term|bit_size|bitstring_to_list|
      bump_reductions|byte_size|cancel_timer|ceil|check_old_code|check_process_code|
      convert_time_unit|crc32|crc32_combine|date|decode_packet|delete_element|
      delete_module|demonitor|disconnect_node|display|dist_ctrl_get_data|
      dist_ctrl_get_data_notification|dist_ctrl_input_handler|dist_ctrl_put_data|
      element|erase|error|exit|external_size|float|float_to_binary|float_to_list|
      floor|fun_info|fun_to_list|function_exported|garbage_collect|get|get_cookie|
      get_keys|get_stacktrace|group_leader|halt|hd|hibernate|insert_element|
      integer_to_binary|integer_to_list|iolist_size|iolist_to_binary|
      iolist_to_iovec|is_alive|is_atom|is_binary|is_bitstring|is_boolean|is_builtin|
      is_float|is_function|is_integer|is_list|is_map|is_map_key|is_number|is_pid|
      is_port|is_process_alive|is_record|is_reference|is_tuple|length|link|
      list_to_atom|list_to_binary|list_to_bitstring|list_to_existing_atom|
      list_to_float|list_to_integer|list_to_pid|list_to_port|list_to_ref|
      list_to_tuple|load_module|load_nif|loaded|localtime|
      localtime_to_universaltime|make_ref|make_tuple|map_get|map_size|
      match_spec_test|max|md5|md5_final|md5_init|md5_update|memory|min|
      module_loaded|monitor|monitor_node|monotonic_time|nif_error|node|nodes|now|
      open_port|phash|phash2|pid_to_list|port_call|port_close|port_command|
      port_connect|port_control|port_info|port_to_list|ports|pre_loaded|
      process_display|process_flag|process_info|processes|purge_module|put|raise|
      read_timer|ref_to_list|register|registered|resume_process|round|self|send|
      send_after|send_nosuspend|set_cookie|setelement|size|spawn|spawn_link|
      spawn_monitor|spawn_opt|split_binary|start_timer|statistics|suspend_process|
      system_flag|system_info|system_monitor|system_profile|system_time|
      term_to_binary|throw|time|time_offset|timestamp|tl|trace|trace_delivered|
      trace_info|trace_pattern|trunc|tuple_size|tuple_to_list|unique_integer|
      universaltime|universaltime_to_localtime|unlink|unregister|whereis|yield
    ){{ident_break}}

  erlang_types: |-
    (?x:
      # builtin data types
      # https://www.erlang.org/doc/reference_manual/typespec.html#the-erlang-type-language
      any|arity|atom|binary|bitstring|boolean|byte|char|float|fun|function|
      identifier|integer|iodata|iolist|list|map|maybe_improper_list|mfa|module|nil|
      no_return|node|none|non_neg_integer|neg_integer|pos_integer|nonempty_list|
      nonempty_maybe_improper_list|nonempty_improper_list|
      nonempty_maybe_improper_list|nonempty_string|
      number|pid|port|record|reference|string|term|timeout|tuple|

      # erlang library
      # https://www.erlang.org/doc/man/erlang.html#data-types
      dist_handle|ext_binary|iovec|message_queue_data|nif_resource|
      deprecated_time_unit|timeout|timestamp|time_unit
    ){{ident_break}}

  support_namespaces: |-
    (?x:
      # builtin namespace
      erlang|

      # erlang otp libraries
      # https://github.com/erlang/otp
      asn1|common_test|compiler|crypto|debugger|dialyzer|diameter|edoc|eldap|
      erl_(docgen|interface)|et|eunit|ftp|hipe|inets|jinterface|kernel|
      megaco|mnesia|observer|odbc|os_mon|parsetools|public_key|reltool|
      runtime_tools|sasl|snmp|ssh|ssl|stdlib|syntax_tools|tftp|tools|wx|xmerl
    ){{ident_break}}

###############################################################################

contexts:

  main:
    - meta_include_prototype: false
    - match: ''
      push: [statements, shebang]

  prototype:
    - include: comments

  statements:
    - include: preproc-control
    - include: preproc-undef
    - include: preproc-define
    - include: preproc-export
    - include: preproc-import
    - include: preproc-include
    - include: preproc-module
    - include: preproc-record
    - include: preproc-spec
    - include: preproc-type
    - include: preproc-attribute
    - include: function
    - include: illegal-stray
    # fallback incase preprocessor or function didn't match
    - match: (?=\S)
      push:
        - include: eol-pop
        - include: terminator-clause
        - include: separator-clauses
        - include: separator-expressions
        - include: expressions

  terms:
    - include: constant
    - include: keyword
    - include: operator
    - include: character
    - include: macro
    - include: number
    - include: record
    - include: string
    - include: operator-unary
    - include: variable-anonymous
    - include: atom

  common:
    - include: map-of-expressions
    - include: expr-control
    - include: expr-try
    - include: expr-fun
    - include: function-call
    - include: terms

  expressions-nested:
    - include: binary
    - include: group-of-expressions
    - include: list-of-expressions
    - include: tuple-of-expressions

  expressions:
    - include: expressions-nested
    - include: namespace
    - include: common
    - include: variable-other

  function-parameter-nested:
    - include: binary-function-parameter
    - include: group-of-function-parameters
    - include: list-of-function-parameters
    - include: tuple-of-function-parameters

  function-parameter:
    - include: parameters-end-pop
    - include: function-parameter-nested
    - include: namespace
    - include: common
    - include: variable-parameter

  type-common:
    - include: illegal-type-keyword
    - include: map-of-types
    - include: separator-type
    - include: separator-union
    - include: type-namespace
    - include: type-call

  type-expressions:
    - include: binary
    - include: group-of-types
    - include: list-of-types
    - include: tuple-of-types
    - include: type-common
    - include: terms
    - include: variable-other

  type-parameter-nested:
    - include: binary-type-parameter
    - include: group-of-type-parameters
    - include: list-of-type-parameters
    - include: tuple-of-type-parameters
    - include: type-common

  type-parameter:
    - include: parameters-end-pop
    - include: type-parameter-nested
    - include: terms
    - include: variable-parameter

###[ COMMENTS ]###############################################################

  comments:
    - match: \%+
      scope: punctuation.definition.comment.erlang
      push: comment-body

  comment-body:
    - meta_include_prototype: false
    - meta_scope: comment.line.percentage.erlang
    - match: \n
      pop: 1

  shebang:
    - meta_include_prototype: false
    - match: ^\#!
      scope: punctuation.definition.comment.shell
      set: shebang-body
    - match: ^|(?=\S)  # Note: Ensure to highlight shebang if the syntax is embedded.
      pop: 1

  shebang-body:
    - meta_include_prototype: false
    - meta_scope: comment.line.shebang.shell
    # Note: Keep sync with first_line_match!
    - match: \b(erlang|escript)\b
      scope: constant.language.shebang.erlang
    - match: \n
      pop: 1

###[ PREPROCESSOR CONTROL ]###################################################

  preproc-control:
    # https://www.erlang.org/doc/reference_manual/macros.html#flow-control-in-macros
    # Note:
    #   The `-` is scoped as `punctuation.definition` because:
    #   1. derectives are most likely one-liners (with exceptions!)
    #   2. the hyphon is compared to the hash-tag in C/C++ preprocessors
    #   3. the `.` is meant to share the scope `punctuation.terminator.clause`
    #      with clauses/functions as it has the same meaning.
    - match: (-)\s*(ifdef|ifndef){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.conditional.erlang
      push: [preproc-control-meta, preproc-control-definitions]
    - match: (-)\s*(if|elif){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.conditional.erlang
      push: [preproc-control-meta, preproc-control-expressions]
    - match: (-)\s*(else|endif){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.conditional.erlang
      push: preproc-control-meta

  preproc-control-meta:
    - meta_scope: meta.preprocessor.conditional.erlang
    - include: preproc-expect-end

  preproc-control-definitions:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-control-definitions-end
        - constant-other-macro
    - include: preproc-stray-arguments-end

  preproc-control-definitions-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.conditional.arguments.erlang
    - include: expect-arguments-end

  preproc-control-expressions:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - clear_scopes: 1
        - meta_scope: meta.preprocessor.conditional.arguments.erlang
        - include: arguments-common
        - include: expressions
    - include: preproc-stray-arguments-end

###[ PREPROCESSOR UNDEF ]#####################################################

  preproc-undef:
    - match: (-)\s*(undef){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.undef.erlang
      push:
        - preproc-undef-end
        - preproc-undef-arguments

  preproc-undef-end:
    - meta_scope: meta.preprocessor.undef.erlang
    - include: preproc-expect-end

  preproc-undef-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-undef-arguments-end
        - entity-name-macro
    - include: preproc-stray-arguments-end

  preproc-undef-arguments-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.undef.arguments.erlang
    - include: expect-arguments-end

###[ PREPROCESSOR DEFINE ]####################################################

  preproc-define:
    # https://www.erlang.org/doc/reference_manual/macros.html#defining-and-using-macros
    - match: (-)\s*(define){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.define.erlang
      push:
        - preproc-define-end
        - preproc-define-arguments

  preproc-define-end:
    - meta_scope: meta.preprocessor.define.erlang
    - include: preproc-expect-end

  preproc-define-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-define-arguments-body
        - expect-arguments-separator
        - preproc-define-arguments-parameters
        - entity-name-macro
    - include: preproc-stray-arguments-end

  preproc-define-arguments-parameters:
    - meta_content_scope: meta.macro.identifier.erlang
    - match: \(
      scope: punctuation.section.parameters.begin.erlang
      set:
        - meta_scope: meta.macro.parameters.erlang
        - include: parameters-common
        - include: function-parameter
    - include: else-pop

  preproc-define-arguments-body:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.define.arguments.erlang
    - include: separator-clauses
    - include: separator-expressions
    - include: separator-union
    - include: expressions
    - include: arguments-end

###[ PREPROCESSOR EXPORT ]####################################################

  preproc-export:
    # https://www.erlang.org/doc/reference_manual/modules.html#pre-defined-module-attributes
    - match: (-)\s*(export(_type)?){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.export.erlang
      push:
        - preproc-export-end
        - preproc-export-arguments

  preproc-export-end:
    - meta_scope: meta.preprocessor.export.erlang
    - include: preproc-expect-end

  preproc-export-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-export-arguments-end
        - preproc-expect-references
    - include: preproc-stray-arguments-end

  preproc-export-arguments-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.export.arguments.erlang
    - include: expect-arguments-end

  preproc-expect-references:
    - match: \[
      scope: punctuation.section.sequence.begin.erlang
      set:
        - meta_scope: meta.sequence.list.erlang
        - include: list-common
        - include: namespace
        - include: reference
    - match: (?=[.)])
      pop: 1
    - match: \S
      scope: invalid.illegal.expect-list.erlang

###[ PREPROCESSOR IMPORT ]####################################################

  preproc-import:
    # https://www.erlang.org/doc/reference_manual/modules.html#pre-defined-module-attributes
    - match: (-)\s*(import){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.import.erlang
      push:
        - preproc-import-end
        - preproc-import-arguments

  preproc-import-end:
    - meta_scope: meta.preprocessor.import.erlang
    - include: preproc-expect-end

  preproc-import-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-import-arguments-end
        - preproc-expect-references
        - expect-arguments-separator
        - entity-name-module
    - include: preproc-stray-arguments-end

  preproc-import-arguments-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.import.arguments.erlang
    - include: expect-arguments-end

###[ PREPROCESSOR INCLUDE ]###################################################

  preproc-include:
    # https://www.erlang.org/doc/reference_manual/macros.html#file-inclusion
    - match: (-)\s*(include(_lib)?){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.include.erlang
      push:
        - preproc-include-end
        - preproc-include-arguments

  preproc-include-end:
    - meta_scope: meta.preprocessor.include.erlang
    - include: preproc-expect-end

  preproc-include-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-include-arguments-end
        - preproc-include-path
    - include: preproc-stray-arguments-end

  preproc-include-arguments-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.include.arguments.erlang
    - include: expect-arguments-end

  preproc-include-path:
    - match: \"
      scope: punctuation.definition.string.begin.erlang
      set: [string-body, string-maybe-env]
    - include: else-pop

###[ PREPROCESSOR MODULE ]####################################################

  preproc-module:
    # https://www.erlang.org/doc/reference_manual/modules.html#module-syntax
    - match: (-)\s*(module){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.namespace.erlang
      push:
        - preproc-module-end
        - preproc-module-arguments

  preproc-module-end:
    - meta_scope: meta.preprocessor.namespace.erlang
    - include: preproc-expect-end

  preproc-module-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-module-arguments-end
        - entity-name-module
    - include: preproc-stray-arguments-end

  preproc-module-arguments-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.namespace.arguments.erlang
    - include: expect-arguments-end

###[ PREPROCESSOR ATTRIBUTE ]#################################################

  preproc-attribute:
    - match: -(?=\s*{{ident}})
      scope: punctuation.definition.keyword.erlang
      push:
        - preproc-attribute-end
        - preproc-attribute-arguments
        - preproc-attribute-keyword

  preproc-attribute-end:
    - meta_scope: meta.preprocessor.attribute.erlang
    - include: preproc-expect-end

  preproc-attribute-keyword:
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang keyword.control.directive.attribute.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang keyword.control.directive.attribute.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  preproc-attribute-arguments:
    # ordinary directive `-name( ... ).`
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - clear_scopes: 1
        - meta_scope: meta.preprocessor.attribute.arguments.erlang
        - include: arguments-common
        - include: preproc-attribute-argument
    # spec/type like directive `-attribute ... .`
    - match: (?=\S)
      set:
        - include: separator-expressions
        - include: expressions
        - include: clause-end-pop
    - include: eol-pop

  preproc-attribute-argument:
    # https://www.erlang.org/doc/reference_manual/expressions.html#parenthesized-expressions
    - match: \(
      scope: punctuation.section.group.begin.erlang
      push:
        - meta_scope: meta.group.erlang
        - include: group-common
        - include: preproc-attribute-argument
    # https://www.erlang.org/doc/reference_manual/data_types.html#list
    - match: \[
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.list.erlang
        - include: list-common
        - include: preproc-attribute-argument
    # https://www.erlang.org/doc/reference_manual/data_types.html#tuple
    - match: \{
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.tuple.erlang
        - include: tuple-common
        - include: preproc-attribute-argument
    - include: binary
    - include: namespace
    - include: reference
    - include: common
    - include: variable-other

###[ PREPROCESSOR RECORD ]####################################################

  preproc-record:
    # https://www.erlang.org/doc/reference_manual/modules.html#record-definitions
    - match: (-)\s*(record){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.record.erlang
      push:
        - preproc-record-end
        - preproc-record-arguments

  preproc-record-end:
    - meta_scope: meta.preprocessor.record.erlang
    - include: preproc-expect-end

  preproc-record-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - preproc-record-arguments-end
        - record-fields-declaration
        - expect-arguments-separator
        - record-name
        - entity-name-record
    - include: preproc-stray-arguments-end

  preproc-record-arguments-end:
    - clear_scopes: 1
    - meta_scope: meta.preprocessor.record.arguments.erlang
    - include: expect-arguments-end

###[ PREPROCESSOR SPEC ]######################################################

  preproc-spec:
    # https://www.erlang.org/doc/reference_manual/typespec.html#specifications-for-functions
    - match: (-)\s*(callback|spec){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.spec.erlang
      push:
        - meta_scope: meta.preprocessor.spec.erlang
        - include: terminator-clause-pop
        - include: separator-clauses
        # NOTE: function name is optional for all but the first clauses
        - match: (?={{ident}}\s*:[^:])
          push:
            - preproc-spec-return
            - preproc-spec-parameters
            - preproc-spec-path
            - entity-name-function
            - namespace-accessor
            - namespace-qualifier
        - match: (?=\S)
          push:
            - preproc-spec-return
            - preproc-spec-parameters
            - preproc-spec-name
            - entity-name-function

  preproc-spec-name:
    - meta_scope: meta.preprocessor.spec.name.erlang
    - include: else-pop

  preproc-spec-path:
    - meta_scope: meta.preprocessor.spec.name.erlang meta.path.erlang
    - include: else-pop

  preproc-spec-parameters:
    - match: \(
      scope: punctuation.section.parameters.begin.erlang
      set:
        - clear_scopes: 1
        - meta_scope: meta.preprocessor.spec.parameters.erlang
        - include: parameters-common
        - include: type-parameter
    - include: else-pop

  preproc-spec-return:
    - match: ->
      scope:
        meta.preprocessor.spec.erlang
        punctuation.separator.parameters-return-type.erlang
      set:
        - clear_scopes: 1
        - meta_content_scope: meta.preprocessor.spec.return-type.erlang
        - include: preproc-spec-guards
        - include: separator-expressions
        - include: type-expressions
    - include: preproc-spec-guards
    - include: illegal-group
    - match: '{{illegal_ident}}|\S'
      scope: invalid.illegal.expect-separator.erlang

  preproc-spec-guards:
    - match: (?=when{{ident_break_char}})
      set:
        - match: when
          scope: keyword.control.conditional.when.erlang
          set:
            - clear_scopes: 1
            - meta_scope: meta.preprocessor.spec.guards.erlang
            - include: separator-expressions
            - include: type-expressions
            - include: clause-end-pop
    - include: clause-end-pop

###[ PREPROCESSOR TYPE ]######################################################

  preproc-type:
    # https://www.erlang.org/doc/reference_manual/typespec.html#typespec-of-user-defined-types
    - match: (-)\s*(opaque|type){{ident_break}}
      captures:
        1: punctuation.definition.keyword.erlang
        2: keyword.control.directive.type.erlang
      push:
        - preproc-type-end
        - preproc-type-name

  preproc-type-end:
    - meta_scope: meta.preprocessor.type.erlang
    - include: preproc-expect-end

  preproc-type-name:
    - match: (?=\S)
      set:
        - preproc-type-body
        - preproc-type-parameters
        - entity-name-type

  preproc-type-parameters:
    - meta_content_scope: meta.preprocessor.type.name.erlang
    - match: \(
      scope: punctuation.section.parameters.begin.erlang
      set:
        - clear_scopes: 1
        - meta_scope: meta.preprocessor.type.parameters.erlang
        - include: parameters-common
        - include: type-parameter
    - include: else-pop

  preproc-type-body:
    - match: '::'
      scope: punctuation.separator.type-head-body.erlang
      set:
        - include: type-expressions
        - include: clause-end-pop
    - include: clause-end-pop
    # anything else is invalid
    - include: illegal-group
    - match: '{{illegal_ident}}|\S'
      scope: invalid.illegal.expect-separator.erlang

###[ PREPROCESSOR PROTOTYPES ]################################################

  preproc-stray-arguments-end:
    - match: \)
      scope: invalid.illegal.stray-arguments-end.erlang
      pop: 1
    - include: eol-pop
    - include: else-pop

  preproc-expect-end:
    - include: terminator-clause-pop
    - match: \n
      scope: invalid.illegal.expect-terminator.erlang
      pop: 1
    - match: '[^\s.]+'
      scope: invalid.illegal.expect-terminator.erlang

###[ CONTROL EXPRESSION ]#####################################################

  expr-control:
    # https://www.erlang.org/doc/reference_manual/expressions.html#if
    - match: if{{ident_break}}
      scope: keyword.control.conditional.if.erlang
      push:
        - meta_scope: meta.if.erlang
        - include: expr-control-conditional-end
        - include: expr-control-body
    # https://www.erlang.org/doc/reference_manual/expressions.html#case
    - match: case{{ident_break}}
      scope: keyword.control.conditional.case.erlang
      push:
        - meta_scope: meta.case.erlang
        - include: expr-control-conditional-end
        - include: expr-control-body
    # https://www.erlang.org/doc/reference_manual/expressions.html#maybe
    - match: maybe{{ident_break}}
      scope: keyword.control.conditional.maybe.erlang
      push:
        - meta_scope: meta.maybe.erlang
        - match: \?=
          scope: keyword.operator.logical.erlang
        - include: expr-control-conditional-end
        - include: expr-control-body
    # https://www.erlang.org/doc/reference_manual/expressions.html#receive
    - match: receive{{ident_break}}
      scope: keyword.control.flow.receive.erlang
      push:
        - meta_scope: meta.receive.erlang
        - include: expr-control-flow-end
        - include: expr-control-body
    # https://www.erlang.org/doc/reference_manual/expressions.html#block-expressions
    - match: begin{{ident_break}}
      scope: keyword.control.flow.begin.erlang
      push:
        - meta_scope: meta.block.erlang
        - include: expr-control-flow-end
        - include: expr-control-body
    # https://www.erlang.org/doc/reference_manual/expressions.html#guard-sequences
    - match: when{{ident_break}}
      scope: keyword.control.conditional.when.erlang
      push:
        - match: (?=->|\.|(end|after|catch){{ident_break_char}})
          pop: 1
        - include: expr-control-body
    - match: ->
      scope: punctuation.separator.clause-head-body.erlang

  expr-control-body:
    - include: separator-clauses
    - include: separator-expressions
    - include: expressions

  expr-control-conditional-end:
    - match: end{{ident_break}}|(?=\.)
      scope: keyword.control.conditional.end.erlang
      pop: 1

  expr-control-flow-end:
    - match: end{{ident_break}}|(?=\.)
      scope: keyword.control.flow.end.erlang
      pop: 1

###[ TRY-CATCH EXPRESSION ]###################################################

  expr-try:
    # https://www.erlang.org/doc/reference_manual/expressions.html#try
    - match: try{{ident_break}}
      scope: keyword.control.exception.try.erlang
      push:
        - meta_scope: meta.exception.try.erlang
        - match: end{{ident_break}}|(?=\.)
          scope: keyword.control.exception.end.erlang
          pop: 1
        - match: catch{{ident_break}}
          scope: keyword.control.exception.catch.erlang
          push:
            - clear_scopes: 1
            - meta_scope: meta.exception.catch.erlang
            - match: (?=\.|(end|after){{ident_break_char}})
              pop: 1
            - match: ->
              scope: punctuation.separator.clause-head-body.erlang
              push:
                - match: (?=[.;]|(end|after|catch){{ident_break_char}})
                  pop: 1
                - include: separator-expressions
                - include: expressions
            # Don't match namespaces in exception patterns
            - match: ':'
              scope: punctuation.separator.patterns.erlang
            - include: separator-clauses
            - include: expressions-nested
            - include: common
            - include: variable-other
        - match: after{{ident_break}}
          scope: keyword.control.exception.after.erlang
          push:
            - clear_scopes: 1
            - meta_scope: meta.exception.after.erlang
            - match: (?=\.|(end|after|catch){{ident_break_char}})
              pop: 1
            - include: expr-control-body
        - include: expr-control-body

###[ FUN EXPRESSION ]#########################################################

  expr-fun:
    # https://www.erlang.org/doc/reference_manual/expressions.html#fun-expressions
    - match: fun{{ident_break}}
      scope: keyword.declaration.function.erlang
      push:
        - expr-fun-meta
        - expr-fun-type-decider

  expr-fun-meta:
    - meta_scope: meta.fun.erlang
    - include: immediatelly-pop

  expr-fun-type-decider:
    # function reference (e.g.: FuncName = fun module:name/arity)
    # keyword `fun` followed by a `function-declaration` but without `end`.
    - include: namespace-pop
    - include: reference-pop
    # function expression (e.g.: FuncName = fun(arg) ... end)
    - match: (?=\S)
      set: expr-fun-anonymous-clauses

  expr-fun-anonymous-clauses:
    - match: end{{ident_break}}|(?=\.)
      scope: keyword.declaration.end.erlang
      pop: 1
    - include: separator-clauses
    - match: (?=\S)
      push:
        - expr-fun-body
        - expr-fun-parameters
        - expr-fun-name-meta
        - expr-fun-name

  expr-fun-name:
    - include: variable-other-pop
    - include: macro-pop
    - match: '{{illegal_ident}}'
      scope: invalid.illegal.expect-variable.erlang
      pop: 1
    - include: else-pop

  expr-fun-name-meta:
    - clear_scopes: 1
    - meta_scope: meta.fun.identifier.erlang
    - include: else-pop

  expr-fun-parameters:
    - match: \(
      scope: punctuation.section.parameters.begin.erlang
      set:
        - clear_scopes: 1
        - meta_scope: meta.fun.parameters.erlang
        - include: parameters-common
        - include: function-parameter
    - include: else-pop

  expr-fun-body:
    - match: (?=[.;]|end{{ident_break_char}})
      pop: 1
    - include: separator-expressions
    - include: expressions

###[ FUNCTION DEFINITION ]####################################################

  function:
    # https://www.erlang.org/doc/reference_manual/functions.html#function-declaration-syntax
    # Function names can be (un-)quoted atoms or nested (un-)quoted macros
    # which can contain escape sequences as ordinary strings.
    # Example:  ?'fu % na\'me' (arguments)
    - match: (?={{ident}}\s*\()
      push: [function-body, function-parameters, entity-name-function]

  function-parameters:
    - meta_content_scope: meta.function.identifier.erlang
    - match: \(
      scope: punctuation.section.parameters.begin.erlang
      set:
        - meta_scope: meta.function.parameters.erlang
        - include: parameters-common
        - include: function-parameter
    - include: else-pop

  function-body:
    - match: ''
      set:
        - meta_scope: meta.function.erlang
        - match: \.
          scope: punctuation.terminator.clause.erlang
          pop: 1
        - match: ';'
          scope: punctuation.separator.clauses.erlang
          pop: 1
        - include: separator-expressions
        - include: expressions

###[ FUNCTION CALL ]##########################################################

  function-call:
    - match: (?={{ident}}\s*\()
      push: [function-call-arguments, function-call-name, variable-function]

  function-call-pop:
    - match: (?={{ident}}\s*\()
      set: [function-call-arguments, function-call-path, variable-function]

  function-call-name:
    - meta_scope: meta.function-call.identifier.erlang
    - include: else-pop

  function-call-path:
    - meta_scope: meta.path.erlang meta.function-call.identifier.erlang
    - include: else-pop

  function-call-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - meta_scope: meta.function-call.arguments.erlang
        - include: arguments-common
        - include: expressions
    - include: else-pop

###[ TYPE CALL ]##############################################################

  type-call:
    # https://www.erlang.org/doc/reference_manual/typespec.html
    # A function type looks like:
    #  fun()                  %% any function
    #  fun((...) -> Type)     %% any arity, returning Type
    #  fun(() -> Type)
    #  fun((TList) -> Type)
    - match: fun{{ident_break}}
      scope: support.type.erlang
      push: [type-call-fun-arguments, type-call-name]
    # other type definition
    - match: (?={{ident}}\s*\()
      push: [type-call-other-arguments, type-call-name, storage-type]

  type-call-pop:
    - match: fun{{ident_break}}
      scope: support.type.erlang
      set: [type-call-fun-arguments, type-call-path]
    - match: (?={{ident}}\s*\()
      set: [type-call-other-arguments, type-call-path, storage-type]

  type-call-name:
    - meta_scope: meta.type-call.identifier.erlang
    - include: else-pop

  type-call-path:
    - meta_scope: meta.path.erlang meta.type-call.identifier.erlang
    - include: else-pop

  type-call-fun-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - type-call-fun-arguments-end
        - type-call-fun-return-type
        - type-call-fun-parameters
    - include: else-pop

  type-call-fun-arguments-end:
    - meta_scope: meta.type-call.arguments.erlang
    - include: expect-arguments-end

  type-call-fun-parameters:
    - match: \(
      scope: punctuation.section.parameters.begin.erlang
      set:
        - meta_scope: meta.fun.parameters.erlang
        - include: variable-any
        - include: parameters-common
        - include: type-parameter
    - include: else-pop

  type-call-fun-return-type:
    - match: ->
      scope: punctuation.separator.parameters-return-type.erlang
      set:
        - meta_content_scope: meta.fun.return-type.erlang
        - match: (?=[.;)])
          pop: 1
        - include: type-expressions
    - include: else-pop

  type-call-other-arguments:
    - match: \(
      scope: punctuation.section.arguments.begin.erlang
      set:
        - meta_scope: meta.type-call.arguments.erlang
        - include: arguments-common
        - include: type-expressions
    - include: else-pop

###[ GROUPS ]#################################################################

  group-of-expressions:
    # https://www.erlang.org/doc/reference_manual/expressions.html#parenthesized-expressions
    - match: \(
      scope: punctuation.section.group.begin.erlang
      push:
        - meta_scope: meta.group.erlang
        - include: group-common
        - include: expressions

  group-of-function-parameters:
    # https://www.erlang.org/doc/reference_manual/expressions.html#parenthesized-expressions
    - match: \(
      scope: punctuation.section.group.begin.erlang
      push:
        - meta_scope: meta.group.erlang
        - include: group-common
        - include: function-parameter

  group-of-types:
    # https://www.erlang.org/doc/reference_manual/expressions.html#parenthesized-expressions
    - match: \(
      scope: punctuation.section.group.begin.erlang
      push:
        - meta_scope: meta.group.erlang
        - include: group-common
        - include: type-expressions

  group-of-type-parameters:
    # https://www.erlang.org/doc/reference_manual/expressions.html#parenthesized-expressions
    - match: \(
      scope: punctuation.section.group.begin.erlang
      push:
        - meta_scope: meta.group.erlang
        - include: group-common
        - include: type-parameter

  group-common:
    - match: \)
      scope: punctuation.section.group.end.erlang
      pop: 1
    - include: clause-end-or-stray

###[ LISTS ]##################################################################

  list-of-expressions:
    # https://www.erlang.org/doc/reference_manual/data_types.html#list
    - match: \[
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.list.erlang
        - include: list-common
        - include: expressions

  list-of-function-parameters:
    # https://www.erlang.org/doc/reference_manual/data_types.html#list
    - match: \[
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.list.erlang
        - include: list-common
        - include: function-parameter

  list-of-types:
    # https://www.erlang.org/doc/reference_manual/data_types.html#list
    - match: \[
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.list.erlang
        - include: variable-any
        - include: list-common
        - include: type-expressions

  list-of-type-parameters:
    # https://www.erlang.org/doc/reference_manual/data_types.html#list
    - match: \[
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.list.erlang
        - include: variable-any
        - include: list-common
        - include: type-parameter

  list-common:
    - match: \]
      scope: punctuation.section.sequence.end.erlang
      pop: 1
    - include: operator-comprehension
    - include: separator-sequence
    - include: separator-union
    - include: clause-end-or-stray

###[ MAPS ]###################################################################

  map-of-expressions:
    # https://www.erlang.org/doc/reference_manual/data_types.html#map
    # https://www.erlang.org/doc/reference_manual/expressions.html#map-expressions
    - match: '#{'
      scope: meta.mapping.erlang punctuation.section.mapping.begin.erlang
      push:
        - include: map-common
        # value
        - match: =>|\:=
          scope: meta.mapping.erlang punctuation.separator.key-value.erlang
          push:
            - meta_content_scope: meta.mapping.value.erlang
            - include: expressions
            - include: value-end-pop
        # key
        - match: ',?'
          scope: meta.mapping.erlang punctuation.separator.sequence.erlang
          push:
            - meta_content_scope: meta.mapping.key.erlang
            - match: (?==>|\:=)
              pop: 1
            - include: expressions
            - include: value-end-pop
    - include: map-separator

  map-of-types:
    # https://www.erlang.org/doc/reference_manual/data_types.html#map
    # https://www.erlang.org/doc/reference_manual/expressions.html#map-expressions
    - match: '#{'
      scope: meta.mapping.erlang punctuation.section.mapping.begin.erlang
      push:
        - include: map-common
        # value
        - match: =>|\:=
          scope: meta.mapping.erlang punctuation.separator.key-value.erlang
          push:
            - meta_content_scope: meta.mapping.value.erlang
            - include: type-expressions
            - include: value-end-pop
        # key
        - match: ',?'
          scope: meta.mapping.erlang punctuation.separator.sequence.erlang
          push:
            - meta_content_scope: meta.mapping.key.erlang
            - match: (?==>|\:=)
              pop: 1
            - include: type-expressions
            - include: value-end-pop
    - include: map-separator

  map-separator:
    - match: =>|\:=
      scope: punctuation.separator.key-value.erlang

  map-common:
    - match: \}
      scope: meta.mapping.erlang punctuation.section.mapping.end.erlang
      pop: 1
    - include: clause-end-or-stray

###[ RECORDS ]################################################################

  record:
    # https://www.erlang.org/doc/reference_manual/records.html
    - match: \#(?={{ident}})
      scope: punctuation.definition.record.erlang
      push: [record-fields, record-name, variable-other-record]
    # records may look like normal variables in macro definitions
    - match: '{{variable}}(?=\.{{ident}})'
      scope: meta.record.identifier.erlang variable.other.readwrite.erlang
      push: record-fields

  record-name:
    - meta_scope: meta.record.identifier.erlang
    - include: else-pop

  variable-other-record:
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang storage.type.record.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang storage.type.record.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  record-fields:
    - include: record-field-access
    - include: record-fields-declaration

  record-field-access:
    - match: \.
      scope: meta.record.erlang punctuation.accessor.dot.erlang
      set:
        - record-field-access-meta
        - record-field-access-name

  record-field-access-meta:
    - meta_content_scope: meta.record.field.erlang
    - include: immediatelly-pop

  record-field-access-name:
    - include: variable-other-field
    - include: eol-pop

  record-fields-declaration:
    - match: \{
      scope: punctuation.section.fields.begin.erlang
      set: record-fields-declaration-common
    - include: else-pop

  record-fields-declaration-common:
    - meta_scope: meta.record.fields.erlang
    - match: \}
      scope: punctuation.section.fields.end.erlang
      pop: 1
    - include: clause-end-or-stray
    # field value
    - match: =
      scope: meta.field.erlang keyword.operator.assignment.erlang
      push: record-field-value
    # field type
    - match: '::'
      scope: meta.field.erlang punctuation.separator.variable-type.erlang
      push: record-field-type
    # field identifier
    - match: ',?'
      scope: punctuation.separator.expressions.erlang
      push:
        - record-field-identifier-meta
        - record-field-identifier

  record-field-identifier-meta:
    - meta_content_scope: meta.field.identifier.erlang
    - include: immediatelly-pop

  record-field-identifier:
    - include: variable-anonymous-pop
    - include: variable-other-field

  record-field-type:
    - meta_content_scope: meta.field.type.erlang
    - include: type-expressions
    - include: value-end-pop

  record-field-value:
    - meta_content_scope: meta.field.value.erlang
    - match: (?=::)
      pop: 1
    - include: expressions
    - include: value-end-pop

  variable-other-field:
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang variable.other.member.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang variable.other.member.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

###[ TUPLES ]#################################################################

  tuple-of-expressions:
    # https://www.erlang.org/doc/reference_manual/data_types.html#tuple
    - match: \{
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.tuple.erlang
        - include: tuple-common
        - include: expressions

  tuple-of-function-parameters:
    # https://www.erlang.org/doc/reference_manual/data_types.html#tuple
    - match: \{
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.tuple.erlang
        - include: tuple-common
        - include: function-parameter

  tuple-of-types:
    # https://www.erlang.org/doc/reference_manual/data_types.html#tuple
    - match: \{
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.tuple.erlang
        - include: variable-any
        - include: tuple-common
        - include: type-expressions

  tuple-of-type-parameters:
    # https://www.erlang.org/doc/reference_manual/data_types.html#tuple
    - match: \{
      scope: punctuation.section.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.tuple.erlang
        - include: variable-any
        - include: tuple-common
        - include: type-parameter

  tuple-common:
    - match: \}
      scope: punctuation.section.sequence.end.erlang
      pop: 1
    - include: operator-comprehension
    - include: separator-sequence
    - include: clause-end-or-stray

###[ KEYWORDS ]###############################################################

  constant:
    # https://www.erlang.org/doc/reference_manual/data_types.html#boolean
    - match: (false|true){{ident_break}}
      scope: constant.language.boolean.erlang
    # https://www.erlang.org/doc/reference_manual/errors.html#exceptions
    - match: (error|exit|ok|throw){{ident_break}}
      scope: constant.language.exception.type.erlang
    - match: (badarg|badarith|badmatch|function_clause|case_clause|if_clause|try_clause|undef|badfun|badarity|timeout_value|noproc|nocatch|system_limit){{ident_break}}
      scope: constant.language.exception.reason.erlang
    # https://www.erlang.org/doc/reference_manual/records.html#defining-records
    - match: (none|undefined){{ident_break}}
      scope: constant.language.undefined.erlang
    # https://www.erlang.org/doc/man/erlang.html#data-types
    - match: (off_heap|on_heap){{ident_break}}
      scope: constant.language.message-queue-data.erlang
    - match: ((milli|micro|nano)?second|native|perf_counter|infinity){{ident_break}}
      scope: constant.language.time.erlang
    - match: ((milli|micro|nano)_)?seconds{{ident_break}}
      scope: constant.language.time.erlang invalid.deprecated.erlang

  keyword:
    # keywords which are not otherwise matched already and don't need fallbacks
    - match: catch{{ident_break}}
      scope: keyword.control.exception.erlang
    - match: (after|cond|end|let|of){{ident_break}}
      scope: keyword.control.flow.erlang

  illegal-type-keyword:
    # The following keywords are not part of the type/spec language and must
    # not be used as types/constants as they are part of the reserved words.
    # https://www.erlang.org/doc/reference_manual/introduction.html#reserved-words
    - match: (after|andalso|begin|case|catch|cond|end|if|let|of|orelse|receive|try|when){{ident_break}}
      scope: invalid.illegal.keyword.erlang

###[ NAMESPACE ]##############################################################

  namespace:
    - match: (?={{ident}}\s*:[^:=])
      push: [namespace-member, namespace-accessor, namespace-qualifier]

  namespace-pop:
    - match: (?={{ident}}\s*:[^:=])
      set: [namespace-member, namespace-accessor, namespace-qualifier]

  type-namespace:
    - match: (?={{ident}}\s*:[^:=])
      push: [type-namespace-member, namespace-accessor, namespace-qualifier]

  namespace-member:
    - meta_scope: meta.path.erlang
    - include: function-call-pop
    - match: (?=\S)|$
      set: [namespace-meta, namespace-member-other]

  type-namespace-member:
    - meta_scope: meta.path.erlang
    - include: type-call-pop
    - match: (?=\S)|$
      set: [namespace-meta, namespace-member-other]

  namespace-meta:
    - meta_scope: meta.path.erlang
    - include: immediatelly-pop

  namespace-member-other:
   - include: reference-pop
   - include: constant
   - include: atom-pop
   - include: macro-pop
   - include: variable-other-pop
   - include: immediatelly-pop

  namespace-accessor:
    - match: ':'
      scope: punctuation.accessor.double-colon.erlang
      pop: 1

  namespace-qualifier:
    - match: '{{support_namespaces}}'
      scope: meta.atom.erlang support.namespace.erlang
      pop: 1
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang variable.namespace.erlang
      pop: 1
    - include: variable-other-pop
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang variable.namespace.erlang
        - include: atom-quoted-common
    - include: macro-pop

###[ REFERENCE ]##############################################################

  reference:
    - match: (?={{ident}}\s*/)
      push: [reference-arity, variable-function]

  reference-pop:
    - match: (?={{ident}}\s*/)
      set: [reference-arity, variable-function]

  reference-arity:
    - meta_content_scope: meta.reference.function.name.erlang
    - match: /
      scope: meta.reference.function.erlang punctuation.separator.reference.erlang
      set:
        - reference-arity-meta
        - reference-arity-body
    - include: else-pop

  reference-arity-meta:
    - meta_content_scope: meta.reference.function.arity.erlang
    - include: immediatelly-pop

  reference-arity-body:
    - match: \d+
      scope: meta.number.integer.decimal.erlang constant.numeric.value.erlang
      pop: 1
    - include: variable-anonymous-pop
    - include: variable-other-pop
    - include: macro-pop
    - match: '{{illegal_ident}}'
      scope: invalid.illegal.expect-integer.erlang
      pop: 1
    - include: else-pop

###[ VARIABLE ]###############################################################

  variable-anonymous:
    - match: _{{ident_break}}
      scope: variable.language.anonymous.erlang

  variable-anonymous-pop:
    - match: _{{ident_break}}
      scope: variable.language.anonymous.erlang
      pop: 1

  variable-any:
    - match: \.{3}
      scope: variable.language.any.erlang

  variable-other:
    - match: '{{variable}}'
      scope: variable.other.readwrite.erlang

  variable-other-pop:
    - match: '{{variable}}'
      scope: variable.other.readwrite.erlang
      pop: 1

  variable-parameter:
    - match: '{{variable}}'
      scope: variable.parameter.erlang

###[ IDENTIFIERS ]############################################################

  atom:
    # https://www.erlang.org/doc/reference_manual/data_types.html#atom
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang constant.other.symbol.erlang
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      push:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang constant.other.symbol.erlang
        - include: atom-quoted-common

  atom-pop:
    # https://www.erlang.org/doc/reference_manual/data_types.html#atom
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang constant.other.symbol.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang constant.other.symbol.erlang
        - include: atom-quoted-common

  entity-name-function:
    # function name must be an atom
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang entity.name.function.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang entity.name.function.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  entity-name-macro:
    - match: '{{ident_unquoted}}'
      scope: meta.atom.erlang entity.name.constant.macro.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang entity.name.constant.macro.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: ident-expect-end

  entity-name-module:
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang entity.name.namespace.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang entity.name.namespace.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  entity-name-record:
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang entity.name.record.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang entity.name.record.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  entity-name-type:
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang entity.name.type.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang entity.name.type.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  constant-other-macro:
    - match: '{{ident_unquoted}}'
      scope: meta.atom.erlang constant.other.macro.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang constant.other.macro.erlang
        - include: atom-quoted-common
    - include: ident-expect-end

  storage-type:
    - match: '{{erlang_types}}'
      scope: meta.atom.erlang support.type.erlang
      pop: 1
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang storage.type.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang storage.type.erlang
        - include: atom-quoted-common
    - include: macro-pop
    - include: atom-expect-end

  variable-function:
    - match: '{{erlang_functions}}'
      scope: meta.atom.erlang support.function.erlang
      pop: 1
    - match: '{{atom_unquoted}}'
      scope: meta.atom.erlang variable.function.erlang
      pop: 1
    - match: \'
      scope: punctuation.definition.atom.begin.erlang
      set:
        - meta_include_prototype: false
        - meta_scope: meta.atom.erlang variable.function.erlang
        - include: atom-quoted-common
    - include: variable-other-pop
    - include: macro-pop
    - include: ident-expect-end

  atom-quoted-common:
    - match: \'
      scope: punctuation.definition.atom.end.erlang
      pop: 1
    - match: (?=\\)
      push: escape

  atom-expect-end:
    - match: '{{illegal_ident}}'
      scope: invalid.illegal.expect-atom.erlang
      pop: 1
    - include: else-pop

  ident-expect-end:
    - match: '{{illegal_ident}}'
      scope: invalid.illegal.expect-identifier.erlang
      pop: 1
    - include: else-pop

###[ ATOMIC DATA TYPES ]######################################################

  binary:
    # https://www.erlang.org/doc/reference_manual/data_types.html#bit-strings-and-binaries
    # https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax
    - match: <<
      scope: punctuation.definition.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.binary.erlang
        - include: binary-common
        - include: expressions-nested
        - include: common
        - include: variable-other

  binary-function-parameter:
    # https://www.erlang.org/doc/reference_manual/data_types.html#bit-strings-and-binaries
    # https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax
    - match: <<
      scope: punctuation.definition.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.binary.erlang
        - include: binary-common
        - include: function-parameter-nested
        - include: common
        - include: variable-parameter

  binary-type-parameter:
    # https://www.erlang.org/doc/reference_manual/data_types.html#bit-strings-and-binaries
    # https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax
    - match: <<
      scope: punctuation.definition.sequence.begin.erlang
      push:
        - meta_scope: meta.sequence.binary.erlang
        - include: binary-common
        - include: type-parameter-nested
        - include: terms
        - include: variable-parameter

  binary-common:
    - match: '>>'
      scope: punctuation.definition.sequence.end.erlang
      pop: 1
    - match: ':'
      scope: punctuation.separator.value-size.erlang
    - match: /
      scope: punctuation.separator.value-type.erlang
      push:
        - match: (?=>>|[.,;])
          pop: 1
        - match: '-'
          scope: punctuation.separator.type-specifiers.erlang
        - match: ':'
          scope: punctuation.separator.unit-value.erlang
        - match: (integer|float|binary|bytes|bitstring|bits|utf8|utf16|utf32){{ident_break}}
          scope: storage.type.erlang
        - match: (signed|unsigned){{ident_break}}
          scope: storage.modifier.signedness.erlang
        - match: (big|little|native){{ident_break}}
          scope: storage.modifier.endianness.erlang
        - match: unit{{ident_break}}
          scope: storage.modifier.unit.erlang
        - include: number
        - include: macro
    - include: operator-comprehension
    - include: separator-sequence
    - include: clause-end-pop

  character:
    - match: \$
      scope: constant.character.erlang punctuation.definition.character.erlang
      push:
        - meta_include_prototype: false
        - include: escape
        - match: .
          scope: constant.character.erlang
          pop: 1

  escape:
    # https://www.erlang.org/doc/reference_manual/data_types.html#escape-sequences
    - match: (\\)[bdefnrstv\\''"$~]
      scope: constant.character.escape.erlang
      captures:
        1: punctuation.definition.escape.erlang
      pop: 1
    # Character with octal representation
    - match: (\\)[0-7]{1,3}
      scope: constant.character.escape.erlang
      captures:
        1: punctuation.definition.escape.erlang
      pop: 1
    # Character with hexadecimal representation
    - match: (\\x)\h{2}
      scope: constant.character.escape.erlang
      captures:
        1: punctuation.definition.escape.erlang
      pop: 1
    - match: \\x\{
      scope: punctuation.definition.escape.begin.erlang
      set:
        - meta_scope: constant.character.escape.erlang
        - include: clause-end-pop
        - match: \}|$
          scope: punctuation.definition.escape.end.erlang
          pop: 1
        - match: \H
          scope: invalid.illegal.hex.erlang
    - match: (\\x)\S{2}
      scope: constant.character.escape.erlang invalid.illegal.escape.erlang
      captures:
        1: punctuation.definition.escape.erlang
      pop: 1
    # Control A to control Z and Control [, ] seen in default libs
    - match: (\\\^)[A-Za-z\[\]]
      scope: constant.character.escape.erlang
      captures:
        1: punctuation.definition.escape.erlang
      pop: 1
    - match: (\\\^?).?
      scope: constant.character.escape.erlang invalid.illegal.escape.erlang
      captures:
        1: punctuation.definition.escape.erlang
      pop: 1

  macro:
    # https://www.erlang.org/doc/reference_manual/macros.html#predefined-macros
    - match: (\?{1,2}){{erlang_macros}}
      scope: constant.language.macro.erlang
      captures:
        1: punctuation.definition.macro.erlang
    # https://www.erlang.org/doc/reference_manual/macros.html#defining-and-using-macros
    - match: \?{1,2}
      scope:
        constant.other.macro.erlang
        punctuation.definition.macro.erlang
      push: constant-other-macro

  macro-pop:
    # predefined macro
    - match: (\?{1,2}){{erlang_macros}}
      scope: constant.language.macro.erlang
      captures:
        1: punctuation.definition.macro.erlang
      pop: 1
    # user defined macro
    - match: \?{1,2}
      scope:
        constant.other.macro.erlang
        punctuation.definition.macro.erlang
      set: constant-other-macro

  number:
    # https://www.erlang.org/doc/reference_manual/data_types.html#number
    - match: \d[\d_]*(\.)[\d_]+([eE][-+]?[\d_]+)?\b
      scope: meta.number.float.decimal.erlang constant.numeric.value.erlang
      captures:
        1: punctuation.separator.decimal.erlang
    - match: (2\#)([0-1_]+)\b
      scope: meta.number.integer.binary.erlang
      captures:
        1: constant.numeric.base.erlang
        2: constant.numeric.value.erlang
    - match: (8\#)([0-7_]+)\b
      scope: meta.number.integer.octal.erlang
      captures:
        1: constant.numeric.base.erlang
        2: constant.numeric.value.erlang
    - match: (10\#)([0-9_]+)\b
      scope: meta.number.integer.decimal.erlang
      captures:
        1: constant.numeric.base.erlang
        2: constant.numeric.value.erlang
    - match: (16\#)([\da-fA-F_]+)\b
      scope: meta.number.integer.hexadecimal.erlang
      captures:
        1: constant.numeric.base.erlang
        2: constant.numeric.value.erlang
    - match: |-
        (?x:
            (3\#)([0-2_]+)
          | (4\#)([0-3_]+)
          | (5\#)([0-4_]+)
          | (6\#)([0-5_]+)
          | (7\#)([0-6_]+)
          | (9\#)([0-8_]+)
          | (11\#)([\daA_]+)
          | (12\#)([\da-bA-B_]+)
          | (13\#)([\da-cA-C_]+)
          | (14\#)([\da-dA-D_]+)
          | (15\#)([\da-eA-E_]+)
          | (17\#)([\da-gA-G_]+)
          | (18\#)([\da-hA-H_]+)
          | (19\#)([\da-iA-I_]+)
          | (20\#)([\da-jA-J_]+)
          | (21\#)([\da-kA-K_]+)
          | (22\#)([\da-lA-L_]+)
          | (23\#)([\da-mA-M_]+)
          | (24\#)([\da-nA-N_]+)
          | (25\#)([\da-oA-O_]+)
          | (26\#)([\da-pA-P_]+)
          | (27\#)([\da-qA-Q_]+)
          | (28\#)([\da-rA-R_]+)
          | (29\#)([\da-sA-S_]+)
          | (30\#)([\da-tA-T_]+)
          | (31\#)([\da-uA-U_]+)
          | (32\#)([\da-vA-V_]+)
          | (33\#)([\da-wA-W_]+)
          | (34\#)([\da-xA-X_]+)
          | (35\#)([\da-yA-Y_]+)
          | (36\#)([\da-zA-Z_]+)
        )\b
      scope: meta.number.integer.other.erlang
      captures:
        1: constant.numeric.base.erlang
        2: constant.numeric.value.erlang
        3: constant.numeric.base.erlang
        4: constant.numeric.value.erlang
        5: constant.numeric.base.erlang
        6: constant.numeric.value.erlang
        7: constant.numeric.base.erlang
        8: constant.numeric.value.erlang
        9: constant.numeric.base.erlang
        10: constant.numeric.value.erlang
        11: constant.numeric.base.erlang
        12: constant.numeric.value.erlang
        13: constant.numeric.base.erlang
        14: constant.numeric.value.erlang
        15: constant.numeric.base.erlang
        16: constant.numeric.value.erlang
        17: constant.numeric.base.erlang
        18: constant.numeric.value.erlang
        19: constant.numeric.base.erlang
        20: constant.numeric.value.erlang
        21: constant.numeric.base.erlang
        22: constant.numeric.value.erlang
        23: constant.numeric.base.erlang
        24: constant.numeric.value.erlang
        25: constant.numeric.base.erlang
        26: constant.numeric.value.erlang
        27: constant.numeric.base.erlang
        28: constant.numeric.value.erlang
        29: constant.numeric.base.erlang
        30: constant.numeric.value.erlang
        31: constant.numeric.base.erlang
        32: constant.numeric.value.erlang
        33: constant.numeric.base.erlang
        34: constant.numeric.value.erlang
        35: constant.numeric.base.erlang
        36: constant.numeric.value.erlang
        37: constant.numeric.base.erlang
        38: constant.numeric.value.erlang
        39: constant.numeric.base.erlang
        40: constant.numeric.value.erlang
        41: constant.numeric.base.erlang
        42: constant.numeric.value.erlang
        43: constant.numeric.base.erlang
        44: constant.numeric.value.erlang
        45: constant.numeric.base.erlang
        46: constant.numeric.value.erlang
        47: constant.numeric.base.erlang
        48: constant.numeric.value.erlang
        49: constant.numeric.base.erlang
        50: constant.numeric.value.erlang
        51: constant.numeric.base.erlang
        52: constant.numeric.value.erlang
        53: constant.numeric.base.erlang
        54: constant.numeric.value.erlang
        55: constant.numeric.base.erlang
        56: constant.numeric.value.erlang
        57: constant.numeric.base.erlang
        58: constant.numeric.value.erlang
        59: constant.numeric.base.erlang
        60: constant.numeric.value.erlang
        61: constant.numeric.base.erlang
        62: constant.numeric.value.erlang
    - match: \d+\#\S+
      scope: invalid.illegal.integer.erlang
    - match: \d[\d_]*\b
      scope: meta.number.integer.decimal.erlang constant.numeric.value.erlang
    - match: \d\w+
      scope: invalid.illegal.integer.erlang

  string:
    # https://www.erlang.org/doc/reference_manual/data_types.html#string
    - match: \"
      scope: punctuation.definition.string.begin.erlang
      push: string-body

  string-body:
    - meta_include_prototype: false
    - meta_scope: string.quoted.double.erlang
    - match: \"
      scope: punctuation.definition.string.end.erlang
      pop: 1
    - match: (?=\\)
      push: escape
    # https://www.erlang.org/doc/man/io.html
    # The general format of a control sequence is ~F.P.PadModC.
    - match: |-
        (?x:
          (~)
          (?: (\-?\*) | (\-?\d+) )?  # F - field width
          (?:
            (\.) (?: (\*) | (\d+) )? # P - precision
            (?: (\.) (.) )?          # Pad - padding character
          )?
          ([lt]{0,2})                # Mod - control modifier
          ([~cfegswpWPBX#bx\+ni])    # C - control sequence
        )
      captures:
        1: constant.other.placeholder.erlang punctuation.definition.placeholder.erlang
        2: constant.other.placeholder.width.asterisk.erlang
        3: constant.other.placeholder.width.integer.erlang
        4: constant.other.placeholder.precision.erlang punctuation.separator.placeholder.erlang
        5: constant.other.placeholder.precision.asterisk.erlang
        6: constant.other.placeholder.precision.integer.erlang
        7: constant.other.placeholder.separator.erlang punctuation.separator.placeholder.erlang
        8: constant.other.placeholder.padding.character.erlang
        9: constant.other.placeholder.control.modifier.erlang
        10: constant.other.placeholder.control.character.erlang

  string-maybe-env:
    - match: (\$){{ident_unquoted}}
      scope: variable.language.environment.erlang
      captures:
        1: punctuation.definition.variable.erlang
      pop: 1
    - include: else-pop

###[ OPERATORS ]##############################################################

  operator-comprehension:
    - match: \|\|
      scope: keyword.operator.comprehension.erlang

  operator-unary:
    # https://www.erlang.org/doc/reference_manual/expressions.html#list-comprehensions
    - match: <=|<-
      scope: keyword.operator.generator.erlang
    # https://www.erlang.org/doc/reference_manual/expressions.html#term-comparisons
    - match: =/=|=:=|/=|==|=<|>=|=!|>|<
      scope: keyword.operator.comparison.erlang
    # https://www.erlang.org/doc/reference_manual/expressions.html#list-operations
    - match: \+\+|--
      scope: keyword.operator.lists.erlang
    # https://www.erlang.org/doc/reference_manual/expressions.html#arithmetic-expressions
    - match: '[-+*/]'
      scope: keyword.operator.arithmetic.erlang
    - match: '[=!]'
      scope: keyword.operator.assignment.erlang

  operator:
    # https://www.erlang.org/doc/reference_manual/expressions.html#arithmetic-expressions
    - match: (div|rem){{ident_break}}
      scope: keyword.operator.arithmetic.erlang
    - match: (band|bor|bxor|bnot|bsl|bsr){{ident_break}}
      scope: keyword.operator.bitwise.erlang
    # https://www.erlang.org/doc/reference_manual/expressions.html#boolean-expressions
    # https://www.erlang.org/doc/reference_manual/expressions.html#short-circuit-expressions
    - match: (and|or|xor|not|andalso|orelse){{ident_break}}
      scope: keyword.operator.logical.erlang

###[ SEPARATORS ]#############################################################

  separator-clauses:
    - match: ';'
      scope: punctuation.separator.clauses.erlang

  separator-expressions:
    - match: ','
      scope: punctuation.separator.expressions.erlang

  separator-sequence:
    - match: ','
      scope: punctuation.separator.sequence.erlang

  separator-type:
    - match: \.\.
      scope: punctuation.separator.range.erlang
    - match: '::'
      scope: punctuation.separator.variable-type.erlang

  separator-union:
    - match: \|
      scope: punctuation.separator.sequence.erlang

  terminator-clause:
    - match: \.
      scope: punctuation.terminator.clause.erlang

  terminator-clause-pop:
    - match: \.
      scope: punctuation.terminator.clause.erlang
      pop: 1

###[ ARGUMENTS ]##############################################################

  arguments-common:
    - include: arguments-end
    - match: ','
      scope: punctuation.separator.arguments.erlang

  arguments-end:
    - match: \)
      scope: punctuation.section.arguments.end.erlang
      pop: 1
    - include: clause-end-or-stray

  expect-arguments-end:
    - include: arguments-end
    - include: illegal-group
    - match: \S
      scope: invalid.illegal.expect-arguments-end.erlang

  expect-arguments-separator:
    - match: ','
      scope: punctuation.separator.arguments.erlang
      pop: 1
    - match: \s+(?!,)
      scope: invalid.illegal.expect-separator.erlang
      pop: 1
    - include: else-pop

###[ CONTEXT POP OFFS ]#######################################################

  parameters-common:
    - match: \)
      scope: punctuation.section.parameters.end.erlang
      pop: 1
    - match: ','
      scope: punctuation.separator.parameters.erlang
    - include: clause-end-or-stray

  parameters-end-pop:
    # bailout from parameter lists if guard or clause body starts
    - match: (?=->|when{{ident_break_char}})
      pop: 1

  immediatelly-pop:
    - match: ''
      pop: 1

  eol-pop:
    - match: $
      pop: 1

  else-pop:
    - match: (?=\S)
      pop: 1

  clause-end-pop:
    - match: (?=[.;])
      pop: 1

  clause-end-or-stray:
    - include: clause-end-pop
    - include: illegal-stray

  value-end-pop:
    # a `value body` ends with
    # - the end of a clause (`;` or `.`)
    # - the end of a clause body (`end`, `after`, `catch`)
    # - the end of a section (`)`, `]`, `}`)
    # - an separator (`,`, `:`)
    - match: (?=->|[,:.;)}\]]|(end|after|catch){{ident_break_char}})
      pop: 1

###[ ILLEGALS ]###############################################################

  illegal-group:
    # Note: To try to prevent breaking highlighting it is important to keep
    #       parens/brackets/braces in balance if the opening bracket is not
    #       expected at its current position and marked illegal.
    - match: \(
      push:
        - meta_scope: invalid.illegal.unexpected-group.erlang
        - match: \)
          pop: 1
        - include: illegal-group-body
    - match: \[
      push:
        - meta_scope: invalid.illegal.unexpected-list.erlang
        - match: \]
          pop: 1
        - include: illegal-group-body
    - match: \#?\{
      push:
        - meta_scope: invalid.illegal.unexpected-tuple.erlang
        - match: \}
          pop: 1
        - include: illegal-group-body

  illegal-group-body:
    # consume numbers to prevent matching decimal separater as clause-end
    - match: \d+\.\d*|\.\d+
    - include: clause-end-pop
    - match: \(
      push:
        - match: \)
          pop: 1
        - include: illegal-group-body
    - match: \[
      push:
        - match: \]
          pop: 1
        - include: illegal-group-body
    - match: \#?\{
      push:
        - match: \}
          pop: 1
        - include: illegal-group-body

  illegal-stray:
    - match: '[)\]}]'
      scope: invalid.illegal.stray.erlang
