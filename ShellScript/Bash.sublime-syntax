%YAML 1.2
---
# https://www.sublimetext.com/docs/syntax.html
# https://www.gnu.org/software/bash/manual/bash.html
name: Bash
scope: source.shell.bash
version: 2

extends: Packages/ShellScript/commands-builtin-shell-bash.sublime-syntax

file_extensions:
  - sh
  - bash
  - ash
  - zsh

hidden_file_extensions:
  - .bash_aliases
  - .bash_completions
  - .bash_functions
  - .bash_login
  - .bash_logout
  - .bash_profile
  - .bash_variables
  - .bashrc
  - .ebuild
  - .eclass
  - .profile
  - .textmate_init
  - .zlogin
  - .zlogout
  - .zprofile
  - .zshenv
  - .zshrc
  - PKGBUILD  # https://jlk.fjfi.cvut.cz/arch/manpages/man/PKGBUILD.5

first_line_match: |-
  (?x:
    ^\#! .* \b(bash|zsh|sh|tcsh|ash)\b |        # shebang
    ^\# \s* -\*- [^*]* shell-script [^*]* -\*-  # editorconfig
  )

###############################################################################

variables:
  is_interpolation: (?=\$([\d({]|[$#@!~*?_-](?!\w)|{{identifier}})|`)
  is_variable: (?=\s*{{variable_first_char}}{{nbc}}(?:[({]{{nbc}}[)}])?{{nbc}}=)

  # posix identifiers (alpha-numeric)
  identifier: '{{identifier_first_char}}{{identifier_char}}*'
  identifier_first_char: '[[:alpha:]_]'
  identifier_char: '[[:alnum:]_]'
  identifier_break: (?!{{identifier_char}})

  # non-posix identifiers
  nonposix: '{{nonposix_first_char}}{{nonposix_char}}*{{nonposix_break}}'
  nonposix_first_char: '[^{{metachar}}\d]'
  nonposix_char: '[^{{metachar}}=]'
  nonposix_begin: (?={{nonposix_first_char}})
  nonposix_break: (?={{metachar}}|{{varassign}}|$)

  # Commands literals are command names without interpolation or quotation.
  cmd_literal: '{{cmd_literal_first_char}}{{cmd_literal_char}}*{{cmd_break}}'
  cmd_literal_first_char: '[^{{metachar}}%$\\""''`\d]'
  cmd_literal_char: '[^{{metachar}}%$\\""''`]'

  # Command names are non-posix identifiers, which don't stop at assignment operators.
  cmd_begin: (?={{nonposix_first_char}})
  cmd_break: (?!{{cmd_char}})
  cmd_char: '[^{{metachar}}]'

  # Command options are identifiers, which may start with interpolation.
  opt_punctuation: (?:\s+|^)(--|[-+]){{variable_begin}}
  opt_break: '{{nonposix_break}}'

  # Variables are posix identifiers, which may start with interpolation.
  variable_begin: (?={{variable_first_char}}|\$)
  variable_first_char: '{{identifier_first_char}}'

  # A character that, when unquoted, separates words. A metacharacter is a
  # space, tab, newline, or one of the following characters: ‘|’, ‘&’, ‘;’,
  # ‘(’, ‘)’, ‘<’, or ‘>’.
  metachar: '[\s|&;()<>]'

  nbc: '[^{}()=\s]*' # non bracket characters (and also non-whitespace, parens)
  varassign: '[-+]?='

###############################################################################

contexts:
  main:
    # - match: ''
    #   push: [statements, shebang]
    - include: statements

  statements:
    - include: comments
    - include: line-continuations
    - include: operator-exclamation
    - include: operator-logical
    - include: redirection
    - include: cmd-arithmetic
    - include: cmd-compound
    - include: cmd-test
    - include: cmd-control
    - include: cmd-coproc
    - include: cmd-unset
    - include: cmd-builtins
    - include: vardef
    - include: funcdef
    - include: cmd-other

  statement:
    - include: statements
    - include: eol-pop

###[ PROTOTYPES ]##############################################################

  else-pop:
    - match: (?=\S)
      pop: 1

  eol-pop:
    - match: $|(?=\s+#)
      pop: 1
    - include: line-continuations

  eol-pop2:
    - match: $|(?=\s+#)
      pop: 2
    - include: line-continuations

  immediately-pop:
    - match: ''
      pop: 1

  immediately-pop2:
    - match: ''
      pop: 2

###[ COMMENTS ]################################################################

  comments:
    - match: \#+
      scope: punctuation.definition.comment.shell
      push: comments-body

  comments-body:
    - meta_scope: comment.line.number-sign.shell
    # NOTE: The reason for consuming the newline character is as follows.
    # When triggering a snippet, its scope is tested to the *right* of the
    # cursor. So, if you don't want your snippet to trigger in a comment,
    # you have to use something like <scope>source.shell - comment</scope>.
    # If the newline character is not scoped as a comment too, then that
    # scope will never work, because the scope to the right of the cursor
    # will never be a comment scope. That is, unless we consume the newline
    # character (or we are editing something in the middle of an existing
    # comment).
    - match: \n
      pop: 1
    - include: line-continuations

  shebang:
    - match: ^\#!
      scope: punctuation.definition.comment.shell
      set: shebang-body
    - match: ^|(?=\S)  # Note: Ensure to highlight shebang if Bash is embedded.
      pop: 1

  shebang-body:
    - meta_scope: comment.line.shebang.shell
    # Note: Keep sync with first_line_match!
    - match: \b(bash|zsh|sh|tcsh|ash)\b
      scope: constant.language.shebang.shell
    - match: \n
      pop: 1
    - include: line-continuations

###[ COPROCESSES ]#############################################################

  cmd-coproc:
    - match: coproc{{cmd_break}}
      scope:
        meta.coproc.shell
        storage.type.coproc.shell
        keyword.declaration.coproc.shell
      push: cmd-coproc-identifier

  cmd-coproc-identifier:
    - match: (\s*({{cmd_literal}})\s*)(\{)
      captures:
        1: meta.coproc.identifier.shell
        2: entity.name.coproc.shell
        3: meta.coproc.command.shell meta.compound.shell
           punctuation.section.compound.begin.shell
      set:
        - cmd-coproc-compound-meta
        - cmd-coproc-compound-command
    - match: ''
      set: cmd-coproc-basic-command

  cmd-coproc-basic-command:
    - meta_scope: meta.coproc.command.shell
    - include: statement

  cmd-coproc-compound-meta:
    - meta_scope: meta.coproc.command.shell
    - include: immediately-pop

  cmd-coproc-compound-command:
    - meta_content_scope: meta.compound.shell
    - match: \}
      scope:
        meta.compound.shell
        punctuation.section.compound.end.shell
      set: cmd-compound-args
    - include: statements

###[ FUNCTIONS ]###############################################################

  funcdef:
    # [Bash] 3.3 Shell Functions
    - match: (?=\s*{{cmd_literal}}\s*\(\s*\))
      push:
        - funcdef-redirection
        - funcdef-body
        - funcdef-params
        - funcdef-name
    - match: function{{cmd_break}}
      scope:
        meta.function.shell
        storage.type.function.shell
        keyword.declaration.function.shell
      push:
        - funcdef-redirection
        - funcdef-body
        - funcdef-params
        - funcdef-name

  funcdef-name:
    - match: '{{cmd_begin}}'
      set: funcdef-name-chars
    - include: else-pop
    - include: eol-pop

  funcdef-name-chars:
    - match: '{{cmd_literal_char}}+'
      scope: entity.name.function.shell
    - include: variable-expansions
    - include: expansion-job
    - include: immediately-pop

  funcdef-params:
    - clear_scopes: 1
    - meta_content_scope: meta.function.identifier.shell
    - match: (\()\s*(\))
      scope: meta.function.parameters.shell
      captures:
        1: punctuation.section.parameters.begin.shell
        2: punctuation.section.parameters.end.shell
      pop: 1
    - include: else-pop

  funcdef-body:
    - match: \{  # Bash expects `{{cmd_break}}` but we don't care.
      scope: punctuation.section.compound.begin.shell
      set:
        - meta_scope: meta.compound.shell
        - match: \}
          scope: punctuation.section.compound.end.shell
          pop: 1
        - include: statements
    - match: \(
      scope: punctuation.section.compound.begin.shell
      set:
        - meta_scope: meta.compound.shell
        - match: \)
          scope: punctuation.section.compound.end.shell
          pop: 1
        - include: statements
    - include: comments
    - include: else-pop

  funcdef-redirection:
    - meta_content_scope: meta.function.shell
    - include: redirection
    - include: else-pop
    - include: eol-pop

###[ VARDEFS ]#################################################################

  vardef:
    - match: alias{{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.alias.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-alias-name
        - vardef-alias-options
    - match: (typeset|declare|local){{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        storage.modifier.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-name
        - vardef-declare-options
    - match: export{{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        storage.modifier.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-name
        - vardef-export-options
    - match: readonly{{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        storage.modifier.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-name
        - vardef-readonly-options
    - match: '{{is_variable}}'
      push:
        - vardef-value
        - vardef-assign
        - vardef-name

  vardef-maybe-more:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: cmd-args-boilerplate-with-end-of-options
    - match: (?=\S)
      push: [vardef-value, vardef-assign, vardef-name]

  vardef-alias-name:
    - match: '{{variable_begin}}'
      set: [vardef-item-access, vardef-alias-name-chars]
    - include: else-pop
    - include: eol-pop

  vardef-alias-name-chars:
    - match: '{{identifier_char}}+'
      scope: entity.name.function.alias.shell
    - include: variable-expansions
    - include: immediately-pop

  vardef-alias-options:
    - match: ([-+])p{{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: vardef-end-of-options

  vardef-declare-options:
    - match: ([-+])(?:[aAfFgilnrtux]+|p){{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: vardef-end-of-options

  vardef-export-options:
    - match: ([-+])(?:[fn]+|p){{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: vardef-end-of-options

  vardef-readonly-options:
    - match: ([-+])(?:[aAf]+|p){{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: vardef-end-of-options

  vardef-end-of-options:
    - match: --{{cmd_break}}
      scope: keyword.operator.end-of-options.shell
      pop: 1
    - match: (--|[-+]){{identifier}}
      scope: invalid.illegal.parameter.shell
    - include: else-pop
    - include: eol-pop

  vardef-name:
    - match: '{{variable_begin}}'
      set: [vardef-item-access, vardef-name-chars]
    - include: else-pop
    - include: eol-pop

  vardef-name-chars:
    - match: '{{identifier_char}}+'
      scope: variable.other.readwrite.shell
    - include: variable-expansions
    - include: immediately-pop

  vardef-item-access:
    - meta_scope: meta.variable.shell
    - include: array
    - include: line-continuations    
    - include: immediately-pop

  vardef-assign:
    - match: '{{varassign}}'
      scope: keyword.operator.assignment.shell
      pop: 1
    - include: line-continuations
    - include: immediately-pop

  vardef-value:
    - match: \(
      scope: punctuation.section.sequence.begin.shell
      set:
        - meta_scope: meta.sequence.shell
        - match: \)
          scope: punctuation.section.sequence.end.shell
          pop: 1
        - match: \[
          scope: punctuation.section.brackets.begin.shell
          push:
            - meta_scope: meta.brackets.shell
            - match: \]
              scope: punctuation.section.brackets.end.shell
              set:
                - match: =
                  scope: keyword.operator.assignment.shell
                  pop: 1
                - include: immediately-pop
            - include: expansion-and-string
            - include: comments
        - include: expansion-and-string
        - include: comments
    - match: ''
      set:
        - meta_scope: meta.string.shell string.unquoted.shell
        - match: (?=\$?["'])
          push:
            - clear_scopes: 2
            - include: string
            - include: immediately-pop
        - match: '{{is_interpolation}}'
          push:
            - clear_scopes: 1
            - include: expansion
            - include: immediately-pop
        - include: any-escapes
        - include: line-continuations
        - match: '{{cmd_break}}'
          pop: 1

###[ UNSET BUILTIN ]###########################################################

  cmd-unset:
    - match: unset{{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.unset.shell
      push:
        - cmd-unset-args-meta
        - cmd-unset-args

  cmd-unset-args-meta:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: immediately-pop

  cmd-unset-args:
    - match: ([-+])(?:[nv]?f[nv]?){{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
      set: cmd-unset-options-then-functions
    - include: cmd-unset-options-then-variables

  cmd-unset-options:
    - match: ([-+])(?:[nv]+){{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - match: (--|[-+]){{identifier}}
      scope: invalid.illegal.parameter.shell
    - include: eol-pop

  cmd-unset-options-then-functions:
    - include: cmd-unset-options
    - match: --{{cmd_break}}
      scope: keyword.operator.end-of-options.shell
      set: cmd-unset-functions
    - match: (?=\S)
      set: cmd-unset-functions

  cmd-unset-functions:
    - include: cmd-args-boilerplate
    - match: '{{cmd_begin}}'
      push: cmd-unset-functions-chars

  cmd-unset-functions-chars:
    - meta_scope: meta.variable.shell
    - match: '{{identifier_char}}+'
      scope: variable.function.shell
    - include: variable-expansions
    - include: immediately-pop

  cmd-unset-options-then-variables:
    - include: cmd-unset-options
    - match: --{{cmd_break}}
      scope: keyword.operator.end-of-options.shell
      set: cmd-unset-variables
    - match: (?=\S)
      set: cmd-unset-variables

  cmd-unset-variables:
    - include: cmd-args-boilerplate
    - match: '{{variable_begin}}'
      push: cmd-unset-variables-chars

  cmd-unset-variables-chars:
    - meta_scope: meta.variable.shell
    - match: '{{identifier_char}}+'
      scope: variable.other.readwrite.shell
    - include: variable-expansions
    - include: immediately-pop

###[ COMMANDS ]################################################################

  cmd-arithmetic:
    - include: arithmetic
    - match: let{{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.let.shell
      push: cmd-arithmetic-args

  cmd-arithmetic-args:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: cmd-args-boilerplate-with-end-of-options
    - include: expression

  cmd-compound:
    - match: \(
      scope: punctuation.section.compound.begin.shell
      push:
        - meta_scope: meta.compound.shell
        - match: \)
          scope: punctuation.section.compound.end.shell
          set: cmd-compound-args
        - include: statements
    - match: \{{{cmd_break}}
      scope: punctuation.section.compound.begin.shell
      push:
        - meta_scope: meta.compound.shell
        - match: \}
          scope: punctuation.section.compound.end.shell
          set: cmd-compound-args
        - include: statements

  cmd-compound-args:
    - meta_content_scope: meta.compound.arguments.shell
    - include: cmd-args

  cmd-test:
    - match: \[\[(?=\s)
      scope: support.function.double-brace.begin.shell
      push:
        - meta_scope: meta.conditional.shell
        - match: \s+(\]\])
          captures:
            1: support.function.double-brace.end.shell
          pop: 1
        - include: expression-test
    - match: \[(?=\s)
      scope: support.function.test.begin.shell
      push:
        - meta_scope: meta.conditional.shell
        - match: \s+(\])
          captures:
            1: support.function.test.end.shell
          pop: 1
        - include: expression-test
    - match: test{{cmd_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.test.shell
      push: cmd-test-args

  cmd-test-args:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: cmd-args-boilerplate
    - include: expression-test

  cmd-other:
    - match: '{{cmd_begin}}'
      push: [cmd-args, cmd-name]

  cmd-name:
    - clear_scopes: 1
    - meta_scope: meta.function-call.identifier.shell
    - match: '{{cmd_literal_char}}+'
      scope: variable.function.shell
    - include: variable-expansions
    - include: expansion-job
    - include: immediately-pop

  cmd-args:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: cmd-args-boilerplate-with-end-of-options
    - match: '{{opt_punctuation}}'
      captures:
        1: variable.parameter.option.shell
           punctuation.definition.parameter.shell
      push:
        - meta_content_scope: variable.parameter.option.shell
        - match: =
          scope: keyword.operator.assignment.shell
          pop: 1
        - match: '{{opt_break}}'
          pop: 1
        - include: expansion-and-string

  cmd-args-boilerplate:
    # NOTE: this context is used in commands-builtin-shell-bash.sublime-syntax
    - include: expansion-and-string
    - include: redirection
    - include: eol-pop
    - match: (?=[)}]|\s*([|;]|&(?!>)))
      pop: 1

  cmd-args-boilerplate-with-end-of-options:
    # NOTE: this context is used in commands-builtin-shell-bash.sublime-syntax
    - match: (?:\s+|^)(--){{cmd_break}}
      captures:
        1: keyword.operator.end-of-options.shell
      push: cmd-args-after-options
    - include: cmd-args-boilerplate

  cmd-args-after-options:
    - include: expansion-and-string
    - include: redirection
    - include: eol-pop2
    - match: (?=[)};&|])
      pop: 2

###[ CONTROL STATEMENTS ]######################################################

  cmd-control:
    # conditional
    - match: if{{cmd_break}}
      scope: keyword.control.conditional.if.shell
    - match: then{{cmd_break}}
      scope: keyword.control.conditional.then.shell
    - match: elif{{cmd_break}}
      scope: keyword.control.conditional.elseif.shell
    - match: fi{{cmd_break}}
      scope: keyword.control.conditional.end.shell
    - match: else{{cmd_break}}
      scope: keyword.control.conditional.else.shell
    - match: case{{cmd_break}}
      scope: keyword.control.conditional.case.shell
      push: [case-body, case-word]
    - match: esac{{cmd_break}}
      scope: keyword.control.conditional.end.shell
    # loops
    - match: do{{cmd_break}}
      scope: keyword.control.loop.do.shell
    - match: done{{cmd_break}}
      scope: keyword.control.loop.end.shell
    - match: for{{cmd_break}}
      scope: keyword.control.loop.for.shell
      push: for-args
    - match: select{{cmd_break}}
      scope: keyword.control.loop.select.shell
      push: select-args
    - match: until{{cmd_break}}
      scope: keyword.control.loop.until.shell
    - match: while{{cmd_break}}
      scope: keyword.control.loop.while.shell
    # flow
    - match: break{{cmd_break}}
      scope: keyword.control.flow.break.shell
      push: flow-args
    - match: continue{{cmd_break}}
      scope: keyword.control.flow.continue.shell
      push: flow-args
    - match: exit{{cmd_break}}
      scope: keyword.control.flow.exit.shell
      push: flow-args
    - match: return{{cmd_break}}
      scope: keyword.control.flow.return.shell
      push: flow-args

  case-word:
    - match: in{{cmd_break}}
      scope: keyword.control.in.shell
      pop: 1
    - include: comments
    - include: case-end-ahead
    - include: expansion-and-string

  case-body:
    - meta_scope: meta.conditional.case.shell
    - include: comments
    - include: case-end
    - match: \(|(?=\S)
      scope: keyword.control.conditional.patterns.begin.shell
      push:
        - case-clause-commands
        - case-clause-patterns

  case-clause-patterns:
    - clear_scopes: 1  # remove meta.conditional.case.shell
    - meta_scope: meta.conditional.case.clause.patterns.shell
    - match: \)
      scope: keyword.control.conditional.patterns.end.shell
      pop: 1
    # emergency bail outs if ')' is missing
    - match: (?=;;&?|;&)
      pop: 1
    - include: case-clause-patterns-body

  case-clause-patterns-body:
    # [Bash] 3.2.4.2: Each pattern undergoes tilde expansion, parameter
    # expansion, command substitution, and arithmetic expansion.
    - match: \(
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.shell
        - match: \)
          scope: punctuation.section.group.end.shell
          pop: 1
        - include: case-clause-patterns-body
    - match: \|
      scope: keyword.operator.logical.shell
    - include: case-end-ahead
    - include: variable-expansions
    - include: expansion-pattern
    - include: eol-pop

  case-clause-commands:
    - clear_scopes: 1  # remove meta.conditional.case.shell
    - meta_scope: meta.conditional.case.clause.commands.shell
    - match: ;;&?|;&
      scope: punctuation.terminator.case.clause.shell
      pop: 1
    - include: case-end-ahead
    - include: statements

  case-end-ahead:
    - match: (?=esac{{cmd_break}})
      pop: 1

  case-end:
    - match: esac{{cmd_break}}
      scope: keyword.control.conditional.end.shell
      pop: 1

  flow-args:
    - include: number
    - include: cmd-args-boilerplate

  for-args:
    - include: cmd-args-boilerplate
    - include: arithmetic
    - match: in{{cmd_break}}
      scope: keyword.control.in.shell

  select-args:
    - include: cmd-args-boilerplate
    - include: expansion-and-string
    - match: in{{cmd_break}}
      scope: keyword.control.in.shell

###[ REDIRECTIONS AND HEREDOCS ]###############################################

  redirection:
    - include: redirection-here-string
    - include: redirection-here-document
    - include: redirection-process
    - include: redirection-input
    - include: redirection-output
    - include: redirection-inout

  redirection-process:
    - match: (\d*)([<>])(\()
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.process.shell
        3: meta.compound.shell
           punctuation.section.compound.begin.shell
      push:
        - meta_content_scope: meta.compound.shell
        - match: \)
          scope:
            meta.compound.shell
            punctuation.section.compound.end.shell
          pop: 1
        - include: statements

  redirection-output:
    - match: (\d*)(>>!?|>&?|&>|&?>[|>])
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
      push: redirection-post

  redirection-input:
    - match: (\d*)(<&?)
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
      push: redirection-post

  redirection-post:
    - match: \s*(?:(\d+)|(-))
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: punctuation.terminator.file-descriptor.shell
      pop: 1
    - match: \s*(?=\S)
      set:
        - match: '{{cmd_break}}'
          pop: 1
        - include: expansion-and-string
    - match: \s*
      pop: 1

  redirection-inout:
    - match: (\d*)(<>)
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell

  redirection-here-string:
    - match: (\d*)(<<<)\s*{{nonposix_begin}}
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.herestring.shell

  redirection-here-document:
    # These are the variants that allow tabs before the end token
    - match: (\d*)(<<-)\s*(')({{identifier}})(')
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*(")({{identifier}})(")
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*(\\)({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.shell
        4: keyword.control.heredoc-token.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: keyword.control.heredoc-token.shell
      push: [heredocs-body-allow-tabs, heredocs-preamble]
    # These are the variants that DON'T allow tabs before the end token
    - match: (\d*)(<<)\s*(')({{identifier}})(')
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*(")({{identifier}})(")
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*(\\)({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.shell
        4: keyword.control.heredoc-token.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: keyword.control.heredoc-token.shell
      push: [heredocs-body, heredocs-preamble]

  heredocs-body:
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - include: heredocs-body-common-with-expansion
    - match: ^\3(\s+)\n # the third capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\3$ # the third capture from redirection-here-document
      scope: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-body-allow-tabs:
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - include: heredocs-body-common-with-expansion
    - match: ^\s*\3(\s+)\n # the third capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\s*(\3)$ # the third capture from redirection-here-document
      captures:
        1: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-body-common-with-expansion:
    # [Bash] 3.6.6: all lines of the here-document are subjected to parameter
    # expansion, command substitution, and arithmetic expansion, the character
    # sequence \newline is ignored, and ‘\’ must be used to quote the
    # characters ‘\’, ‘$’, and ‘`’.
    - include: string-escapes
    - include: string-interpolations

  heredocs-body-no-expansion:
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - match: ^\4(\s+)\n # the fourth capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\4$ # the fourth capture from redirection-here-document
      scope: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-body-allow-tabs-no-expansion:
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - match: ^\s*\4(\s+)\n # the fourth capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\s*(\4)$ # the fourth capture from redirection-here-document
      captures:
        1: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-preamble:
    - match: ''
      set:
        # This enables us to keep parsing on the line where the start token of
        # the heredoc is. Once the first line has ended, we enter the body of
        # the heredoc, where everything is just an unquoted string.
        # One clear_scope for the string.unquoted.
        # The problem with this is that when we also end a function definition
        # on the same line (with the "}" token), we cannot do that.
        - clear_scopes: 1
        - include: eol-pop
        - match: \s*(?=\S)
          set: [statement, cmd-args]

###[ EXPRESSIONS ]#############################################################

  array:
    - match: \[
      scope: punctuation.section.item-access.begin.shell
      push:
        - meta_scope: meta.item-access.shell
        - match: \]
          scope: punctuation.section.item-access.end.shell
          pop: 1
        - match: '[*@]'
          scope: variable.language.array.shell
        - include: expression

  arithmetic:
    - match: \(\((?=.+\)\))
      scope: punctuation.section.arithmetic.begin.shell
      push:
        - meta_scope: meta.arithmetic.shell
        - match: \)\)
          scope: punctuation.section.arithmetic.end.shell
          pop: 1
        - include: expression

  expression:
    - match: \(
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.shell
        - match: \)
          scope: punctuation.section.group.end.shell
          pop: 1
        - include: expression
    # multi char operators
    - match: '[-+*/%&|^]=|<<=|>>='
      scope: keyword.operator.assignment.augmented.shell
    - match: '<<|>>'
      scope: keyword.operator.bitwise.shell
    - match: '<=?|>=?|[=!]='
      scope: keyword.operator.comparison.shell
    - match: '&&|\|\||!'
      scope: keyword.operator.logical.shell
    # single char operators
    - match: '[-+*/%]'
      scope: keyword.operator.arithmetic.shell
    - match: '='
      scope: keyword.operator.assignment.shell
    - match: '[&|^~]'
      scope: keyword.operator.bitwise.shell
    - match: ;
      scope: punctuation.separator.expressions.shell
    - match: \,
      scope: punctuation.separator.sequence.shell
    - match: \:|\?
      scope: keyword.operator.ternary.shell
    # Shell variables are allowed as operands; parameter expansion is performed
    # before the expression is evaluated. Within an expression, shell variables
    # may also be referenced by name without using the parameter expansion
    # syntax.
    - include: numbers
    - include: string
    - include: expansion-parameter
    - include: expansion-arithmetic
    - include: expansion-command

  expression-test:
    - match: \(
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.shell
        - match: \)
          scope: punctuation.section.group.end.shell
          pop: 1
        - include: expression-test
    - match: ([-+])[aobcdefghknoprstuvwxzGLNORS]{{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - match: ([-+])(?:ef|nt|ot|eq|ne|lt|le|gt|ge){{opt_break}}
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - match: (=~)\s*
      captures:
        1: keyword.operator.logical.shell
      push:
        - meta_content_scope: meta.regexp.shell
        - match: (?=\s)
          pop: 1
        - include: expansion-and-string
    - match: '<=?|>=?|[=!]='
      scope: keyword.operator.comparison.shell
    - match: '&&|\|\||!'
      scope: keyword.operator.logical.shell
    - match: '='
      scope: keyword.operator.assignment.shell
    - include: numbers
    - include: expansion-and-string

  numbers:
    # A leading ‘0x’ or ‘0X’ denotes hexadecimal.
    - match: \b(0[xX])(\h*)
      captures:
        1: meta.number.base.shell constant.numeric.integer.hexadecimal.shell
        2: meta.number.value.shell constant.numeric.integer.hexadecimal.shell
    # Constants with a leading 0 are interpreted as octal numbers.
    - match: \b(0)([0-7]+)
      captures:
        1: meta.number.base.shell constant.numeric.integer.octal.shell
        2: meta.number.value.shell constant.numeric.integer.octal.shell
    # Otherwise, numbers take the form [base#]n, where the optional base is a
    # decimal number between 2 and 64 representing the arithmetic base, and n is
    # a number in that base. When specifying n, the digits greater than 9 are
    # represented by the lowercase letters, the uppercase letters, ‘@’, and ‘_’,
    # in that order.
    - match: \b(\d+#)([a-zA-Z0-9@_]+)
      captures:
        1: meta.number.base.shell constant.numeric.integer.other.shell
        2: meta.number.value.shell constant.numeric.integer.other.shell
    # If base# is omitted, then base 10 is used.
    - match: \b\d+
      scope: meta.number.value.shell constant.numeric.integer.decimal.shell

  number:
    - match: ([-+]?)(0[xX])(\h*)\w*
      captures:
        1: keyword.operator.arithmetic.shell
        2: meta.number.base.shell constant.numeric.integer.hexadecimal.shell
        3: meta.number.value.shell constant.numeric.integer.hexadecimal.shell
      pop: 1
    - match: ([-+]?)(0)([0-7]+)\w*
      captures:
        1: keyword.operator.arithmetic.shell
        2: meta.number.base.shell constant.numeric.integer.octal.shell
        3: meta.number.value.shell constant.numeric.integer.octal.shell
      pop: 1
    - match: ([-+]?)(\d+#)([a-zA-Z0-9@_]+)
      captures:
        1: keyword.operator.arithmetic.shell
        2: meta.number.base.shell constant.numeric.integer.other.shell
        3: meta.number.value.shell constant.numeric.integer.other.shell
    # If base# is omitted, then base 10 is used.
    - match: ([-+]?)(\d+)\b
      captures:
        1: keyword.operator.arithmetic.shell
        2: meta.number.value.shell constant.numeric.integer.decimal.shell
      pop: 1

###[ OPERATORS ]###############################################################

  line-continuations:
    - match: \\\n
      scope: punctuation.separator.continuation.line.shell
      push:
        - match: ^
          pop: 1
    - match: \\(\s+)\n
      captures:
        1: invalid.illegal.extraneous-spaces-after-line-continuations.shell

  operator-exclamation:
    - match: \!(?!\S)
      scope: keyword.operator.logical.shell
    - match: (\!)(-?\d+|!)
      scope: variable.language.history.shell
      captures:
        1: punctuation.definition.history.shell
    - match: \!
      scope: punctuation.definition.history.shell

  operator-logical:
    - match: ;
      scope: keyword.operator.logical.continue.shell
    - match: \|\|
      scope: keyword.operator.logical.or.shell
    - match: \|
      scope: keyword.operator.logical.pipe.shell
    - match: \&\&
      scope: keyword.operator.logical.and.shell
    - match: \&
      scope: keyword.operator.logical.job.shell

###[ EXPANSIONS ]##############################################################

  variable-expansions:
    - include: line-continuations
    - include: string
    - include: expansion-parameter
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde

  expansion-and-string:
    - include: string
    - include: expansion

  expansion:
    - include: expansion-pattern
    - include: expansion-parameter
    - include: expansion-brace
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde
    - include: expansion-job

  expansion-arithmetic:
    - match: \$\(\((?=.+\)\))
      scope: punctuation.section.interpolation.begin.shell
      push:
        - meta_scope: meta.interpolation.arithmetic.shell
        - match: \)\)
          scope: punctuation.section.interpolation.end.shell
          pop: 1
        - include: expression

  expansion-brace:
    - match: \{
      scope: punctuation.section.interpolation.begin.shell
      push:
        - meta_scope: meta.interpolation.brace.shell
        - match: \}
          scope: punctuation.section.interpolation.end.shell
          pop: 1
        - match: \,
          scope: punctuation.separator.sequence.shell
        - include: expansion-and-string

  expansion-command:
    - match: \$\(
      scope: punctuation.section.interpolation.begin.shell
      push:
        - meta_scope: meta.interpolation.command.shell
        - match: \s*(\))
          captures:
            1: punctuation.section.interpolation.end.shell
          pop: 1
        - include: statements
    - match: \`
      scope:
        meta.interpolation.command.shell
        punctuation.section.interpolation.begin.shell
      embed: statements
      embed_scope: meta.interpolation.command.shell
      escape: (?<![^\\]\\)(?<![\\]{3})\`
      escape_captures:
        0: meta.interpolation.command.shell
           punctuation.section.interpolation.end.shell

  expansion-job:
    # There are a number of ways to refer to a job in the shell.
    # The symbols ‘%%’ and ‘%+’ refer to the shell’s notion of the current job,
    # which is the last job stopped while it was in the foreground or started in
    # the background. The previous job may be referenced using ‘%-’.
    - match: (%)[-+%]
      scope:
        meta.interpolation.job.shell
        variable.language.job.shell
      captures:
        1: punctuation.definition.variable.shell
    # The character ‘%’ introduces a job specification (jobspec). Job number n
    # may be referred to as ‘%n’.
    - match: (%)(\d+)
      scope:
        meta.interpolation.job.shell
        variable.language.job.shell
      captures:
        1: punctuation.definition.variable.shell
        2: constant.numeric.integer.decimal.shell
    # A job may also be referred to using a prefix of the name used to start it,
    # or using a substring that appears in its command line. For example, ‘%ce’
    # refers to a stopped ce job. Using ‘%?ce’, on the other hand, refers to any
    # job containing the string ‘ce’ in its command line. If the prefix or
    # substring matches more than one job, Bash reports an error.
    # A single ‘%’ (with no accompanying job specification) also refers to the
    # current job.
    - match: (%)(?:(\??)\w+)?
      scope:
        meta.interpolation.job.shell
        variable.other.readwrite.shell
      captures:
        1: punctuation.definition.variable.shell
        2: keyword.operator.regexp.quantifier.shell

  expansion-parameter:
    - match: \$\{
      scope: punctuation.section.interpolation.begin.shell
      push:
        - expansion-parameter-meta
        - expansion-parameter-post-first-char
        - expansion-parameter-first-char
    - match: (\$)[$#@!~*?_-](?!\w)
      scope:
        meta.interpolation.parameter.shell
        variable.language.shell
      captures:
        1: punctuation.definition.variable.shell
    - match: (\$)(?:\d|{{identifier}})
      scope:
        meta.interpolation.parameter.shell
        variable.other.readwrite.shell
      captures:
        1: punctuation.definition.variable.shell

  expansion-parameter-meta:
    - meta_scope: meta.interpolation.parameter.shell
    - include: immediately-pop

  expansion-parameter-first-char:
    - match: \!
      scope: keyword.operator.indirection.shell
      pop: 1
    - match: \#
      scope: keyword.operator.arithmetic.shell
      pop: 1
    - include: immediately-pop

  expansion-parameter-post-first-char:
    - include: expansion-parameter-common    
    - match: ([@*])?(/)
      captures:
        1: variable.language.shell
        2: keyword.operator.substitution.shell
      set:
        - expansion-parameter-pattern
        - expansion-parameter-switch
    - match: \:?[-+=?]
      scope: keyword.operator.assignment.shell
      set: expansion-parameter-common
    - match: (@)?(:)
      captures:
        1: variable.language.shell
        2: keyword.operator.substring.begin.shell
      set:
        - match: ":"
          scope: keyword.operator.substring.end.shell
          set:
            - include: expression
            - include: expansion-parameter-common
        - include: expression
        - include: expansion-parameter-common
    - match: \#(?=})
    - match: ([@*])?(\#\#?|%%?|\^\^?|,,?)
      captures:
        1: variable.language.shell
        2: keyword.operator.expansion.shell
      set:
        - include: expansion-parameter-common
        - include: expansion-pattern
    - match: ([@*]?)(@)([QEPAa])(?=})
      captures:
        1: variable.language.shell
        2: keyword.operator.expansion.shell
        3: variable.parameter.switch.shell
    - include: array
    - match: '[@*](?=})'
      scope: variable.language.shell

  expansion-parameter-common:
    - match: \}
      scope: punctuation.section.interpolation.end.shell
      pop: 1
    - match: '{{identifier_char}}+'
      scope: variable.other.readwrite.shell
    - include: variable-expansions

  expansion-parameter-pattern:
    - match: /
      scope: keyword.operator.substitution.shell
      set: expansion-parameter-common
    - include: expansion-parameter-common
    - include: expansion-pattern

  expansion-parameter-switch:
    - match: '[/#%]'
      scope: variable.parameter.switch.shell
      pop: 1
    - include: immediately-pop

  expansion-pattern:
    - match: ([?*+@!])(\()
      captures:
        1: keyword.operator.regexp.quantifier.shell
        2: meta.group.shell
           punctuation.section.group.begin.shell
      push:
        - meta_content_scope: meta.group.shell
        - match: \)
          scope:
            meta.group.shell
            punctuation.section.group.end.shell
          pop: 1
        - match: \|
          scope: keyword.operator.logical.or.shell
        - include: expansion-and-string
    - match: '[*?]'
      scope: keyword.operator.regexp.quantifier.shell
    - match: \[(?=.*])
      scope: keyword.control.regexp.set.begin.shell
      push:
        - expansion-pattern-post-first-char
        - expansion-pattern-first-char

  expansion-pattern-first-char:
    - match: '[!^]'
      scope: keyword.operator.logical.not.shell
      pop: 1
    - match: \-
      pop: 1
    - include: immediately-pop

  expansion-pattern-post-first-char:
    - match: (?:-)?(\])
      captures:
        1: keyword.control.regexp.set.end.shell
      pop: 1
    - match: \-
      scope: keyword.operator.word.shell
    - match: (\.)[[:word:]](\.)
      captures:
        1: punctuation.separator.collate.begin.shell
        2: punctuation.separator.collate.end.shell
    - match: (=)[[:word:]](=)
      captures:
        1: punctuation.separator.equivalence-class.begin.shell
        2: punctuation.separator.equivalence-class.end.shell
    - match: (:)[[:lower:]]+(:)
      captures:
        1: punctuation.separator.character-class.begin.shell
        2: punctuation.separator.character-class.end.shell
    # You cannot have a regex set inside a regex set, so just consume this
    # character in order to not push into another regex set.
    # Except when writing a character class like [:lower:], so negative look
    # ahead for that possibility.
    - match: \[(?![\.=:])
    - include: expansion-and-string

  expansion-tilde:
    - match: '~'
      scope: meta.interpolation.tilde.shell variable.language.tilde.shell

###[ STRINGS ]#################################################################

  string:
    - include: any-escapes
    - include: string-quoted-double
    - include: string-quoted-single
    - include: string-ansi-c
    - include: string-locale

  # nothing is escaped in a singly-quoted string!
  string-quoted-single:
    - match: \'
      scope: punctuation.definition.string.begin.shell
      push: string-quoted-single-body

  string-quoted-single-body:
    - meta_scope: meta.string.shell string.quoted.single.shell
    - match: \'
      scope: punctuation.definition.string.end.shell
      pop: 1

  string-quoted-double:
    - match: \"
      scope: punctuation.definition.string.begin.shell
      push: string-quoted-double-body

  string-quoted-double-body:
    - meta_scope: meta.string.shell string.quoted.double.shell
    - match: \"
      scope: punctuation.definition.string.end.shell
      pop: 1
    - include: line-continuations
    - include: string-escapes
    - include: string-interpolations

  # [Bash] 3.1.2.4
  string-ansi-c:
    - match: \$'
      scope: punctuation.definition.string.begin.shell
      push: string-ansi-c-body

  string-ansi-c-body:
    - meta_scope: meta.string.shell string.quoted.single.ansi-c.shell
    - match: \'
      scope: punctuation.definition.string.end.shell
      pop: 1
    - include: line-continuations
    - include: string-escapes-ansi-c

  # [Bash] 3.1.2.5
  # If the string is translated and replaced, the replacement is double-quoted.
  string-locale:
    - match: \$"
      scope: punctuation.definition.string.begin.shell
      push: string-locale-body

  string-locale-body:
    - meta_scope: meta.string.shell string.quoted.double.locale.shell
    - match: \"
      scope: punctuation.definition.string.end.shell
      pop: 1
    - include: line-continuations
    - include: string-escapes
    - include: string-interpolations

  any-escapes:
    - match: \\.
      scope: constant.character.escape.shell

  string-escapes:
    - match: \\[$`"\\]
      scope: constant.character.escape.shell

  string-escapes-ansi-c:
    - match: \\([abfnrtv'"?$`\\]|[0-8]{1,3}|x\h{1,8}|c[a-z])
      scope: constant.character.escape.shell

  string-interpolations:
    - match: '{{is_interpolation}}'
      push:
        - clear_scopes: 1
        - include: expansion-parameter
        - include: expansion-arithmetic
        - include: expansion-command
        - include: immediately-pop
