%YAML 1.2
---
# https://www.sublimetext.com/docs/syntax.html
# https://www.gnu.org/software/bash/manual/bash.html
name: Bash
scope: source.shell.bash
version: 2

file_extensions:
  - sh
  - bash
  - ash
  - zsh

hidden_file_extensions:
  - .bash_aliases
  - .bash_completions
  - .bash_functions
  - .bash_login
  - .bash_logout
  - .bash_profile
  - .bash_variables
  - .bashrc
  - .ebuild
  - .eclass
  - .profile
  - .textmate_init
  - .zlogin
  - .zlogout
  - .zprofile
  - .zshenv
  - .zshrc
  - PKGBUILD  # https://jlk.fjfi.cvut.cz/arch/manpages/man/PKGBUILD.5

first_line_match: |-
  (?x:
    ^\#! .* \b(bash|zsh|sh|tcsh|ash)\b |        # shebang
    ^\# \s* -\*- [^*]* shell-script [^*]* -\*-  # editorconfig
  )

###############################################################################

variables:
  identifier: '[[:alpha:]_][[:alnum:]_]*'
  identifier_non_posix: '[^{{metachar}}\d][^{{metachar}}=]*'
  is_end_of_option: '[^\w$-]|$'
  is_interpolation: (?=\$([\d({]|[$#@!~*?_-](?!\w)|{{identifier}})|`)
  is_variable: (?=\s*{{nbc}}(?:[({]{{nbc}}[)}])?{{nbc}}=)
  keyword_break: (?![-=\w])

  # A character that, when unquoted, separates words. A metacharacter is a
  # space, tab, newline, or one of the following characters: ‘|’, ‘&’, ‘;’,
  # ‘(’, ‘)’, ‘<’, or ‘>’.
  metachar: '[\s|&;()<>]'

  nbc: '[^{}()=\s]*' # non bracket characters (and also non-whitespace, parens)
  start_of_option: (?:\s+|^)--?(?=[\w$])
  varassign: '[+\-?]?='

###############################################################################

contexts:
  main:
    - meta_include_prototype: false
    - include: comment
    - include: coproc
    - include: funcdef
    - include: vardef
    - include: line-continuation
    - include: operator-exclamation
    - include: redirection
    - include: cmd

  statement:
    - meta_include_prototype: false
    - include: eol-pop
    - include: main

###[ PROTOTYPES ]##############################################################

  prototype:
    - include: line-continuation
    - include: any-escape

  any-escape:
    - match: \\.
      scope: constant.character.escape.shell

  eol-pop:
    - match: $|(?=\s+#)
      pop: 1

  line-continuation:
    - match: \\\n
      scope: punctuation.separator.continuation.line.shell
      push:
        - match: ^
          pop: 1
    - match: \\(\s+)\n
      captures:
        1: invalid.illegal.extraneous-spaces-after-line-continuation.shell

  immediately-pop:
    - match: ''
      pop: 1

  else-pop:
    - match: (?=\S)
      pop: 1

###[ COMMENTS ]################################################################

  comment:
    - match: \#
      scope: punctuation.definition.comment.shell
      push:
        - meta_include_prototype: false
        - meta_scope: comment.line.number-sign.shell
        # NOTE: The reason for consuming the newline character is as follows.
        # When triggering a snippet, its scope is tested to the *right* of the
        # cursor. So, if you don't want your snippet to trigger in a comment,
        # you have to use something like <scope>source.shell - comment</scope>.
        # If the newline character is not scoped as a comment too, then that
        # scope will never work, because the scope to the right of the cursor
        # will never be a comment scope. That is, unless we consume the newline
        # character (or we are editing something in the middle of an existing
        # comment).
        - match: \n
          pop: 1
        - include: line-continuation

###[ COPROCESSES ]#############################################################

  coproc:
    - match: coproc{{keyword_break}}
      scope:
        meta.coproc.shell
        storage.type.coproc.shell
        keyword.declaration.coproc.shell
      push:
        # Extended Coproc Syntax
        - match: (\s*(\S+)\s*)(\{)
          captures:
            1: meta.coproc.identifier.shell
            2: entity.name.coproc.shell
            3: meta.coproc.command.shell meta.compound.shell
               punctuation.section.compound.begin.shell
          set:
            - meta_include_prototype: false
            - meta_content_scope:
                meta.coproc.command.shell meta.compound.shell
            - match: \}
              scope:
                meta.coproc.command.shell meta.compound.shell
                punctuation.section.compound.end.shell
              set:
                - meta_content_scope: meta.coproc.shell
                - include: cmd-args
            - include: main
        # Basic Coproc Syntax
        - match: ''
          set:
            - meta_include_prototype: false
            - meta_scope: meta.coproc.command.shell
            - include: statement

###[ FUNCTIONS ]###############################################################

  funcdef:
    # [Bash] 3.3 Shell Functions
    - match: (?=\s*{{identifier_non_posix}}\s*\(\s*\))
      push:
        - funcdef-redirection
        - funcdef-body
        - funcdef-params
        - funcdef-name
    - match: function{{keyword_break}}
      scope:
        meta.function.shell
        storage.type.function.shell
        keyword.declaration.function.shell
      push:
        - funcdef-redirection
        - funcdef-body
        - funcdef-params
        - funcdef-name

  funcdef-name:
    - match: (?=\S)
      set:
        - meta_content_scope: entity.name.function.shell
        - match: \s*(?=[({])
          pop: 1
        - include: eol-pop
    - include: eol-pop

  funcdef-params:
    - clear_scopes: 1
    - meta_content_scope: meta.function.identifier.shell
    - match: (\()\s*(\))
      scope: meta.function.parameters.shell
      captures:
        1: punctuation.section.parameters.begin.shell
        2: punctuation.section.parameters.end.shell
      pop: 1
    - include: else-pop

  funcdef-body:
    - match: \{
      scope: punctuation.section.compound.begin.shell
      set:
        - meta_include_prototype: false
        - meta_scope: meta.compound.shell
        - match: \}
          scope: punctuation.section.compound.end.shell
          pop: 1
        - include: main
    - match: \(
      scope: punctuation.section.compound.begin.shell
      set:
        - meta_include_prototype: false
        - meta_scope: meta.compound.shell
        - match: \)
          scope: punctuation.section.compound.end.shell
          pop: 1
        - include: main
    - include: comment
    - include: else-pop

  funcdef-redirection:
    - meta_content_scope: meta.function.shell
    - include: redirection
    - include: else-pop
    - include: eol-pop

###[ VARDEFS ]#################################################################

  vardef:
    - match: alias{{keyword_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.alias.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-alias-name
        - vardef-alias-options
    - match: (typeset|declare|local){{keyword_break}}
      scope:
        meta.function-call.identifier.shell
        storage.modifier.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-name
        - vardef-declare-options
    - match: export{{keyword_break}}
      scope:
        meta.function-call.identifier.shell
        storage.modifier.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-name
        - vardef-export-options
    - match: readonly{{keyword_break}}
      scope:
        meta.function-call.identifier.shell
        storage.modifier.shell
      push:
        - vardef-maybe-more
        - vardef-value
        - vardef-assign
        - vardef-name
        - vardef-readonly-options
    - match: '{{is_variable}}'
      push:
        - vardef-value
        - vardef-assign
        - vardef-name

  vardef-maybe-more:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: cmd-args-boilerplate-with-end-of-options
    - match: (?=\S)
      push: [vardef-value, vardef-assign, vardef-name]

  vardef-alias-name:
    - match: (?=\S)
      set:
        - meta_content_scope:
            meta.variable.shell
            entity.name.function.alias.shell
        - match: (?=\s|{{varassign}})
          pop: 1
        - include: array
        - include: string
        - include: string-interpolation
    - include: eol-pop

  vardef-alias-options:
    - match: (-)p
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: else-pop
    - include: eol-pop

  vardef-declare-options:
    - match: (-)(?:[aAfFgilnrtux]+|p)
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: else-pop
    - include: eol-pop

  vardef-export-options:
    - match: (-)(?:[fn]+|p)
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: else-pop
    - include: eol-pop

  vardef-readonly-options:
    - match: (-)(?:[aAf]+|p)
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - include: else-pop
    - include: eol-pop

  vardef-name:
    - match: (?=\S)
      set:
        - meta_content_scope:
            meta.variable.shell
            variable.other.readwrite.shell
        - match: (?={{varassign}}|{{metachar}})
          pop: 1
        - include: array
        - include: string
        - include: string-interpolation
    - include: eol-pop

  vardef-assign:
    - match: '{{varassign}}'
      scope: keyword.operator.assignment.shell
      pop: 1
    - include: immediately-pop

  vardef-value:
    - match: \(
      scope: punctuation.section.sequence.begin.shell
      set:
        - meta_scope: meta.sequence.shell
        - match: \)
          scope: punctuation.section.sequence.end.shell
          pop: 1
        - match: \[
          scope: punctuation.section.brackets.begin.shell
          push:
            - meta_scope: meta.brackets.shell
            - match: \]
              scope: punctuation.section.brackets.end.shell
              set:
                - match: =
                  scope: keyword.operator.assignment.shell
                  pop: 1
                - include: immediately-pop
            - include: expansion-and-string
            - include: comment
        - include: expansion-and-string
        - include: comment
    - match: ''
      set:
        - meta_scope: meta.string.shell string.unquoted.shell
        - match: (?=\$?["'])
          push:
            - clear_scopes: 2
            - meta_include_prototype: false
            - include: string
            - include: immediately-pop
        - match: '{{is_interpolation}}'
          push:
            - clear_scopes: 1
            - meta_include_prototype: false
            - include: expansion
            - include: immediately-pop
        - match: (?={{metachar}})
          pop: 1

###[ COMMANDS ]################################################################

  cmd:
    - include: cmd-arithmetic
    - include: cmd-compound
    - include: cmd-test
    - include: cmd-control
    - include: scope:commands.builtin.shell.bash#main
    - match: (?=\S)
      push: [cmd-post, cmd-args, cmd-name]

  cmd-arithmetic:
    - include: arithmetic
    - match: let{{keyword_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.let.shell
      push:
        - meta_content_scope: meta.function-call.arguments.shell
        - include: cmd-args-boilerplate-with-end-of-options
        - include: expression

  cmd-compound:
    - match: \(
      scope: punctuation.section.compound.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.compound.shell
        - match: \)
          scope: punctuation.section.compound.end.shell
          set: [cmd-post, cmd-compound-args]
        - include: main
    - match: \{(?=\s)
      scope: punctuation.section.compound.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.compound.shell
        - match: \}
          scope: punctuation.section.compound.end.shell
          set: [cmd-post, cmd-compound-args]
        - include: main

  cmd-compound-args:
    - meta_content_scope: meta.compound.arguments.shell
    - include: cmd-args

  cmd-test:
    - match: \[\[(?=\s)
      scope: support.function.double-brace.begin.shell
      push:
        - meta_scope: meta.function-call.arguments.shell
        - match: \s+(\]\])
          captures:
            1: support.function.double-brace.end.shell
          set: cmd-post
        - include: expression-test
    - match: \[(?=\s)
      scope: support.function.test.begin.shell
      push:
        - meta_scope: meta.function-call.arguments.shell
        - match: \s+(\])
          captures:
            1: support.function.test.end.shell
          set: cmd-post
        - include: expression-test
    - match: test{{keyword_break}}
      scope:
        meta.function-call.identifier.shell
        support.function.test.shell
      push:
        - meta_content_scope: meta.function-call.arguments.shell
        - include: cmd-args-boilerplate
        - include: expression-test

  cmd-name:
    - clear_scopes: 1
    - meta_scope: meta.function-call.identifier.shell
    - include: string
    - include: expansion-parameter
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde
    - include: expansion-job
    - match: '[^\s`=|&;()}<>]'
      scope: variable.function.shell
    - include: immediately-pop

  cmd-args:
    - meta_content_scope: meta.function-call.arguments.shell
    - include: cmd-args-boilerplate-with-end-of-options
    - match: '{{start_of_option}}'
      scope:
        variable.parameter.option.shell
        punctuation.definition.parameter.shell
      push:
        - meta_content_scope: variable.parameter.option.shell
        - match: =
          scope: keyword.operator.assignment.shell
          pop: 1
        - match: (?={{is_end_of_option}})
          pop: 1
        - include: expansion-and-string

  cmd-args-boilerplate:
    # NOTE: this context is used in commands-builtin-shell-bash.sublime-syntax
    - include: redirection
    - match: (?=[)}]|\s*([|;]|&(?!>)))
      pop: 1
    - include: eol-pop
    - include: expansion-and-string

  cmd-args-boilerplate-with-end-of-options:
    # NOTE: this context is used in commands-builtin-shell-bash.sublime-syntax
    - include: cmd-args-boilerplate
    - match: (?:\s+|^)--(?=\s|;|$|\))
      scope: keyword.operator.end-of-options.shell
      set:
        - meta_content_scope: meta.function-call.arguments.shell
        - include: redirection
        - match: (?=[)};&|])
          pop: 1
        - include: eol-pop
        - include: expansion-and-string

  cmd-post: # looks like [main, cmd-post] at this point
    # NOTE: this context is used in commands-builtin-shell-bash.sublime-syntax
    - match: ;(?![;&])
      scope: keyword.operator.logical.continue.shell
      pop: 1
    - match: \|\|
      scope: keyword.operator.logical.or.shell
      pop: 1
    - match: \|
      scope: keyword.operator.logical.pipe.shell
      pop: 1
    - match: \&\&
      scope: keyword.operator.logical.and.shell
      pop: 1
    - match: \&
      scope: keyword.operator.logical.job.shell
      pop: 1
    - include: else-pop
    - include: eol-pop

###[ CONTROL STATEMENTS ]######################################################

  cmd-control:
    # conditional
    - match: if{{keyword_break}}
      scope: keyword.control.conditional.if.shell
    - match: then{{keyword_break}}
      scope: keyword.control.conditional.then.shell
    - match: elif{{keyword_break}}
      scope: keyword.control.conditional.elseif.shell
    - match: fi{{keyword_break}}
      scope: keyword.control.conditional.end.shell
    - match: else{{keyword_break}}
      scope: keyword.control.conditional.else.shell
    - match: case{{keyword_break}}
      scope: keyword.control.conditional.case.shell
      push: [case-body, case-word]
    - match: esac{{keyword_break}}
      scope: keyword.control.conditional.end.shell
    # loops
    - match: do{{keyword_break}}
      scope: keyword.control.loop.do.shell
    - match: done{{keyword_break}}
      scope: keyword.control.loop.end.shell
    - match: for{{keyword_break}}
      scope: keyword.control.loop.for.shell
      push: for-args
    - match: select{{keyword_break}}
      scope: keyword.control.loop.select.shell
      push: select-args
    - match: until{{keyword_break}}
      scope: keyword.control.loop.until.shell
    - match: while{{keyword_break}}
      scope: keyword.control.loop.while.shell
    # flow
    - match: break{{keyword_break}}
      scope: keyword.control.flow.break.shell
      push: flow-args
    - match: continue{{keyword_break}}
      scope: keyword.control.flow.continue.shell
      push: flow-args
    - match: exit{{keyword_break}}
      scope: keyword.control.flow.exit.shell
      push: flow-args
    - match: return{{keyword_break}}
      scope: keyword.control.flow.return.shell
      push: flow-args

  case-word:
    - match: in{{keyword_break}}
      scope: keyword.control.in.shell
      pop: 1
    - include: comment
    - include: case-end-ahead
    - include: expansion-and-string

  case-body:
    - meta_scope: meta.conditional.case.shell
    - include: comment
    - include: case-end
    - match: \(|(?=\S)
      scope: keyword.control.conditional.patterns.begin.shell
      push:
        - case-clause-commands
        - case-clause-patterns

  case-clause-patterns:
    - clear_scopes: 1  # remove meta.conditional.case.shell
    - meta_scope: meta.conditional.case.clause.patterns.shell
    - match: \)
      scope: keyword.control.conditional.patterns.end.shell
      pop: 1
    # emergency bail outs if ')' is missing
    - match: (?=;;&?|;&)
      pop: 1
    - include: case-clause-patterns-body

  case-clause-patterns-body:
    # [Bash] 3.2.4.2: Each pattern undergoes tilde expansion, parameter
    # expansion, command substitution, and arithmetic expansion.
    - match: \(
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.shell
        - match: \)
          scope: punctuation.section.group.end.shell
          pop: 1
        - include: case-clause-patterns-body
    - match: \|
      scope: keyword.operator.logical.shell
    - include: case-end-ahead
    - include: expansion-pattern
    - include: expansion-tilde
    - include: expansion-parameter
    - include: expansion-command
    - include: expansion-arithmetic
    - include: string
    - include: eol-pop

  case-clause-commands:
    - clear_scopes: 1  # remove meta.conditional.case.shell
    - meta_include_prototype: false
    - meta_scope: meta.conditional.case.clause.commands.shell
    - match: ;;&?|;&
      scope: punctuation.terminator.case.clause.shell
      pop: 1
    - include: case-end-ahead
    - include: main

  case-end-ahead:
    - match: (?=esac{{keyword_break}})
      pop: 1

  case-end:
    - match: esac{{keyword_break}}
      scope: keyword.control.conditional.end.shell
      pop: 1

  flow-args:
    - include: cmd-args-boilerplate
    - include: expression

  for-args:
    - include: cmd-args-boilerplate
    - include: arithmetic
    - match: in{{keyword_break}}
      scope: keyword.control.in.shell

  select-args:
    - include: cmd-args-boilerplate
    - include: expansion-and-string
    - match: in{{keyword_break}}
      scope: keyword.control.in.shell

###[ REDIRECTIONS AND HEREDOCS ]###############################################

  redirection:
    - include: redirection-here-string
    - include: redirection-here-document
    - include: redirection-process
    - include: redirection-input
    - include: redirection-output
    - include: redirection-inout

  redirection-process:
    - match: (\d*)([<>])(\()
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.process.shell
        3: meta.compound.shell
           punctuation.section.compound.begin.shell
      push:
        - meta_include_prototype: false
        - meta_content_scope: meta.compound.shell
        - match: \)
          scope:
            meta.compound.shell
            punctuation.section.compound.end.shell
          pop: 1
        - include: main

  redirection-output:
    - match: (\d*)(>>!?|>&?|&>|&?>(?:\||>))
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
      push: redirection-post

  redirection-input:
    - match: (\d*)(<&?)
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
      push: redirection-post

  redirection-post:
    - match: \s*(?:(\d+)|(-))
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: punctuation.terminator.file-descriptor.shell
      pop: 1
    - match: \s*(?=\S)
      set:
        - match: (?={{metachar}})
          pop: 1
        - include: expansion-and-string
    - match: \s*
      pop: 1

  redirection-inout:
    - match: (\d*)(<>)
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell

  redirection-here-string:
    - match: (\d*)(<<<)(?![-|&;<>])
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.herestring.shell

  redirection-here-document:
    # These are the variants that allow tabs before the end token
    - match: (\d*)(<<-)\s*(')({{identifier}})(')
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*(")({{identifier}})(")
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*(\\)({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.shell
        4: keyword.control.heredoc-token.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: keyword.control.heredoc-token.shell
      push: [heredocs-body-allow-tabs, heredocs-preamble]
    # These are the variants that DON'T allow tabs before the end token
    - match: (\d*)(<<)\s*(')({{identifier}})(')
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*(")({{identifier}})(")
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*(\\)({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.shell
        4: keyword.control.heredoc-token.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*({{identifier}})
      captures:
        1: constant.numeric.integer.decimal.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: keyword.control.heredoc-token.shell
      push: [heredocs-body, heredocs-preamble]

  heredocs-body:
    - meta_include_prototype: false
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - include: heredocs-body-common-with-expansion
    - match: ^\3(\s+)\n # the third capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\3$ # the third capture from redirection-here-document
      scope: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-body-allow-tabs:
    - meta_include_prototype: false
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - include: heredocs-body-common-with-expansion
    - match: ^\s*\3(\s+)\n # the third capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\s*(\3)$ # the third capture from redirection-here-document
      captures:
        1: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-body-common-with-expansion:
    # [Bash] 3.6.6: all lines of the here-document are subjected to parameter
    # expansion, command substitution, and arithmetic expansion, the character
    # sequence \newline is ignored, and ‘\’ must be used to quote the
    # characters ‘\’, ‘$’, and ‘`’.
    - include: string-escape
    - include: string-interpolation

  heredocs-body-no-expansion:
    - meta_include_prototype: false
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - match: ^\4(\s+)\n # the fourth capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\4$ # the fourth capture from redirection-here-document
      scope: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-body-allow-tabs-no-expansion:
    - meta_include_prototype: false
    - meta_scope: meta.string.shell string.unquoted.heredoc.shell
    - match: ^\s*\4(\s+)\n # the fourth capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: 1
    - match: ^\s*(\4)$ # the fourth capture from redirection-here-document
      captures:
        1: keyword.control.heredoc-token.shell
      pop: 1

  heredocs-preamble:
    - match: ''
      set:
        # This enables us to keep parsing on the line where the start token of
        # the heredoc is. Once the first line has ended, we enter the body of
        # the heredoc, where everything is just an unquoted string.
        # One clear_scope for the string.unquoted.
        # The problem with this is that when we also end a function definition
        # on the same line (with the "}" token), we cannot do that.
        - clear_scopes: 1
        - include: eol-pop
        - match: \s*(?=\S)
          set: [statement, cmd-post, cmd-args]

###[ EXPRESSIONS ]#############################################################

  array:
    - match: \[
      scope: punctuation.section.item-access.begin.shell
      push:
        - clear_scopes: 1
        - meta_scope: meta.item-access.shell
        - match: \]
          scope: punctuation.section.item-access.end.shell
          pop: 1
        - match: '[*@]'
          scope: variable.language.array.shell
        - include: expression

  arithmetic:
    - match: \(\((?=.+\)\))
      scope: punctuation.section.arithmetic.begin.shell
      push:
        - meta_scope: meta.arithmetic.shell
        - match: \)\)
          scope: punctuation.section.arithmetic.end.shell
          pop: 1
        - include: expression

  expression:
    - match: \(
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.shell
        - match: \)
          scope: punctuation.section.group.end.shell
          pop: 1
        - include: expression
    # multi char operators
    - match: '[-+*/%&|^]=|<<=|>>='
      scope: keyword.operator.assignment.augmented.shell
    - match: <[=<]?|>[=>]?|[=!]=|&&|\|\||!
      scope: keyword.operator.logical.shell
    # single char operators
    - match: '[-+*/%]'
      scope: keyword.operator.arithmetic.shell
    - match: '='
      scope: keyword.operator.assignment.shell
    - match: '[&|^~]'
      scope: keyword.operator.bitwise.shell
    - match: ;
      scope: punctuation.separator.expressions.shell
    - match: \,
      scope: punctuation.separator.sequence.shell
    - match: \:|\?
      scope: keyword.operator.ternary.shell
    # Shell variables are allowed as operands; parameter expansion is performed
    # before the expression is evaluated. Within an expression, shell variables
    # may also be referenced by name without using the parameter expansion
    # syntax.
    - include: numbers
    - include: string
    - include: expansion-parameter
    - include: expansion-arithmetic
    - include: expansion-command

  expression-test:
    - match: \(
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.shell
        - match: \)
          scope: punctuation.section.group.end.shell
          pop: 1
        - include: expression-test
    - match: (-)[aobcdefghknoprstuvwxzGLNORS](?=\s)
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - match: (-)(?:ef|nt|ot|eq|ne|lt|le|gt|ge)(?=\s)
      scope: variable.parameter.option.shell
      captures:
        1: punctuation.definition.parameter.shell
    - match: (=~)\s*
      captures:
        1: keyword.operator.logical.shell
      push:
        - meta_content_scope: meta.regexp.shell
        - match: (?=\s)
          pop: 1
        - include: expansion-and-string
    - match: ==|!=?|<|>|\|\||&&
      scope: keyword.operator.logical.shell
    - match: '='
      scope: keyword.operator.assignment.shell
    - include: numbers
    - include: expansion-and-string

  numbers:
    # A leading ‘0x’ or ‘0X’ denotes hexadecimal.
    - match: (\b0[xX])(\h*)
      captures:
        1: meta.number.base.shell constant.numeric.integer.hexadecimal.shell
        2: meta.number.value.shell constant.numeric.integer.hexadecimal.shell
    # Constants with a leading 0 are interpreted as octal numbers.
    - match: (\b0)([0-7]+)
      captures:
        1: meta.number.base.shell constant.numeric.integer.octal.shell
        2: meta.number.value.shell constant.numeric.integer.octal.shell
    # Otherwise, numbers take the form [base#]n, where the optional base is a
    # decimal number between 2 and 64 representing the arithmetic base, and n is
    # a number in that base. When specifying n, the digits greater than 9 are
    # represented by the lowercase letters, the uppercase letters, ‘@’, and ‘_’,
    # in that order.
    - match: \b(\d+#)([a-zA-Z0-9@_]+)
      captures:
        1: meta.number.base.shell constant.numeric.integer.other.shell
        2: meta.number.value.shell constant.numeric.integer.other.shell
    # If base# is omitted, then base 10 is used.
    - match: \b\d+
      scope: meta.number.value.shell constant.numeric.integer.decimal.shell

  operator-exclamation:
    - match: \!(?!\S)
      scope: keyword.operator.logical.shell
    - match: (\!)(-?\d+|!)
      scope: variable.language.history.shell
      captures:
        1: punctuation.definition.history.shell
    - match: \!
      scope: punctuation.definition.history.shell

###[ EXPANSIONS ]##############################################################

  expansion-and-string:
    - include: string
    - include: expansion

  expansion:
    - include: expansion-pattern
    - include: expansion-parameter
    - include: expansion-brace
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde
    - include: expansion-job

  expansion-arithmetic:
    - match: \$\(\((?=.+\)\))
      scope: punctuation.section.interpolation.begin.shell
      push:
        - meta_scope: meta.interpolation.arithmetic.shell
        - match: \)\)
          scope: punctuation.section.interpolation.end.shell
          pop: 1
        - include: expression

  expansion-brace:
    - match: \{
      scope: punctuation.section.interpolation.begin.shell
      push:
        - meta_scope: meta.interpolation.brace.shell
        - match: \}
          scope: punctuation.section.interpolation.end.shell
          pop: 1
        - match: \,
          scope: punctuation.separator.sequence.shell
        - include: expansion-and-string

  expansion-command:
    - match: \$\(
      scope: punctuation.section.interpolation.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.interpolation.command.shell
        - match: \s*(\))
          captures:
            1: punctuation.section.interpolation.end.shell
          pop: 1
        - include: main
    - match: \`
      scope:
        meta.interpolation.command.shell
        punctuation.section.interpolation.begin.shell
      embed: main
      embed_scope: meta.interpolation.command.shell
      escape: (?<![^\\]\\)(?<![\\]{3})\`
      escape_captures:
        0: meta.interpolation.command.shell
           punctuation.section.interpolation.end.shell

  expansion-job:
    # There are a number of ways to refer to a job in the shell.
    # The symbols ‘%%’ and ‘%+’ refer to the shell’s notion of the current job,
    # which is the last job stopped while it was in the foreground or started in
    # the background. The previous job may be referenced using ‘%-’.
    - match: (%)[-+%]
      scope:
        meta.interpolation.job.shell
        variable.language.job.shell
      captures:
        1: punctuation.definition.variable.shell
    # The character ‘%’ introduces a job specification (jobspec). Job number n
    # may be referred to as ‘%n’.
    - match: (%)(\d+)
      scope:
        meta.interpolation.job.shell
        variable.language.job.shell
      captures:
        1: punctuation.definition.variable.shell
        2: constant.numeric.integer.decimal.shell
    # A job may also be referred to using a prefix of the name used to start it,
    # or using a substring that appears in its command line. For example, ‘%ce’
    # refers to a stopped ce job. Using ‘%?ce’, on the other hand, refers to any
    # job containing the string ‘ce’ in its command line. If the prefix or
    # substring matches more than one job, Bash reports an error.
    # A single ‘%’ (with no accompanying job specification) also refers to the
    # current job.
    - match: (%)(?:(\??)\w+)?
      scope:
        meta.interpolation.job.shell
        variable.other.readwrite.shell
      captures:
        1: punctuation.definition.variable.shell
        2: keyword.operator.regexp.quantifier.shell

  expansion-parameter:
    - match: \$\{
      scope: punctuation.section.interpolation.begin.shell
      push:
        - expansion-parameter-meta
        - expansion-parameter-post-first-char
        - expansion-parameter-first-char
    - match: (\$)[$#@!~*?_-](?!\w)
      scope:
        meta.interpolation.parameter.shell
        variable.language.shell
      captures:
        1: punctuation.definition.variable.shell
    - match: (\$)(?:\d|{{identifier}})
      scope:
        meta.interpolation.parameter.shell
        variable.other.readwrite.shell
      captures:
        1: punctuation.definition.variable.shell

  expansion-parameter-meta:
    - meta_scope: meta.interpolation.parameter.shell
    - include: immediately-pop

  expansion-parameter-first-char:
    - meta_include_prototype: false
    - match: \!
      scope: keyword.operator.indirection.shell
      pop: 1
    - match: \#
      scope: keyword.operator.arithmetic.shell
      pop: 1
    - include: immediately-pop

  expansion-parameter-post-first-char:
    - meta_content_scope: variable.other.readwrite.shell
    - include: expansion-parameter-common
    - match: ([@*])?(/)
      captures:
        1: variable.language.shell
        2: keyword.operator.substitution.shell
      set:
        - expansion-parameter-pattern
        - expansion-parameter-switch
    - match: \:?[-+=?]
      scope: keyword.operator.assignment.shell
      set: expansion-parameter-common
    - match: (@)?(:)
      captures:
        1: variable.language.shell
        2: keyword.operator.substring.begin.shell
      set:
        - match: ":"
          scope: keyword.operator.substring.end.shell
          set:
            - include: expression
            - include: expansion-parameter-common
        - include: expression
        - include: expansion-parameter-common
    - match: \#(?=})
    - match: ([@*])?(\#\#?|%%?|\^\^?|,,?)
      captures:
        1: variable.language.shell
        2: keyword.operator.expansion.shell
      set:
        - meta_include_prototype: false
        - include: expansion-parameter-common
        - include: expansion-pattern
    - match: ([@*]?)(@)([QEPAa])(?=})
      captures:
        1: variable.language.shell
        2: keyword.operator.expansion.shell
        3: variable.parameter.switch.shell
    - include: array
    - match: '[@*](?=})'
      scope: variable.language.shell

  expansion-parameter-common:
    - match: \}
      scope: punctuation.section.interpolation.end.shell
      pop: 1
    - include: string
    - include: expansion-parameter
    # no brace expansion
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde
    # no pattern expansion
    - include: any-escape

  expansion-parameter-pattern:
    - match: /
      scope: keyword.operator.substitution.shell
      set: expansion-parameter-common
    - include: expansion-parameter-common
    - include: expansion-pattern

  expansion-parameter-switch:
    - meta_include_prototype: false
    - match: '[/#%]'
      scope: variable.parameter.switch.shell
      pop: 1
    - include: immediately-pop

  expansion-pattern:
    - match: ([?*+@!])(\()
      captures:
        1: keyword.operator.regexp.quantifier.shell
        2: meta.group.shell
           punctuation.section.group.begin.shell
      push:
        - meta_content_scope: meta.group.shell
        - match: \)
          scope:
            meta.group.shell
            punctuation.section.group.end.shell
          pop: 1
        - match: \|
          scope: keyword.operator.logical.or.shell
        - include: expansion-and-string
    - match: '[*?]'
      scope: keyword.operator.regexp.quantifier.shell
    - match: \[(?=.*])
      scope: keyword.control.regexp.set.begin.shell
      push:
        - expansion-pattern-post-first-char
        - expansion-pattern-first-char

  expansion-pattern-first-char:
    - meta_include_prototype: false
    - match: '[!^]'
      scope: keyword.operator.logical.not.shell
      pop: 1
    - match: \-
      pop: 1
    - include: immediately-pop

  expansion-pattern-post-first-char:
    - match: (?:-)?(\])
      captures:
        1: keyword.control.regexp.set.end.shell
      pop: 1
    - match: \-
      scope: keyword.operator.word.shell
    - match: (\.)[[:word:]](\.)
      captures:
        1: punctuation.separator.collate.begin.shell
        2: punctuation.separator.collate.end.shell
    - match: (=)[[:word:]](=)
      captures:
        1: punctuation.separator.equivalence-class.begin.shell
        2: punctuation.separator.equivalence-class.end.shell
    - match: (:)[[:lower:]]+(:)
      captures:
        1: punctuation.separator.character-class.begin.shell
        2: punctuation.separator.character-class.end.shell
    # You cannot have a regex set inside a regex set, so just consume this
    # character in order to not push into another regex set.
    # Except when writing a character class like [:lower:], so negative look
    # ahead for that possibility.
    - match: \[(?![\.=:])
    - include: expansion-and-string

  expansion-tilde:
    - match: '~'
      scope: meta.interpolation.tilde.shell variable.language.tilde.shell

###[ STRINGS ]#################################################################

  string:
    - include: string-quoted-double
    - include: string-quoted-single
    - include: string-ansi-c
    - include: string-locale

  # nothing is escaped in a singly-quoted string!
  string-quoted-single:
    - match: \'
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.string.shell string.quoted.single.shell
        - match: \'
          scope: punctuation.definition.string.end.shell
          pop: 1

  string-quoted-double:
    - match: \"
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.string.shell string.quoted.double.shell
        - include: string-quoted-double-common

  # [Bash] 3.1.2.4
  string-ansi-c:
    - match: \$'
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.string.shell string.quoted.single.ansi-c.shell
        - match: \'
          scope: punctuation.definition.string.end.shell
          pop: 1
        - match: \\([abfnrtv'"?$`\\]|[0-8]{1,3}|x\h{1,8}|c[a-z])
          scope: constant.character.escape.shell
        - include: string-continuation

  # [Bash] 3.1.2.5
  # If the string is translated and replaced, the replacement is double-quoted.
  string-locale:
    - match: \$"
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: meta.string.shell string.quoted.double.locale.shell
        - include: string-quoted-double-common

  string-quoted-double-common:
    - match: \"
      scope: punctuation.definition.string.end.shell
      pop: 1
    - include: string-continuation
    - include: string-escape
    - include: string-interpolation

  string-continuation:
    - match: \\\n
      scope: punctuation.separator.continuation.line.shell

  string-escape:
    - match: \\[$`"\\]
      scope: constant.character.escape.shell

  string-interpolation:
    - match: '{{is_interpolation}}'
      push:
        - clear_scopes: 1
        - meta_include_prototype: false
        - include: expansion-parameter
        - include: expansion-arithmetic
        - include: expansion-command
        - include: immediately-pop
